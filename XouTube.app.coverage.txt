/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/Helper/GlobalDataGenre.m:
    1|       |//
    2|       |//  GlobalDataGenre.m
    3|       |//  XouDevSpec
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/30.
    6|       |//
    7|       |
    8|       |#import "GlobalDataGenre.h"
    9|       |
   10|       |@implementation GlobalDataGenre
   11|       |@synthesize message;
   12|       |static GlobalDataGenre *sharedGlobalData = nil;
   13|       |
   14|      0|+ (GlobalDataGenre*)sharedGlobalData {
   15|      0|    if (sharedGlobalData == nil) {
   16|      0|        sharedGlobalData = [[super allocWithZone:NULL] init];
   17|      0| 
   18|      0|    sharedGlobalData.message = @"";
   19|      0|    }
   20|      0|    return sharedGlobalData;
   21|      0|}
   22|       |
   23|      0|+ (id)allocWithZone:(NSZone *)zone {
   24|      0|    @synchronized(self)
   25|      0|    {
   26|      0|        if (sharedGlobalData == nil)
   27|      0|        {
   28|      0|            sharedGlobalData = [super allocWithZone:zone];
   29|      0|            return sharedGlobalData;
   30|      0|        }
   31|      0|    }
   32|      0|    return nil;
   33|      0|}
   34|       |
   35|      0|- (id)copyWithZone:(NSZone *)zone {
   36|      0|    return self;
   37|      0|}
   38|       |
   39|      0|- (void)mySetMessageFunc {
   40|      0|    self.message = self.genre;
   41|      0|}
   42|       |
   43|       |-(instancetype)initWith:(NSString *)genre;
   44|      0|{
   45|      0|    self = [super init];
   46|      0|    if (self) {
   47|      0|        self.genre = genre;
   48|      0|    } return self;
   49|      0|    
   50|      0|}
   51|       |@end

/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/Model/AnimeJsonSearchStruct.swift:
    1|       |//
    2|       |//  AnimeJsonStruct.swift
    3|       |//  XouDevSpec
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/17.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public struct animeInfo: Decodable {
   11|       |    public var request_hash: String?
   12|       |    public var request_cached: Bool?
   13|       |    public var request_cache_expiry: Int?
   14|       |    public var results = [AnimeDetails]()
   15|       |    public var last_page : Int?
   16|       |
   17|      2|    public init() {
   18|      2|        request_hash.self = ""
   19|      2|        request_cached.self = true
   20|      2|        request_cache_expiry.self = 0
   21|      2|        last_page.self = 0
   22|      2|
   23|      2|    }
   24|       |
   25|       |}
   26|       |
   27|       |
   28|       |public struct AnimeDetails: Decodable {
   29|       |    public var mal_id: Int?
   30|       |    public  var url: String?
   31|       |    public var image_url: String?
   32|       |    public var title: String?
   33|       |    public var airing: Bool?
   34|       |    public var synopsis: String?
   35|       |    public var type: String?
   36|       |    public var episodes: Int?
   37|       |    public var score: Double?
   38|       |    public var start_date: String?
   39|       |    public var end_date: String?
   40|       |    public var members: Int?
   41|       |    public var rated: String?
   42|       |
   43|      2|    public init() {
   44|      2|
   45|      2|        mal_id.self = 0
   46|      2|        url.self = ""
   47|      2|        image_url.self = ""
   48|      2|        title.self = ""
   49|      2|        airing.self = true
   50|      2|        synopsis.self = ""
   51|      2|        type.self = ""
   52|      2|        episodes.self = 0
   53|      2|        score.self = 0.0
   54|      2|        start_date.self = ""
   55|      2|        end_date.self = ""
   56|      2|        members.self = 0
   57|      2|        rated.self = ""
   58|      2|
   59|      2|
   60|      2|    }
   61|       |}
   62|       |
   63|       |

/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/Model/AnimeJsonTopStruct.swift:
    1|       |
    2|       |
    3|       |
    4|       |import Foundation
    5|       |
    6|       |public struct animeTopInfoStruct: Decodable {
    7|       |    public var request_hash: String?
    8|       |    public var request_cached: Bool?
    9|       |    public var request_cache_expiry: Int?
   10|       |    public var top = [TopStruct]()
   11|       |    
   12|      2|    public init() {
   13|      2|        request_hash.self = ""
   14|      2|        request_cached.self = true
   15|      2|        request_cache_expiry.self = 0
   16|      2|    }
   17|       |        
   18|       |}
   19|       |
   20|       |
   21|       |public struct TopStruct: Decodable {
   22|       |    public var mal_id: Int?
   23|       |    public var rank: Int?
   24|       |  public var title: String?
   25|       |    public  var url: String?
   26|       |    public var image_url: String?
   27|       |    public var type: String?
   28|       |    public var episodes: Int?
   29|       |    public var start_date: String?
   30|       |    public var end_date: String?
   31|       |    public var members: Int?
   32|       |    public var score: Double?
   33|       |    
   34|      2|    public init( ){
   35|      2|
   36|      2|        mal_id.self = 0
   37|      2|        rank.self = 0
   38|      2|        title.self = ""
   39|      2|        url.self = ""
   40|      2|        image_url.self = ""
   41|      2|        type.self = ""
   42|      2|        episodes.self = 0
   43|      2|        start_date.self = ""
   44|      2|        end_date.self = ""
   45|      2|        members.self = 0
   46|      2|        score.self = 0
   47|      2|
   48|      2|    }
   49|       |}

/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/Model/ApiCallerRepo.swift:
    1|       |//
    2|       |//  ApiCallerModel.swift
    3|       |//  XouDevSpec
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/17.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public enum AnimeError: Error {
   11|       |    case noDataAvailable
   12|       |    case cannotProcessData
   13|       |    case problemWithUrl
   14|       |}
   15|       |
   16|       |public struct ApiCallerRepo {
   17|       |    let headers = [
   18|       |        "x-rapidapi-host": "jikan1.p.rapidapi.com",
   19|       |        "x-rapidapi-key": "844aa4143cmsha9162c362813b50p169716jsn9c6c8269713a"
   20|       |         ]
   21|       |    var searchText: String?
   22|       |    var genre: String?
   23|       |    
   24|      1|    public init(SearchText: String) {
   25|      1|        self.searchText = SearchText
   26|      1|        
   27|      1|    }
   28|      2|    public init(SearchText: String, GenreSelected: String) {
   29|      2|        self.searchText = SearchText
   30|      2|        self.genre = GenreSelected
   31|      2|    }
   32|       |    
   33|      3|    public init() {
   34|      3|        
   35|      3|    }
   36|       |    
   37|       |    
   38|       |    
   39|      1|    public  func getAnimeData(completetionHandler: @escaping(Result<[AnimeDetails], AnimeError>) -> Void) {
   40|      1|        
   41|      1|        guard let url = URL(string: "https://jikan1.p.rapidapi.com/search/anime?\(genre ?? "")q=\(searchText ?? "Top")") else {
   42|      0|            return
   43|      1|        }
   44|      1|    
   45|      1|        var request = URLRequest(url: url,
   46|      1|            cachePolicy: .useProtocolCachePolicy,
   47|      1|        timeoutInterval: 10.0)
   48|      1|        
   49|      1|
   50|      1|        request.httpMethod = "GET"
   51|      1|        request.allHTTPHeaderFields = headers
   52|      1|
   53|      1|        let session = URLSession.shared
   54|      1|        let dataTask = session.dataTask(with: request as URLRequest) { data, _, _ in
   55|      0|            guard let jsonData = data else {
   56|      0|                completetionHandler(.failure(.noDataAvailable))
   57|      0|                return
   58|      0|            }
   59|      0|            do {
   60|      0|                let decoder = JSONDecoder()
   61|      0|                let response = try decoder.decode(animeInfo.self, from: jsonData)
   62|      0|                let responseDetails = response.results
   63|      0|                completetionHandler(.success(responseDetails))
   64|      0|                
   65|      0|            } catch {
   66|      0|                completetionHandler(.failure(.cannotProcessData))
   67|      0|            }
   68|      0|        }
   69|      1|
   70|      1|        dataTask.resume()
   71|      1|      }
   72|       |    
   73|       |    
   74|      1|    public  func getAnimeTopData(completetionHandler: @escaping(Result<[TopStruct], AnimeError>) -> Void) {
   75|      1|        
   76|      1|        
   77|      1|            guard let url = URL(string: "https://jikan1.p.rapidapi.com/top/anime/1/upcoming") else {
   78|      0|                return
   79|      1|            }
   80|      1|        
   81|      1|            var request = URLRequest(url: url,
   82|      1|                cachePolicy: .useProtocolCachePolicy,
   83|      1|            timeoutInterval: 10.0)
   84|      1|
   85|      1|
   86|      1|        request.httpMethod = "GET"
   87|      1|        request.allHTTPHeaderFields = headers
   88|      1|
   89|      1|        let session = URLSession.shared
   90|      1|        let dataTask = session.dataTask(with: request as URLRequest) { data, _, _ in
   91|      0|            guard let jsonData = data else {
   92|      0|                completetionHandler(.failure(.noDataAvailable))
   93|      0|                return
   94|      0|            }
   95|      0|            do {
   96|      0|                let decoder = JSONDecoder()
   97|      0|                let response = try decoder.decode(animeTopInfoStruct.self, from: jsonData)
   98|      0|                let responseDetails = response.top
   99|      0|                completetionHandler(.success(responseDetails))
  100|      0|                
  101|      0|            } catch {
  102|      0|                completetionHandler(.failure(.cannotProcessData))
  103|      0|            }
  104|      0|        }
  105|      1|
  106|      1|        dataTask.resume()
  107|      1|      }
  108|      1|    public  func getMangaData(completetionHandler: @escaping(Result<[MangaDetails], AnimeError>) -> Void) {
  109|      1|        
  110|      1|        guard let url = URL(string:"https://jikan1.p.rapidapi.com/search/manga?\(genre ?? "")q=\(searchText ?? "")") else {
  111|      0|                return
  112|      1|            }
  113|      1|        
  114|      1|            var request = URLRequest(url: url,
  115|      1|                cachePolicy: .useProtocolCachePolicy,
  116|      1|            timeoutInterval: 10.0)
  117|      1|        
  118|      1|
  119|      1|        request.httpMethod = "GET"
  120|      1|        request.allHTTPHeaderFields = headers
  121|      1|
  122|      1|        let session = URLSession.shared
  123|      1|        let dataTask = session.dataTask(with: request as URLRequest) { data, _, _ in
  124|      0|            guard let jsonData = data else {
  125|      0|                completetionHandler(.failure(.noDataAvailable))
  126|      0|                return
  127|      0|            }
  128|      0|            do {
  129|      0|                let decoder = JSONDecoder()
  130|      0|                let response = try decoder.decode(mangaInfo.self, from: jsonData)
  131|      0|                let responseDetails = response.results
  132|      0|                completetionHandler(.success(responseDetails))
  133|      0|                
  134|      0|            } catch {
  135|      0|                completetionHandler(.failure(.cannotProcessData))
  136|      0|            }
  137|      0|        }
  138|      1|
  139|      1|        dataTask.resume()
  140|      1|      }
  141|       |
  142|       |}
  143|       |

/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/Model/Extensions.swift:
    1|       |//
    2|       |//  Extensions.swift
    3|       |//  XouTube
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/02/19.
    6|       |//  Copyright © 2020 Xander Schoeman. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |extension UIColor {
   12|      3|    static func rgb(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat) -> UIColor {
   13|      3|        return UIColor(red: red/255, green: green/255, blue: blue/255, alpha: 1.0)
   14|      3|    }
   15|       |}
   16|       |
   17|       |public extension UIImageView {
   18|      0|    func loadImageUsingUrlString(urlString: String) {
   19|      0|        let url = URL(string: urlString)
   20|      0|        URLSession.shared.dataTask(with: url!) { (data, response, error) in
   21|      0|            if error != nil {
   22|      0|                print(error as Any)
   23|      0|                return
   24|      0|            }
   25|      0|            DispatchQueue.main.async {
   26|      0|            self.image = UIImage(data: data!)
   27|      0|            }
   28|      0|        }.resume()
   29|      0|    }
   30|       |}
   31|       |
   32|       |
   33|       |

/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/Model/GenreModel.m:
    1|       |//
    2|       |//  GenreModel.m
    3|       |//  XouDevSpec
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/30.
    6|       |//
    7|       |
    8|       |#import "GenreModel.h"
    9|       |
   10|       |@implementation GenreModel
   11|       |
   12|       |-(instancetype)initWith:(NSString *)action :(NSString *)adventure :(NSString *)sports :(NSString *)comedy :(NSString *)martialArts :(NSString *)game :(NSString *)military :(NSString *)supernatural :(NSString *)horror :(NSString *)kids :(NSString *)sliceOfLife :(NSString *)romance :(NSString *)school :(NSString *)sciFi :(NSString *)magic :(NSString *)superPower :(NSString *)vampire :(NSString *)drama :(NSString *)fantasy :(NSString *)mystery;
   13|      0|{
   14|      0|    self = [super init];
   15|      0|    if (self) {
   16|      0|        self.action = action;
   17|      0|        self.adventure = adventure;
   18|      0|        self.sports = sports;
   19|      0|        self.comedy = comedy;
   20|      0|        self.martialArts = martialArts;
   21|      0|        self.game = game;
   22|      0|        self.military = military;
   23|      0|        self.supernatural = supernatural;
   24|      0|        self.horror = horror;
   25|      0|        self.kids = kids;
   26|      0|        self.sliceOfLife = sliceOfLife;
   27|      0|        self.romance = romance;
   28|      0|        self.school = school;
   29|      0|        self.sciFi = sciFi;
   30|      0|        self.magic = magic;
   31|      0|        self.superPower = superPower;
   32|      0|        self.vampire = vampire;
   33|      0|        self.drama = drama;
   34|      0|        self.fantasy = fantasy;
   35|      0|        self.mystery = mystery;
   36|      0|    } return self;
   37|      0|}
   38|       |-(instancetype)initWith:(NSString *)genre;
   39|      0|{
   40|      0|    self = [super init];
   41|      0|    if (self) {
   42|      0|        self.Genre = genre;
   43|      0|    } return self;
   44|      0|    
   45|      0|}
   46|       |
   47|       |@end

/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/Model/MangaSearchStruct.swift:
    1|       |//
    2|       |//  MangaSearchStruct.swift
    3|       |//  XouDevSpec
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/24.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |    public struct mangaInfo: Decodable {
   11|       |        public var request_hash: String?
   12|       |        public var request_cached: Bool?
   13|       |        public var request_cache_expiry: Int?
   14|       |        public var results = [MangaDetails]()
   15|       |        public var last_page : Int?
   16|       |
   17|      0|        public init() {
   18|      0|            request_hash.self = ""
   19|      0|            request_cached.self = true
   20|      0|            request_cache_expiry.self = 0
   21|      0|            last_page.self = 0
   22|      0|
   23|      0|        }
   24|       |
   25|       |    }
   26|       |
   27|       |    public struct MangaDetails: Decodable {
   28|       |        public var mal_id: Int?
   29|       |        public  var url: String?
   30|       |        public var image_url: String?
   31|       |        public var title: String?
   32|       |        public var publishing: Bool?
   33|       |        public var synopsis: String?
   34|       |        public var type: String?
   35|       |        public var chapters: Int?
   36|       |        public var volumes: Int?
   37|       |        public var score: Double?
   38|       |        public var start_date: String?
   39|       |        public var end_date: String?
   40|       |        public var members: Int?
   41|       |
   42|      2|        public init() {
   43|      2|
   44|      2|            mal_id.self = 0
   45|      2|            url.self = ""
   46|      2|            image_url.self = ""
   47|      2|            title.self = ""
   48|      2|            publishing.self = true
   49|      2|            synopsis.self = ""
   50|      2|            type.self = ""
   51|      2|            chapters.self = 0
   52|      2|            volumes.self = 0
   53|      2|            score.self = 0.0
   54|      2|            start_date.self = ""
   55|      2|            end_date.self = ""
   56|      2|            members.self = 0
   57|      2|        }
   58|       |    }
   59|       |
   60|       |

/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/ViewModel/AnimeFavouriteCell.swift:
    1|       |//
    2|       |//  AnimeFavouriteCell.swift
    3|       |//  XouDevSpec
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/26.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |
   11|       |public class AnimeFavouriteCell: UITableViewCell {
   12|       |
   13|       |    @IBOutlet weak var imgFaveAnime: UIImageView!
   14|       |    @IBOutlet weak var lblFaveAnime: UILabel!
   15|       |    @IBOutlet weak var imgManga: UIImageView!
   16|       |    @IBOutlet weak var lblManga: UILabel!
   17|       |    
   18|       |    public var animeViewModel: AnimeTableViewModel! {
   19|      0|         didSet {
   20|      0|             lblFaveAnime.text = animeViewModel.title
   21|      0|             if let ImageUrl = animeViewModel.image_url {
   22|      0|               imgFaveAnime.loadImageUsingUrlString(urlString: ImageUrl)
   23|      0|             }
   24|      0|         }
   25|       |     }
   26|       |     
   27|       |     public var mangaViewModel: MangaTableViewModel! {
   28|      0|          didSet {
   29|      0|              lblManga.text = mangaViewModel.title
   30|      0|              if let ImageUrl = mangaViewModel.image_url {
   31|      0|                imgManga.loadImageUsingUrlString(urlString: ImageUrl)
   32|      0|              }
   33|      0|          }
   34|       |      }
   35|       |
   36|       |}

/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/ViewModel/AnimeTableViewModel.swift:
    1|       |//
    2|       |//  AnimeTableViewModel.swift
    3|       |//  XouDevSpec
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/17.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |import Foundation
   10|       |
   11|       |
   12|       |public struct AnimeTableViewModel {
   13|       |
   14|       |    //var topAnimeObj: TopStruct?
   15|       |      public var title: String?
   16|       |      public var mal_id: Int?
   17|       |      public var rank: Int?
   18|       |      public  var url: String?
   19|       |      public var image_url: String?
   20|       |      public var type: String?
   21|       |      public var episodes: Int?
   22|       |      public var start_date: String?
   23|       |      public var end_date: String?
   24|       |      public var members: Int?
   25|       |      public var score: Double?
   26|       |      public var airing: Bool?
   27|       |      public var synopsis: String?
   28|       |      public var rated: String?
   29|      0|    public init(topAnime: TopStruct) {
   30|      0|        
   31|      0|        self.mal_id = topAnime.mal_id
   32|      0|        self.title = topAnime.title
   33|      0|        self.image_url = topAnime.image_url
   34|      0|        self.url = topAnime.url
   35|      0|        self.rank = topAnime.rank
   36|      0|        self.type = topAnime.type
   37|      0|        self.episodes = topAnime.episodes
   38|      0|        self.members = topAnime.members
   39|      0|        self.score = topAnime.score
   40|      0|        self.start_date = topAnime.start_date
   41|      0|        self.end_date = topAnime.end_date
   42|      0|        
   43|      0|        //Leaving this code commented because I have some questions:
   44|      0|        //Why does this contain no values?
   45|      0|        //self.topAnimeObj?.title = topAnime.title
   46|      0|        //self.topAnimeObj?.title = topAnime.image_url
   47|      0|        //==============================================
   48|      0|        // If i use this then it works, but then it defeats the purpose of dependency injection in the init.
   49|      0|        //self.title = topAnimeObj?.title
   50|      0|        //self.imageUrl = topAnimeObj?.title
   51|      0|    }
   52|       |    
   53|      0|    public init(SearchedAnime: AnimeDetails) {
   54|      0|        self.mal_id = SearchedAnime.mal_id
   55|      0|        self.title = SearchedAnime.title
   56|      0|        self.image_url = SearchedAnime.image_url
   57|      0|        self.url = SearchedAnime.url
   58|      0|        self.type = SearchedAnime.type
   59|      0|        self.episodes = SearchedAnime.episodes
   60|      0|        self.members = SearchedAnime.members
   61|      0|        self.score = SearchedAnime.score
   62|      0|        self.start_date = SearchedAnime.start_date
   63|      0|        self.end_date = SearchedAnime.end_date
   64|      0|        self.airing = SearchedAnime.airing
   65|      0|        self.synopsis = SearchedAnime.synopsis
   66|      0|        self.rated = SearchedAnime.rated
   67|      0|    }
   68|      0|    public init() {
   69|      0|        
   70|      0|    }
   71|       |    
   72|       |}

/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/ViewModel/AnimeVideoCell.swift:
    1|       |//
    2|       |//  VideoCell.swift
    3|       |//  XouDevSpec
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/03.
    6|       |//
    7|       |
    8|       |import UIKit
    9|       |
   10|       |public class AnimeVideoCell: UITableViewCell {
   11|       |
   12|       |    @IBOutlet weak var videoImageView: UIImageView!
   13|       |    @IBOutlet weak var videoTitleLabel: UILabel!
   14|       |
   15|       |   public var animeViewModel: AnimeTableViewModel! {
   16|      0|        didSet {
   17|      0|            videoTitleLabel.text = animeViewModel.title
   18|      0|            if let ImageUrl = animeViewModel.image_url {
   19|      0|              videoImageView.loadImageUsingUrlString(urlString: ImageUrl)
   20|      0|            }
   21|      0|        }
   22|       |    }
   23|       |    
   24|       |    public var mangaViewModel: MangaTableViewModel! {
   25|      0|         didSet {
   26|      0|             videoTitleLabel.text = mangaViewModel.title
   27|      0|             if let ImageUrl = mangaViewModel.image_url {
   28|      0|               videoImageView.loadImageUsingUrlString(urlString: ImageUrl)
   29|      0|             }
   30|      0|         }
   31|       |     }
   32|       |    
   33|      0|   public func setAnimeVidSearch(anime: AnimeDetails) {
   34|      0|        videoTitleLabel.text = anime.title
   35|      0|        if let profileImageUrl = anime.image_url {
   36|      0|            videoImageView.loadImageUsingUrlString(urlString: profileImageUrl)
   37|      0|          }
   38|      0|    }
   39|      0|    public func setAnimeVidTop(anime: TopStruct) {
   40|      0|         videoTitleLabel.text = anime.title
   41|      0|         if let profileImageUrl = anime.image_url {
   42|      0|             videoImageView.loadImageUsingUrlString(urlString: profileImageUrl)
   43|      0|           }
   44|      0|     }
   45|      0|    public func setMangaSearch(manga: MangaDetails) {
   46|      0|         videoTitleLabel.text = manga.title
   47|      0|         if let profileImageUrl = manga.image_url {
   48|      0|             videoImageView.loadImageUsingUrlString(urlString: profileImageUrl)
   49|      0|           }
   50|      0|     }
   51|       |}

/Users/xschoeman/Documents/git/Podfolder/XouDevSpec/XouDevSpec/Classes/ViewModel/MangaTableViewModel.swift:
    1|       |//
    2|       |//  MangaTableViewModel.swift
    3|       |//  XouDevSpec
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/28.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |public class MangaTableViewModel {
   11|       |    
   12|       |      public var mal_id: Int?
   13|       |      public  var url: String?
   14|       |      public var image_url: String?
   15|       |      public var title: String?
   16|       |      public var publishing: Bool?
   17|       |      public var synopsis: String?
   18|       |      public var type: String?
   19|       |      public var chapters: Int?
   20|       |      public var volumes: Int?
   21|       |      public var score: Double?
   22|       |      public var start_date: String?
   23|       |      public var end_date: String?
   24|       |      public var members: Int?
   25|       |    
   26|      0|    public init(SearchedManga: MangaDetails) {
   27|      0|        self.mal_id = SearchedManga.mal_id
   28|      0|        self.title = SearchedManga.title
   29|      0|        self.image_url = SearchedManga.image_url
   30|      0|        self.url = SearchedManga.url
   31|      0|        self.type = SearchedManga.type
   32|      0|        self.publishing = SearchedManga.publishing
   33|      0|        self.members = SearchedManga.members
   34|      0|        self.score = SearchedManga.score
   35|      0|        self.start_date = SearchedManga.start_date
   36|      0|        self.end_date = SearchedManga.end_date
   37|      0|        self.chapters = SearchedManga.chapters
   38|      0|        self.synopsis = SearchedManga.synopsis
   39|      0|        self.volumes = SearchedManga.volumes
   40|      0|    }
   41|      0|    public init() {
   42|      0|        
   43|      0|    }
   44|       |    
   45|       |}

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRAnalyticsConfiguration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import <Foundation/Foundation.h>
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRAnalyticsConfiguration.h"
   18|       |
   19|       |#pragma clang diagnostic push
   20|       |#pragma clang diagnostic ignored "-Wdeprecated-implementations"
   21|       |@implementation FIRAnalyticsConfiguration
   22|       |#pragma clang diagnostic pop
   23|       |
   24|      1|+ (FIRAnalyticsConfiguration *)sharedInstance {
   25|      1|  static FIRAnalyticsConfiguration *sharedInstance = nil;
   26|      1|  static dispatch_once_t onceToken;
   27|      1|  dispatch_once(&onceToken, ^{
   28|      1|    sharedInstance = [[FIRAnalyticsConfiguration alloc] init];
   29|      1|  });
   30|      1|  return sharedInstance;
   31|      1|}
   32|       |
   33|      0|- (void)postNotificationName:(NSString *)name value:(id)value {
   34|      0|  if (!name.length || !value) {
   35|      0|    return;
   36|      0|  }
   37|      0|  [[NSNotificationCenter defaultCenter] postNotificationName:name
   38|      0|                                                      object:self
   39|      0|                                                    userInfo:@{name : value}];
   40|      0|}
   41|       |
   42|      0|- (void)setAnalyticsCollectionEnabled:(BOOL)analyticsCollectionEnabled {
   43|      0|  [self setAnalyticsCollectionEnabled:analyticsCollectionEnabled persistSetting:YES];
   44|      0|}
   45|       |
   46|       |- (void)setAnalyticsCollectionEnabled:(BOOL)analyticsCollectionEnabled
   47|      0|                       persistSetting:(BOOL)shouldPersist {
   48|      0|  // Persist the measurementEnabledState. Use FIRAnalyticsEnabledState values instead of YES/NO.
   49|      0|  FIRAnalyticsEnabledState analyticsEnabledState =
   50|      0|      analyticsCollectionEnabled ? kFIRAnalyticsEnabledStateSetYes : kFIRAnalyticsEnabledStateSetNo;
   51|      0|  if (shouldPersist) {
   52|      0|    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
   53|      0|    [userDefaults setObject:@(analyticsEnabledState)
   54|      0|                     forKey:kFIRAPersistedConfigMeasurementEnabledStateKey];
   55|      0|    [userDefaults synchronize];
   56|      0|  }
   57|      0|
   58|      0|  [self postNotificationName:kFIRAnalyticsConfigurationSetEnabledNotification
   59|      0|                       value:@(analyticsCollectionEnabled)];
   60|      0|}
   61|       |
   62|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRApp.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include <sys/utsname.h>
   16|       |
   17|       |#if __has_include(<UIKit/UIKit.h>)
   18|       |#import <UIKit/UIKit.h>
   19|       |#endif
   20|       |
   21|       |#if __has_include(<AppKit/AppKit.h>)
   22|       |#import <AppKit/AppKit.h>
   23|       |#endif
   24|       |
   25|       |#import <FirebaseCore/FIRApp.h>
   26|       |
   27|       |#import "FirebaseCore/Sources/FIRBundleUtil.h"
   28|       |#import "FirebaseCore/Sources/FIRVersion.h"
   29|       |#import "FirebaseCore/Sources/Private/FIRAnalyticsConfiguration.h"
   30|       |#import "FirebaseCore/Sources/Private/FIRAppInternal.h"
   31|       |#import "FirebaseCore/Sources/Private/FIRComponentContainerInternal.h"
   32|       |#import "FirebaseCore/Sources/Private/FIRConfigurationInternal.h"
   33|       |#import "FirebaseCore/Sources/Private/FIRCoreDiagnosticsConnector.h"
   34|       |#import "FirebaseCore/Sources/Private/FIRLibrary.h"
   35|       |#import "FirebaseCore/Sources/Private/FIRLogger.h"
   36|       |#import "FirebaseCore/Sources/Private/FIROptionsInternal.h"
   37|       |
   38|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   39|       |
   40|       |#import <objc/runtime.h>
   41|       |
   42|       |// The kFIRService strings are only here while transitioning CoreDiagnostics from the Analytics
   43|       |// pod to a Core dependency. These symbols are not used and should be deleted after the transition.
   44|       |NSString *const kFIRServiceAdMob;
   45|       |NSString *const kFIRServiceAuth;
   46|       |NSString *const kFIRServiceAuthUI;
   47|       |NSString *const kFIRServiceCrash;
   48|       |NSString *const kFIRServiceDatabase;
   49|       |NSString *const kFIRServiceDynamicLinks;
   50|       |NSString *const kFIRServiceFirestore;
   51|       |NSString *const kFIRServiceFunctions;
   52|       |NSString *const kFIRServiceInstanceID;
   53|       |NSString *const kFIRServiceInvites;
   54|       |NSString *const kFIRServiceMessaging;
   55|       |NSString *const kFIRServiceMeasurement;
   56|       |NSString *const kFIRServicePerformance;
   57|       |NSString *const kFIRServiceRemoteConfig;
   58|       |NSString *const kFIRServiceStorage;
   59|       |NSString *const kGGLServiceAnalytics;
   60|       |NSString *const kGGLServiceSignIn;
   61|       |
   62|       |NSString *const kFIRDefaultAppName = @"__FIRAPP_DEFAULT";
   63|       |NSString *const kFIRAppReadyToConfigureSDKNotification = @"FIRAppReadyToConfigureSDKNotification";
   64|       |NSString *const kFIRAppDeleteNotification = @"FIRAppDeleteNotification";
   65|       |NSString *const kFIRAppIsDefaultAppKey = @"FIRAppIsDefaultAppKey";
   66|       |NSString *const kFIRAppNameKey = @"FIRAppNameKey";
   67|       |NSString *const kFIRGoogleAppIDKey = @"FIRGoogleAppIDKey";
   68|       |
   69|       |NSString *const kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat =
   70|       |    @"/google/firebase/global_data_collection_enabled:%@";
   71|       |NSString *const kFIRGlobalAppDataCollectionEnabledPlistKey =
   72|       |    @"FirebaseDataCollectionDefaultEnabled";
   73|       |
   74|       |NSString *const kFIRAppDiagnosticsNotification = @"FIRAppDiagnosticsNotification";
   75|       |
   76|       |NSString *const kFIRAppDiagnosticsConfigurationTypeKey = @"ConfigType";
   77|       |NSString *const kFIRAppDiagnosticsErrorKey = @"Error";
   78|       |NSString *const kFIRAppDiagnosticsFIRAppKey = @"FIRApp";
   79|       |NSString *const kFIRAppDiagnosticsSDKNameKey = @"SDKName";
   80|       |NSString *const kFIRAppDiagnosticsSDKVersionKey = @"SDKVersion";
   81|       |NSString *const kFIRAppDiagnosticsApplePlatformPrefix = @"apple-platform";
   82|       |
   83|       |// Auth internal notification notification and key.
   84|       |NSString *const FIRAuthStateDidChangeInternalNotification =
   85|       |    @"FIRAuthStateDidChangeInternalNotification";
   86|       |NSString *const FIRAuthStateDidChangeInternalNotificationAppKey =
   87|       |    @"FIRAuthStateDidChangeInternalNotificationAppKey";
   88|       |NSString *const FIRAuthStateDidChangeInternalNotificationTokenKey =
   89|       |    @"FIRAuthStateDidChangeInternalNotificationTokenKey";
   90|       |NSString *const FIRAuthStateDidChangeInternalNotificationUIDKey =
   91|       |    @"FIRAuthStateDidChangeInternalNotificationUIDKey";
   92|       |
   93|       |/**
   94|       | * The URL to download plist files.
   95|       | */
   96|       |static NSString *const kPlistURL = @"https://console.firebase.google.com/";
   97|       |
   98|       |/**
   99|       | * An array of all classes that registered as `FIRCoreConfigurable` in order to receive lifecycle
  100|       | * events from Core.
  101|       | */
  102|       |static NSMutableArray<Class<FIRLibrary>> *sRegisteredAsConfigurable;
  103|       |
  104|       |@interface FIRApp ()
  105|       |
  106|       |#ifdef DEBUG
  107|       |@property(nonatomic) BOOL alreadyOutputDataCollectionFlag;
  108|       |#endif  // DEBUG
  109|       |
  110|       |@end
  111|       |
  112|       |@implementation FIRApp
  113|       |
  114|       |// This is necessary since our custom getter prevents `_options` from being created.
  115|       |@synthesize options = _options;
  116|       |
  117|       |static NSMutableDictionary *sAllApps;
  118|       |static FIRApp *sDefaultApp;
  119|       |static NSMutableDictionary *sLibraryVersions;
  120|       |static dispatch_once_t sFirebaseUserAgentOnceToken;
  121|       |
  122|      1|+ (void)configure {
  123|      1|  FIROptions *options = [FIROptions defaultOptions];
  124|      1|  if (!options) {
  125|      0|    [NSException raise:kFirebaseCoreErrorDomain
  126|      0|                format:@"`[FIRApp configure];` (`FirebaseApp.configure()` in Swift) could not find "
  127|      0|                       @"a valid GoogleService-Info.plist in your project. Please download one "
  128|      0|                       @"from %@.",
  129|      0|                       kPlistURL];
  130|      0|  }
  131|      1|  [FIRApp configureWithOptions:options];
  132|       |#if TARGET_OS_OSX || TARGET_OS_TV
  133|       |  FIRLogNotice(kFIRLoggerCore, @"I-COR000028",
  134|       |               @"tvOS and macOS SDK support is not part of the official Firebase product. "
  135|       |               @"Instead they are community supported. Details at "
  136|       |               @"https://github.com/firebase/firebase-ios-sdk/blob/master/README.md.");
  137|       |#endif
  138|       |}
  139|       |
  140|      1|+ (void)configureWithOptions:(FIROptions *)options {
  141|      1|  if (!options) {
  142|      0|    [NSException raise:kFirebaseCoreErrorDomain
  143|      0|                format:@"Options is nil. Please pass a valid options."];
  144|      0|  }
  145|      1|  [FIRApp configureWithName:kFIRDefaultAppName options:options];
  146|      1|}
  147|       |
  148|      0|+ (NSCharacterSet *)applicationNameAllowedCharacters {
  149|      0|  static NSCharacterSet *applicationNameAllowedCharacters;
  150|      0|  static dispatch_once_t onceToken;
  151|      0|  dispatch_once(&onceToken, ^{
  152|      0|    NSMutableCharacterSet *allowedNameCharacters = [NSMutableCharacterSet alphanumericCharacterSet];
  153|      0|    [allowedNameCharacters addCharactersInString:@"-_"];
  154|      0|    applicationNameAllowedCharacters = [allowedNameCharacters copy];
  155|      0|  });
  156|      0|  return applicationNameAllowedCharacters;
  157|      0|}
  158|       |
  159|      1|+ (void)configureWithName:(NSString *)name options:(FIROptions *)options {
  160|      1|  if (!name || !options) {
  161|      0|    [NSException raise:kFirebaseCoreErrorDomain format:@"Neither name nor options can be nil."];
  162|      0|  }
  163|      1|  if (name.length == 0) {
  164|      0|    [NSException raise:kFirebaseCoreErrorDomain format:@"Name cannot be empty."];
  165|      0|  }
  166|      1|
  167|      1|  if ([name isEqualToString:kFIRDefaultAppName]) {
  168|      1|    if (sDefaultApp) {
  169|      0|      // The default app already exixts. Handle duplicate `configure` calls and return.
  170|      0|      [self appWasConfiguredTwice:sDefaultApp usingOptions:options];
  171|      0|      return;
  172|      0|    }
  173|      1|
  174|      1|    FIRLogDebug(kFIRLoggerCore, @"I-COR000001", @"Configuring the default app.");
  175|      1|  } else {
  176|      0|    // Validate the app name and ensure it hasn't been configured already.
  177|      0|    NSCharacterSet *nameCharacters = [NSCharacterSet characterSetWithCharactersInString:name];
  178|      0|
  179|      0|    if (![[self applicationNameAllowedCharacters] isSupersetOfSet:nameCharacters]) {
  180|      0|      [NSException raise:kFirebaseCoreErrorDomain
  181|      0|                  format:@"App name can only contain alphanumeric, "
  182|      0|                         @"hyphen (-), and underscore (_) characters"];
  183|      0|    }
  184|      0|
  185|      0|    @synchronized(self) {
  186|      0|      if (sAllApps && sAllApps[name]) {
  187|      0|        // The app already exists. Handle a duplicate `configure` call and return.
  188|      0|        [self appWasConfiguredTwice:sAllApps[name] usingOptions:options];
  189|      0|        return;
  190|      0|      }
  191|      0|    }
  192|      0|
  193|      0|    FIRLogDebug(kFIRLoggerCore, @"I-COR000002", @"Configuring app named %@", name);
  194|      0|  }
  195|      1|
  196|      1|  @synchronized(self) {
  197|      1|    FIRApp *app = [[FIRApp alloc] initInstanceWithName:name options:options];
  198|      1|    if (app.isDefaultApp) {
  199|      1|      sDefaultApp = app;
  200|      1|    }
  201|      1|
  202|      1|    [FIRApp addAppToAppDictionary:app];
  203|      1|
  204|      1|    // The FIRApp instance is ready to go, `sDefaultApp` is assigned, other SDKs are now ready to be
  205|      1|    // instantiated.
  206|      1|    [app.container instantiateEagerComponents];
  207|      1|    [FIRApp sendNotificationsToSDKs:app];
  208|      1|  }
  209|      1|}
  210|       |
  211|       |/// Called when `configure` has been called multiple times for the same app. This can either throw
  212|       |/// an exception (most cases) or ignore the duplicate configuration in situations where it's allowed
  213|       |/// like an extension.
  214|      0|+ (void)appWasConfiguredTwice:(FIRApp *)app usingOptions:(FIROptions *)options {
  215|      0|  // Only extensions should potentially be able to call `configure` more than once.
  216|      0|  if (![GULAppEnvironmentUtil isAppExtension]) {
  217|      0|    // Throw an exception since this is now an invalid state.
  218|      0|    if (app.isDefaultApp) {
  219|      0|      [NSException raise:kFirebaseCoreErrorDomain
  220|      0|                  format:@"Default app has already been configured."];
  221|      0|    } else {
  222|      0|      [NSException raise:kFirebaseCoreErrorDomain
  223|      0|                  format:@"App named %@ has already been configured.", app.name];
  224|      0|    }
  225|      0|  }
  226|      0|
  227|      0|  // In an extension, the entry point could be called multiple times. As long as the options are
  228|      0|  // identical we should allow multiple `configure` calls.
  229|      0|  if ([options isEqual:app.options]) {
  230|      0|    // Everything is identical but the extension's lifecycle triggered `configure` twice.
  231|      0|    // Ignore duplicate calls and return since everything should still be in a valid state.
  232|      0|    FIRLogDebug(kFIRLoggerCore, @"I-COR000035",
  233|      0|                @"Ignoring second `configure` call in an extension.");
  234|      0|    return;
  235|      0|  } else {
  236|      0|    [NSException raise:kFirebaseCoreErrorDomain
  237|      0|                format:@"App named %@ has already been configured.", app.name];
  238|      0|  }
  239|      0|}
  240|       |
  241|      2|+ (FIRApp *)defaultApp {
  242|      2|  if (sDefaultApp) {
  243|      2|    return sDefaultApp;
  244|      2|  }
  245|      0|  FIRLogError(kFIRLoggerCore, @"I-COR000003",
  246|      0|              @"The default Firebase app has not yet been "
  247|      0|              @"configured. Add `[FIRApp configure];` (`FirebaseApp.configure()` in Swift) to your "
  248|      0|              @"application initialization. Read more: https://goo.gl/ctyzm8.");
  249|      0|  return nil;
  250|      0|}
  251|       |
  252|      0|+ (FIRApp *)appNamed:(NSString *)name {
  253|      0|  @synchronized(self) {
  254|      0|    if (sAllApps) {
  255|      0|      FIRApp *app = sAllApps[name];
  256|      0|      if (app) {
  257|      0|        return app;
  258|      0|      }
  259|      0|    }
  260|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000004", @"App with name %@ does not exist.", name);
  261|      0|    return nil;
  262|      0|  }
  263|      0|}
  264|       |
  265|      2|+ (NSDictionary *)allApps {
  266|      2|  @synchronized(self) {
  267|      2|    if (!sAllApps) {
  268|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000005", @"No app has been configured yet.");
  269|      0|    }
  270|      2|    return [sAllApps copy];
  271|      2|  }
  272|      2|}
  273|       |
  274|       |// Public only for tests
  275|      0|+ (void)resetApps {
  276|      0|  @synchronized(self) {
  277|      0|    sDefaultApp = nil;
  278|      0|    [sAllApps removeAllObjects];
  279|      0|    sAllApps = nil;
  280|      0|    [sLibraryVersions removeAllObjects];
  281|      0|    sLibraryVersions = nil;
  282|      0|    sFirebaseUserAgentOnceToken = 0;
  283|      0|  }
  284|      0|}
  285|       |
  286|      0|- (void)deleteApp:(FIRAppVoidBoolCallback)completion {
  287|      0|  @synchronized([self class]) {
  288|      0|    if (sAllApps && sAllApps[self.name]) {
  289|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000006", @"Deleting app named %@", self.name);
  290|      0|
  291|      0|      // Remove all registered libraries from the container to avoid creating new instances.
  292|      0|      [self.container removeAllComponents];
  293|      0|      // Remove all cached instances from the container before deleting the app.
  294|      0|      [self.container removeAllCachedInstances];
  295|      0|
  296|      0|      [sAllApps removeObjectForKey:self.name];
  297|      0|      [self clearDataCollectionSwitchFromUserDefaults];
  298|      0|      if ([self.name isEqualToString:kFIRDefaultAppName]) {
  299|      0|        sDefaultApp = nil;
  300|      0|      }
  301|      0|      NSDictionary *appInfoDict = @{kFIRAppNameKey : self.name};
  302|      0|      [[NSNotificationCenter defaultCenter] postNotificationName:kFIRAppDeleteNotification
  303|      0|                                                          object:[self class]
  304|      0|                                                        userInfo:appInfoDict];
  305|      0|      completion(YES);
  306|      0|    } else {
  307|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000007", @"App does not exist.");
  308|      0|      completion(NO);
  309|      0|    }
  310|      0|  }
  311|      0|}
  312|       |
  313|      1|+ (void)addAppToAppDictionary:(FIRApp *)app {
  314|      1|  if (!sAllApps) {
  315|      1|    sAllApps = [NSMutableDictionary dictionary];
  316|      1|  }
  317|      1|  if ([app configureCore]) {
  318|      1|    sAllApps[app.name] = app;
  319|      1|  } else {
  320|      0|    [NSException raise:kFirebaseCoreErrorDomain
  321|      0|                format:@"Configuration fails. It may be caused by an invalid GOOGLE_APP_ID in "
  322|      0|                       @"GoogleService-Info.plist or set in the customized options."];
  323|      0|  }
  324|      1|}
  325|       |
  326|      1|- (instancetype)initInstanceWithName:(NSString *)name options:(FIROptions *)options {
  327|      1|  self = [super init];
  328|      1|  if (self) {
  329|      1|    _name = [name copy];
  330|      1|    _options = [options copy];
  331|      1|    _options.editingLocked = YES;
  332|      1|    _isDefaultApp = [name isEqualToString:kFIRDefaultAppName];
  333|      1|    _container = [[FIRComponentContainer alloc] initWithApp:self];
  334|      1|  }
  335|      1|  return self;
  336|      1|}
  337|       |
  338|      0|- (void)dealloc {
  339|      0|  [[NSNotificationCenter defaultCenter] removeObserver:self];
  340|      0|}
  341|       |
  342|      1|- (BOOL)configureCore {
  343|      1|  [self checkExpectedBundleID];
  344|      1|  if (![self isAppIDValid]) {
  345|      0|    return NO;
  346|      0|  }
  347|      1|
  348|      1|  [self logCoreTelemetryIfEnabled];
  349|      1|
  350|      1|#if TARGET_OS_IOS
  351|      1|  // Initialize the Analytics once there is a valid options under default app. Analytics should
  352|      1|  // always initialize first by itself before the other SDKs.
  353|      1|  if ([self.name isEqualToString:kFIRDefaultAppName]) {
  354|      1|    Class firAnalyticsClass = NSClassFromString(@"FIRAnalytics");
  355|      1|    if (firAnalyticsClass) {
  356|      1|#pragma clang diagnostic push
  357|      1|#pragma clang diagnostic ignored "-Wundeclared-selector"
  358|      1|      SEL startWithConfigurationSelector = @selector(startWithConfiguration:options:);
  359|      1|#pragma clang diagnostic pop
  360|      1|      if ([firAnalyticsClass respondsToSelector:startWithConfigurationSelector]) {
  361|      1|#pragma clang diagnostic push
  362|      1|#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
  363|      1|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  364|      1|        [firAnalyticsClass performSelector:startWithConfigurationSelector
  365|      1|                                withObject:[FIRConfiguration sharedInstance].analyticsConfiguration
  366|      1|                                withObject:_options];
  367|      1|#pragma clang diagnostic pop
  368|      1|      }
  369|      1|    }
  370|      1|  }
  371|      1|#endif
  372|      1|
  373|      1|  [self subscribeForAppDidBecomeActiveNotifications];
  374|      1|
  375|      1|  return YES;
  376|      1|}
  377|       |
  378|      2|- (FIROptions *)options {
  379|      2|  return [_options copy];
  380|      2|}
  381|       |
  382|      0|- (void)setDataCollectionDefaultEnabled:(BOOL)dataCollectionDefaultEnabled {
  383|      0|#ifdef DEBUG
  384|      0|  FIRLogDebug(kFIRLoggerCore, @"I-COR000034", @"Explicitly %@ data collection flag.",
  385|      0|              dataCollectionDefaultEnabled ? @"enabled" : @"disabled");
  386|      0|  self.alreadyOutputDataCollectionFlag = YES;
  387|      0|#endif  // DEBUG
  388|      0|
  389|      0|  NSString *key =
  390|      0|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, self.name];
  391|      0|  [[NSUserDefaults standardUserDefaults] setBool:dataCollectionDefaultEnabled forKey:key];
  392|      0|
  393|      0|  // Core also controls the FirebaseAnalytics flag, so check if the Analytics flags are set
  394|      0|  // within FIROptions and change the Analytics value if necessary. Analytics only works with the
  395|      0|  // default app, so return if this isn't the default app.
  396|      0|  if (!self.isDefaultApp) {
  397|      0|    return;
  398|      0|  }
  399|      0|
  400|      0|  // Check if the Analytics flag is explicitly set. If so, no further actions are necessary.
  401|      0|  if ([self.options isAnalyticsCollectionExplicitlySet]) {
  402|      0|    return;
  403|      0|  }
  404|      0|
  405|      0|  // The Analytics flag has not been explicitly set, so update with the value being set.
  406|      0|#pragma clang diagnostic push
  407|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  408|      0|  [[FIRAnalyticsConfiguration sharedInstance]
  409|      0|      setAnalyticsCollectionEnabled:dataCollectionDefaultEnabled
  410|      0|                     persistSetting:NO];
  411|      0|#pragma clang diagnostic pop
  412|      0|}
  413|       |
  414|      3|- (BOOL)isDataCollectionDefaultEnabled {
  415|      3|  // Check if it's been manually set before in code, and use that as the higher priority value.
  416|      3|  NSNumber *defaultsObject = [[self class] readDataCollectionSwitchFromUserDefaultsForApp:self];
  417|      3|  if (defaultsObject != nil) {
  418|      0|#ifdef DEBUG
  419|      0|    if (!self.alreadyOutputDataCollectionFlag) {
  420|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000031", @"Data Collection flag is %@ in user defaults.",
  421|      0|                  [defaultsObject boolValue] ? @"enabled" : @"disabled");
  422|      0|      self.alreadyOutputDataCollectionFlag = YES;
  423|      0|    }
  424|      0|#endif  // DEBUG
  425|      0|    return [defaultsObject boolValue];
  426|      0|  }
  427|      3|
  428|      3|  // Read the Info.plist to see if the flag is set. If it's not set, it should default to `YES`.
  429|      3|  // As per the implementation of `readDataCollectionSwitchFromPlist`, it's a cached value and has
  430|      3|  // no performance impact calling multiple times.
  431|      3|  NSNumber *collectionEnabledPlistValue = [[self class] readDataCollectionSwitchFromPlist];
  432|      3|  if (collectionEnabledPlistValue != nil) {
  433|      0|#ifdef DEBUG
  434|      0|    if (!self.alreadyOutputDataCollectionFlag) {
  435|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000032", @"Data Collection flag is %@ in plist.",
  436|      0|                  [collectionEnabledPlistValue boolValue] ? @"enabled" : @"disabled");
  437|      0|      self.alreadyOutputDataCollectionFlag = YES;
  438|      0|    }
  439|      0|#endif  // DEBUG
  440|      0|    return [collectionEnabledPlistValue boolValue];
  441|      0|  }
  442|      3|
  443|      3|#ifdef DEBUG
  444|      3|  if (!self.alreadyOutputDataCollectionFlag) {
  445|      1|    FIRLogDebug(kFIRLoggerCore, @"I-COR000033", @"Data Collection flag is not set.");
  446|      1|    self.alreadyOutputDataCollectionFlag = YES;
  447|      1|  }
  448|      3|#endif  // DEBUG
  449|      3|  return YES;
  450|      3|}
  451|       |
  452|       |#pragma mark - private
  453|       |
  454|      1|+ (void)sendNotificationsToSDKs:(FIRApp *)app {
  455|      1|  // TODO: Remove this notification once all SDKs are registered with `FIRCoreConfigurable`.
  456|      1|  NSNumber *isDefaultApp = [NSNumber numberWithBool:app.isDefaultApp];
  457|      1|  NSDictionary *appInfoDict = @{
  458|      1|    kFIRAppNameKey : app.name,
  459|      1|    kFIRAppIsDefaultAppKey : isDefaultApp,
  460|      1|    kFIRGoogleAppIDKey : app.options.googleAppID
  461|      1|  };
  462|      1|  [[NSNotificationCenter defaultCenter] postNotificationName:kFIRAppReadyToConfigureSDKNotification
  463|      1|                                                      object:self
  464|      1|                                                    userInfo:appInfoDict];
  465|      1|
  466|      1|  // This is the new way of sending information to SDKs.
  467|      1|  // TODO: Do we want this on a background thread, maybe?
  468|      1|  @synchronized(self) {
  469|      1|    for (Class<FIRLibrary> library in sRegisteredAsConfigurable) {
  470|      0|      [library configureWithApp:app];
  471|      0|    }
  472|      1|  }
  473|      1|}
  474|       |
  475|      0|+ (NSError *)errorForMissingOptions {
  476|      0|  NSDictionary *errorDict = @{
  477|      0|    NSLocalizedDescriptionKey :
  478|      0|        @"Unable to parse GoogleService-Info.plist in order to configure services.",
  479|      0|    NSLocalizedRecoverySuggestionErrorKey :
  480|      0|        @"Check formatting and location of GoogleService-Info.plist."
  481|      0|  };
  482|      0|  return [NSError errorWithDomain:kFirebaseCoreErrorDomain
  483|      0|                             code:FIRErrorCodeInvalidPlistFile
  484|      0|                         userInfo:errorDict];
  485|      0|}
  486|       |
  487|       |+ (NSError *)errorForSubspecConfigurationFailureWithDomain:(NSString *)domain
  488|       |                                                 errorCode:(FIRErrorCode)code
  489|       |                                                   service:(NSString *)service
  490|      0|                                                    reason:(NSString *)reason {
  491|      0|  NSString *description =
  492|      0|      [NSString stringWithFormat:@"Configuration failed for service %@.", service];
  493|      0|  NSDictionary *errorDict =
  494|      0|      @{NSLocalizedDescriptionKey : description, NSLocalizedFailureReasonErrorKey : reason};
  495|      0|  return [NSError errorWithDomain:domain code:code userInfo:errorDict];
  496|      0|}
  497|       |
  498|      0|+ (NSError *)errorForInvalidAppID {
  499|      0|  NSDictionary *errorDict = @{
  500|      0|    NSLocalizedDescriptionKey : @"Unable to validate Google App ID",
  501|      0|    NSLocalizedRecoverySuggestionErrorKey :
  502|      0|        @"Check formatting and location of GoogleService-Info.plist or GoogleAppID set in the "
  503|      0|        @"customized options."
  504|      0|  };
  505|      0|  return [NSError errorWithDomain:kFirebaseCoreErrorDomain
  506|      0|                             code:FIRErrorCodeInvalidAppID
  507|      0|                         userInfo:errorDict];
  508|      0|}
  509|       |
  510|      1|+ (BOOL)isDefaultAppConfigured {
  511|      1|  return (sDefaultApp != nil);
  512|      1|}
  513|       |
  514|      7|+ (void)registerLibrary:(nonnull NSString *)name withVersion:(nonnull NSString *)version {
  515|      7|  // Create the set of characters which aren't allowed, only if this feature is used.
  516|      7|  NSMutableCharacterSet *allowedSet = [NSMutableCharacterSet alphanumericCharacterSet];
  517|      7|  [allowedSet addCharactersInString:@"-_."];
  518|      7|  NSCharacterSet *disallowedSet = [allowedSet invertedSet];
  519|      7|  // Make sure the library name and version strings do not contain unexpected characters, and
  520|      7|  // add the name/version pair to the dictionary.
  521|      7|  if ([name rangeOfCharacterFromSet:disallowedSet].location == NSNotFound &&
  522|      7|      [version rangeOfCharacterFromSet:disallowedSet].location == NSNotFound) {
  523|      7|    @synchronized(self) {
  524|      7|      if (!sLibraryVersions) {
  525|      1|        sLibraryVersions = [[NSMutableDictionary alloc] init];
  526|      1|      }
  527|      7|      sLibraryVersions[name] = version;
  528|      7|    }
  529|      7|  } else {
  530|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000027",
  531|      0|                @"The library name (%@) or version number (%@) contain invalid characters. "
  532|      0|                @"Only alphanumeric, dash, underscore and period characters are allowed.",
  533|      0|                name, version);
  534|      0|  }
  535|      7|}
  536|       |
  537|       |+ (void)registerInternalLibrary:(nonnull Class<FIRLibrary>)library
  538|       |                       withName:(nonnull NSString *)name
  539|      2|                    withVersion:(nonnull NSString *)version {
  540|      2|  // This is called at +load time, keep the work to a minimum.
  541|      2|
  542|      2|  // Ensure the class given conforms to the proper protocol.
  543|      2|  if (![(Class)library conformsToProtocol:@protocol(FIRLibrary)] ||
  544|      2|      ![(Class)library respondsToSelector:@selector(componentsToRegister)]) {
  545|      0|    [NSException raise:NSInvalidArgumentException
  546|      0|                format:@"Class %@ attempted to register components, but it does not conform to "
  547|      0|                       @"`FIRLibrary or provide a `componentsToRegister:` method.",
  548|      0|                       library];
  549|      0|  }
  550|      2|
  551|      2|  [FIRComponentContainer registerAsComponentRegistrant:library];
  552|      2|  if ([(Class)library respondsToSelector:@selector(configureWithApp:)]) {
  553|      0|    static dispatch_once_t onceToken;
  554|      0|    dispatch_once(&onceToken, ^{
  555|      0|      sRegisteredAsConfigurable = [[NSMutableArray alloc] init];
  556|      0|    });
  557|      0|    @synchronized(self) {
  558|      0|      [sRegisteredAsConfigurable addObject:library];
  559|      0|    }
  560|      0|  }
  561|      2|  [self registerLibrary:name withVersion:version];
  562|      2|}
  563|       |
  564|      2|+ (NSString *)firebaseUserAgent {
  565|      2|  @synchronized(self) {
  566|      2|    dispatch_once(&sFirebaseUserAgentOnceToken, ^{
  567|      1|      // Report FirebaseCore version for useragent string
  568|      1|      [FIRApp registerLibrary:@"fire-ios"
  569|      1|                  withVersion:[NSString stringWithUTF8String:FIRCoreVersionString]];
  570|      1|
  571|      1|      NSDictionary<NSString *, id> *info = [[NSBundle mainBundle] infoDictionary];
  572|      1|      NSString *xcodeVersion = info[@"DTXcodeBuild"];
  573|      1|      NSString *sdkVersion = info[@"DTSDKBuild"];
  574|      1|      if (xcodeVersion) {
  575|      1|        [FIRApp registerLibrary:@"xcode" withVersion:xcodeVersion];
  576|      1|      }
  577|      1|      if (sdkVersion) {
  578|      1|        [FIRApp registerLibrary:@"apple-sdk" withVersion:sdkVersion];
  579|      1|      }
  580|      1|
  581|      1|      NSString *swiftFlagValue = [self hasSwiftRuntime] ? @"true" : @"false";
  582|      1|      [FIRApp registerLibrary:@"swift" withVersion:swiftFlagValue];
  583|      1|
  584|      1|      [FIRApp registerLibrary:kFIRAppDiagnosticsApplePlatformPrefix
  585|      1|                  withVersion:[self applePlatform]];
  586|      1|    });
  587|      2|
  588|      2|    NSMutableArray<NSString *> *libraries =
  589|      2|        [[NSMutableArray<NSString *> alloc] initWithCapacity:sLibraryVersions.count];
  590|     14|    for (NSString *libraryName in sLibraryVersions) {
  591|     14|      [libraries addObject:[NSString stringWithFormat:@"%@/%@", libraryName,
  592|     14|                                                      sLibraryVersions[libraryName]]];
  593|     14|    }
  594|      2|    [libraries sortUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
  595|      2|    return [libraries componentsJoinedByString:@" "];
  596|      2|  }
  597|      2|}
  598|       |
  599|      1|+ (BOOL)hasSwiftRuntime {
  600|      1|  // The class
  601|      1|  // [Swift._SwiftObject](https://github.com/apple/swift/blob/5eac3e2818eb340b11232aff83edfbd1c307fa03/stdlib/public/runtime/SwiftObject.h#L35)
  602|      1|  // is a part of Swift runtime, so it should be present if Swift runtime is available.
  603|      1|
  604|      1|  BOOL hasSwiftRuntime =
  605|      1|      objc_lookUpClass("Swift._SwiftObject") != nil ||
  606|      1|      // Swift object class name before
  607|      1|      // https://github.com/apple/swift/commit/9637b4a6e11ddca72f5f6dbe528efc7c92f14d01
  608|      1|      objc_getClass("_TtCs12_SwiftObject") != nil;
  609|      1|
  610|      1|  return hasSwiftRuntime;
  611|      1|}
  612|       |
  613|      1|+ (NSString *)applePlatform {
  614|      1|  NSString *applePlatform = @"unknown";
  615|      1|
  616|      1|  // When a Catalyst app is run on macOS then both `TARGET_OS_MACCATALYST` and `TARGET_OS_IOS` are
  617|      1|  // `true`, which means the condition list is order-sensitive.
  618|       |#if TARGET_OS_MACCATALYST
  619|       |  applePlatform = @"maccatalyst";
  620|       |#elif TARGET_OS_IOS
  621|       |  applePlatform = @"ios";
  622|       |#elif TARGET_OS_TV
  623|       |  applePlatform = @"tvos";
  624|       |#elif TARGET_OS_OSX
  625|       |  applePlatform = @"macos";
  626|       |#elif TARGET_OS_WATCH
  627|       |  applePlatform = @"watchos";
  628|       |#endif
  629|       |
  630|      1|  return applePlatform;
  631|      1|}
  632|       |
  633|      1|- (void)checkExpectedBundleID {
  634|      1|  NSArray *bundles = [FIRBundleUtil relevantBundles];
  635|      1|  NSString *expectedBundleID = [self expectedBundleID];
  636|      1|  // The checking is only done when the bundle ID is provided in the serviceInfo dictionary for
  637|      1|  // backward compatibility.
  638|      1|  if (expectedBundleID != nil && ![FIRBundleUtil hasBundleIdentifierPrefix:expectedBundleID
  639|      1|                                                                 inBundles:bundles]) {
  640|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000008",
  641|      0|                @"The project's Bundle ID is inconsistent with "
  642|      0|                @"either the Bundle ID in '%@.%@', or the Bundle ID in the options if you are "
  643|      0|                @"using a customized options. To ensure that everything can be configured "
  644|      0|                @"correctly, you may need to make the Bundle IDs consistent. To continue with this "
  645|      0|                @"plist file, you may change your app's bundle identifier to '%@'. Or you can "
  646|      0|                @"download a new configuration file that matches your bundle identifier from %@ "
  647|      0|                @"and replace the current one.",
  648|      0|                kServiceInfoFileName, kServiceInfoFileType, expectedBundleID, kPlistURL);
  649|      0|  }
  650|      1|}
  651|       |
  652|       |#pragma mark - private - App ID Validation
  653|       |
  654|       |/**
  655|       | * Validates the format and fingerprint of the app ID contained in GOOGLE_APP_ID in the plist file.
  656|       | * This is the main method for validating app ID.
  657|       | *
  658|       | * @return YES if the app ID fulfills the expected format and fingerprint, NO otherwise.
  659|       | */
  660|      1|- (BOOL)isAppIDValid {
  661|      1|  NSString *appID = _options.googleAppID;
  662|      1|  BOOL isValid = [FIRApp validateAppID:appID];
  663|      1|  if (!isValid) {
  664|      0|    NSString *expectedBundleID = [self expectedBundleID];
  665|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000009",
  666|      0|                @"The GOOGLE_APP_ID either in the plist file "
  667|      0|                @"'%@.%@' or the one set in the customized options is invalid. If you are using "
  668|      0|                @"the plist file, use the iOS version of bundle identifier to download the file, "
  669|      0|                @"and do not manually edit the GOOGLE_APP_ID. You may change your app's bundle "
  670|      0|                @"identifier to '%@'. Or you can download a new configuration file that matches "
  671|      0|                @"your bundle identifier from %@ and replace the current one.",
  672|      0|                kServiceInfoFileName, kServiceInfoFileType, expectedBundleID, kPlistURL);
  673|      0|  };
  674|      1|  return isValid;
  675|      1|}
  676|       |
  677|      1|+ (BOOL)validateAppID:(NSString *)appID {
  678|      1|  // Failing validation only occurs when we are sure we are looking at a V2 app ID and it does not
  679|      1|  // have a valid fingerprint, otherwise we just warn about the potential issue.
  680|      1|  if (!appID.length) {
  681|      0|    return NO;
  682|      0|  }
  683|      1|
  684|      1|  NSScanner *stringScanner = [NSScanner scannerWithString:appID];
  685|      1|  stringScanner.charactersToBeSkipped = nil;
  686|      1|
  687|      1|  NSString *appIDVersion;
  688|      1|  if (![stringScanner scanCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet]
  689|      1|                                 intoString:&appIDVersion]) {
  690|      0|    return NO;
  691|      0|  }
  692|      1|
  693|      1|  if (![stringScanner scanString:@":" intoString:NULL]) {
  694|      0|    // appIDVersion must be separated by ":"
  695|      0|    return NO;
  696|      0|  }
  697|      1|
  698|      1|  NSArray *knownVersions = @[ @"1" ];
  699|      1|  if (![knownVersions containsObject:appIDVersion]) {
  700|      0|    // Permit unknown yet properly formatted app ID versions.
  701|      0|    FIRLogInfo(kFIRLoggerCore, @"I-COR000010", @"Unknown GOOGLE_APP_ID version: %@", appIDVersion);
  702|      0|    return YES;
  703|      0|  }
  704|      1|
  705|      1|  if (![self validateAppIDFormat:appID withVersion:appIDVersion]) {
  706|      0|    return NO;
  707|      0|  }
  708|      1|
  709|      1|  if (![self validateAppIDFingerprint:appID withVersion:appIDVersion]) {
  710|      0|    return NO;
  711|      0|  }
  712|      1|
  713|      1|  return YES;
  714|      1|}
  715|       |
  716|      0|+ (NSString *)actualBundleID {
  717|      0|  return [[NSBundle mainBundle] bundleIdentifier];
  718|      0|}
  719|       |
  720|       |/**
  721|       | * Validates that the format of the app ID string is what is expected based on the supplied version.
  722|       | * The version must end in ":".
  723|       | *
  724|       | * For v1 app ids the format is expected to be
  725|       | * '<version #>:<project number>:ios:<fingerprint of bundle id>'.
  726|       | *
  727|       | * This method does not verify that the contents of the app id are correct, just that they fulfill
  728|       | * the expected format.
  729|       | *
  730|       | * @param appID Contents of GOOGLE_APP_ID from the plist file.
  731|       | * @param version Indicates what version of the app id format this string should be.
  732|       | * @return YES if provided string fufills the expected format, NO otherwise.
  733|       | */
  734|      1|+ (BOOL)validateAppIDFormat:(NSString *)appID withVersion:(NSString *)version {
  735|      1|  if (!appID.length || !version.length) {
  736|      0|    return NO;
  737|      0|  }
  738|      1|
  739|      1|  NSScanner *stringScanner = [NSScanner scannerWithString:appID];
  740|      1|  stringScanner.charactersToBeSkipped = nil;
  741|      1|
  742|      1|  // Skip version part
  743|      1|  // '*<version #>*:<project number>:ios:<fingerprint of bundle id>'
  744|      1|  if (![stringScanner scanString:version intoString:NULL]) {
  745|      0|    // The version part is missing or mismatched
  746|      0|    return NO;
  747|      0|  }
  748|      1|
  749|      1|  // Validate version part (see part between '*' symbols below)
  750|      1|  // '<version #>*:*<project number>:ios:<fingerprint of bundle id>'
  751|      1|  if (![stringScanner scanString:@":" intoString:NULL]) {
  752|      0|    // appIDVersion must be separated by ":"
  753|      0|    return NO;
  754|      0|  }
  755|      1|
  756|      1|  // Validate version part (see part between '*' symbols below)
  757|      1|  // '<version #>:*<project number>*:ios:<fingerprint of bundle id>'.
  758|      1|  NSInteger projectNumber = NSNotFound;
  759|      1|  if (![stringScanner scanInteger:&projectNumber]) {
  760|      0|    // NO project number found.
  761|      0|    return NO;
  762|      0|  }
  763|      1|
  764|      1|  // Validate version part (see part between '*' symbols below)
  765|      1|  // '<version #>:<project number>*:*ios:<fingerprint of bundle id>'.
  766|      1|  if (![stringScanner scanString:@":" intoString:NULL]) {
  767|      0|    // The project number must be separated by ":"
  768|      0|    return NO;
  769|      0|  }
  770|      1|
  771|      1|  // Validate version part (see part between '*' symbols below)
  772|      1|  // '<version #>:<project number>:*ios*:<fingerprint of bundle id>'.
  773|      1|  NSString *platform;
  774|      1|  if (![stringScanner scanUpToString:@":" intoString:&platform]) {
  775|      0|    return NO;
  776|      0|  }
  777|      1|
  778|      1|  if (![platform isEqualToString:@"ios"]) {
  779|      0|    // The platform must be @"ios"
  780|      0|    return NO;
  781|      0|  }
  782|      1|
  783|      1|  // Validate version part (see part between '*' symbols below)
  784|      1|  // '<version #>:<project number>:ios*:*<fingerprint of bundle id>'.
  785|      1|  if (![stringScanner scanString:@":" intoString:NULL]) {
  786|      0|    // The platform must be separated by ":"
  787|      0|    return NO;
  788|      0|  }
  789|      1|
  790|      1|  // Validate version part (see part between '*' symbols below)
  791|      1|  // '<version #>:<project number>:ios:*<fingerprint of bundle id>*'.
  792|      1|  unsigned long long fingerprint = NSNotFound;
  793|      1|  if (![stringScanner scanHexLongLong:&fingerprint]) {
  794|      0|    // Fingerprint part is missing
  795|      0|    return NO;
  796|      0|  }
  797|      1|
  798|      1|  if (!stringScanner.isAtEnd) {
  799|      0|    // There are not allowed characters in the fingerprint part
  800|      0|    return NO;
  801|      0|  }
  802|      1|
  803|      1|  return YES;
  804|      1|}
  805|       |
  806|       |/**
  807|       | * Validates that the fingerprint of the app ID string is what is expected based on the supplied
  808|       | * version.
  809|       | *
  810|       | * Note that the v1 hash algorithm is not permitted on the client and cannot be fully validated.
  811|       | *
  812|       | * @param appID Contents of GOOGLE_APP_ID from the plist file.
  813|       | * @param version Indicates what version of the app id format this string should be.
  814|       | * @return YES if provided string fufills the expected fingerprint and the version is known, NO
  815|       | *         otherwise.
  816|       | */
  817|      1|+ (BOOL)validateAppIDFingerprint:(NSString *)appID withVersion:(NSString *)version {
  818|      1|  // Extract the supplied fingerprint from the supplied app ID.
  819|      1|  // This assumes the app ID format is the same for all known versions below. If the app ID format
  820|      1|  // changes in future versions, the tokenizing of the app ID format will need to take into account
  821|      1|  // the version of the app ID.
  822|      1|  NSArray *components = [appID componentsSeparatedByString:@":"];
  823|      1|  if (components.count != 4) {
  824|      0|    return NO;
  825|      0|  }
  826|      1|
  827|      1|  NSString *suppliedFingerprintString = components[3];
  828|      1|  if (!suppliedFingerprintString.length) {
  829|      0|    return NO;
  830|      0|  }
  831|      1|
  832|      1|  uint64_t suppliedFingerprint;
  833|      1|  NSScanner *scanner = [NSScanner scannerWithString:suppliedFingerprintString];
  834|      1|  if (![scanner scanHexLongLong:&suppliedFingerprint]) {
  835|      0|    return NO;
  836|      0|  }
  837|      1|
  838|      1|  if ([version isEqual:@"1"]) {
  839|      1|    // The v1 hash algorithm is not permitted on the client so the actual hash cannot be validated.
  840|      1|    return YES;
  841|      1|  }
  842|      0|
  843|      0|  // Unknown version.
  844|      0|  return NO;
  845|      0|}
  846|       |
  847|      1|- (NSString *)expectedBundleID {
  848|      1|  return _options.bundleID;
  849|      1|}
  850|       |
  851|       |// end App ID validation
  852|       |
  853|       |#pragma mark - Reading From Plist & User Defaults
  854|       |
  855|       |/**
  856|       | * Clears the data collection switch from the standard NSUserDefaults for easier testing and
  857|       | * readability.
  858|       | */
  859|      0|- (void)clearDataCollectionSwitchFromUserDefaults {
  860|      0|  NSString *key =
  861|      0|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, self.name];
  862|      0|  [[NSUserDefaults standardUserDefaults] removeObjectForKey:key];
  863|      0|}
  864|       |
  865|       |/**
  866|       | * Reads the data collection switch from the standard NSUserDefaults for easier testing and
  867|       | * readability.
  868|       | */
  869|      3|+ (nullable NSNumber *)readDataCollectionSwitchFromUserDefaultsForApp:(FIRApp *)app {
  870|      3|  // Read the object in user defaults, and only return if it's an NSNumber.
  871|      3|  NSString *key =
  872|      3|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, app.name];
  873|      3|  id collectionEnabledDefaultsObject = [[NSUserDefaults standardUserDefaults] objectForKey:key];
  874|      3|  if ([collectionEnabledDefaultsObject isKindOfClass:[NSNumber class]]) {
  875|      0|    return collectionEnabledDefaultsObject;
  876|      0|  }
  877|      3|
  878|      3|  return nil;
  879|      3|}
  880|       |
  881|       |/**
  882|       | * Reads the data collection switch from the Info.plist for easier testing and readability. Will
  883|       | * only read once from the plist and return the cached value.
  884|       | */
  885|      3|+ (nullable NSNumber *)readDataCollectionSwitchFromPlist {
  886|      3|  static NSNumber *collectionEnabledPlistObject;
  887|      3|  static dispatch_once_t onceToken;
  888|      3|  dispatch_once(&onceToken, ^{
  889|      1|    // Read the data from the `Info.plist`, only assign it if it's there and an NSNumber.
  890|      1|    id plistValue = [[NSBundle mainBundle]
  891|      1|        objectForInfoDictionaryKey:kFIRGlobalAppDataCollectionEnabledPlistKey];
  892|      1|    if (plistValue && [plistValue isKindOfClass:[NSNumber class]]) {
  893|      0|      collectionEnabledPlistObject = (NSNumber *)plistValue;
  894|      0|    }
  895|      1|  });
  896|      3|
  897|      3|  return collectionEnabledPlistObject;
  898|      3|}
  899|       |
  900|       |#pragma mark - Sending Logs
  901|       |
  902|       |#pragma clang diagnostic push
  903|       |#pragma clang diagnostic ignored "-Wunused-parameter"
  904|       |- (void)sendLogsWithServiceName:(NSString *)serviceName
  905|       |                        version:(NSString *)version
  906|      0|                          error:(NSError *)error {
  907|      0|  // Do nothing. Please remove calls to this method.
  908|      0|}
  909|       |#pragma clang diagnostic pop
  910|       |
  911|       |#pragma mark - App Life Cycle
  912|       |
  913|      1|- (void)subscribeForAppDidBecomeActiveNotifications {
  914|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  915|      1|  NSNotificationName notificationName = UIApplicationDidBecomeActiveNotification;
  916|       |#elif TARGET_OS_OSX
  917|       |  NSNotificationName notificationName = NSApplicationDidBecomeActiveNotification;
  918|       |#endif
  919|       |
  920|      1|#if !TARGET_OS_WATCH
  921|      1|  [[NSNotificationCenter defaultCenter] addObserver:self
  922|      1|                                           selector:@selector(appDidBecomeActive:)
  923|      1|                                               name:notificationName
  924|      1|                                             object:nil];
  925|      1|#endif
  926|      1|}
  927|       |
  928|      1|- (void)appDidBecomeActive:(NSNotification *)notification {
  929|      1|  [self logCoreTelemetryIfEnabled];
  930|      1|}
  931|       |
  932|      2|- (void)logCoreTelemetryIfEnabled {
  933|      2|  if ([self isDataCollectionDefaultEnabled]) {
  934|      2|    [FIRCoreDiagnosticsConnector logCoreTelemetryWithOptions:_options];
  935|      2|  }
  936|      2|}
  937|       |
  938|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRAppAssociationRegistration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/Private/FIRAppAssociationRegistration.h"
   16|       |
   17|       |#import <objc/runtime.h>
   18|       |
   19|       |@implementation FIRAppAssociationRegistration
   20|       |
   21|       |+ (nullable id)registeredObjectWithHost:(id)host
   22|       |                                    key:(NSString *)key
   23|      0|                          creationBlock:(id _Nullable (^)(void))creationBlock {
   24|      0|  @synchronized(self) {
   25|      0|    SEL dictKey = @selector(registeredObjectWithHost:key:creationBlock:);
   26|      0|    NSMutableDictionary<NSString *, id> *objectsByKey = objc_getAssociatedObject(host, dictKey);
   27|      0|    if (!objectsByKey) {
   28|      0|      objectsByKey = [[NSMutableDictionary alloc] init];
   29|      0|      objc_setAssociatedObject(host, dictKey, objectsByKey, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
   30|      0|    }
   31|      0|    id obj = objectsByKey[key];
   32|      0|    NSValue *creationBlockBeingCalled = [NSValue valueWithPointer:dictKey];
   33|      0|    if (obj) {
   34|      0|      if ([creationBlockBeingCalled isEqual:obj]) {
   35|      0|        [NSException raise:@"Reentering registeredObjectWithHost:key:creationBlock: not allowed"
   36|      0|                    format:@"host: %@ key: %@", host, key];
   37|      0|      }
   38|      0|      return obj;
   39|      0|    }
   40|      0|    objectsByKey[key] = creationBlockBeingCalled;
   41|      0|    obj = creationBlock();
   42|      0|    objectsByKey[key] = obj;
   43|      0|    return obj;
   44|      0|  }
   45|      0|}
   46|       |
   47|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRBundleUtil.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/FIRBundleUtil.h"
   16|       |
   17|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   18|       |
   19|       |@implementation FIRBundleUtil
   20|       |
   21|      2|+ (NSArray *)relevantBundles {
   22|      2|  return @[ [NSBundle mainBundle], [NSBundle bundleForClass:[self class]] ];
   23|      2|}
   24|       |
   25|       |+ (NSString *)optionsDictionaryPathWithResourceName:(NSString *)resourceName
   26|       |                                        andFileType:(NSString *)fileType
   27|      1|                                          inBundles:(NSArray *)bundles {
   28|      1|  // Loop through all bundles to find the config dict.
   29|      1|  for (NSBundle *bundle in bundles) {
   30|      1|    NSString *path = [bundle pathForResource:resourceName ofType:fileType];
   31|      1|    // Use the first one we find.
   32|      1|    if (path) {
   33|      1|      return path;
   34|      1|    }
   35|      1|  }
   36|      1|  return nil;
   37|      1|}
   38|       |
   39|      0|+ (NSArray *)relevantURLSchemes {
   40|      0|  NSMutableArray *result = [[NSMutableArray alloc] init];
   41|      0|  for (NSBundle *bundle in [[self class] relevantBundles]) {
   42|      0|    NSArray *urlTypes = [bundle objectForInfoDictionaryKey:@"CFBundleURLTypes"];
   43|      0|    for (NSDictionary *urlType in urlTypes) {
   44|      0|      [result addObjectsFromArray:urlType[@"CFBundleURLSchemes"]];
   45|      0|    }
   46|      0|  }
   47|      0|  return result;
   48|      0|}
   49|       |
   50|      1|+ (BOOL)hasBundleIdentifierPrefix:(NSString *)bundleIdentifier inBundles:(NSArray *)bundles {
   51|      1|  for (NSBundle *bundle in bundles) {
   52|      1|    // This allows app extensions that have the app's bundle as their prefix to pass this test.
   53|      1|    NSString *applicationBundleIdentifier =
   54|      1|        [GULAppEnvironmentUtil isAppExtension]
   55|      1|            ? [self bundleIdentifierByRemovingLastPartFrom:bundle.bundleIdentifier]
   56|      1|            : bundle.bundleIdentifier;
   57|      1|
   58|      1|    if ([applicationBundleIdentifier isEqualToString:bundleIdentifier]) {
   59|      1|      return YES;
   60|      1|    }
   61|      1|  }
   62|      1|  return NO;
   63|      1|}
   64|       |
   65|      0|+ (NSString *)bundleIdentifierByRemovingLastPartFrom:(NSString *)bundleIdentifier {
   66|      0|  NSString *bundleIDComponentsSeparator = @".";
   67|      0|
   68|      0|  NSMutableArray<NSString *> *bundleIDComponents =
   69|      0|      [[bundleIdentifier componentsSeparatedByString:bundleIDComponentsSeparator] mutableCopy];
   70|      0|  [bundleIDComponents removeLastObject];
   71|      0|
   72|      0|  return [bundleIDComponents componentsJoinedByString:bundleIDComponentsSeparator];
   73|      0|}
   74|       |
   75|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRComponent.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRComponent.h"
   18|       |
   19|       |#import "FirebaseCore/Sources/Private/FIRComponentContainer.h"
   20|       |#import "FirebaseCore/Sources/Private/FIRDependency.h"
   21|       |
   22|       |@interface FIRComponent ()
   23|       |
   24|       |- (instancetype)initWithProtocol:(Protocol *)protocol
   25|       |             instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   26|       |                    dependencies:(NSArray<FIRDependency *> *)dependencies
   27|       |                   creationBlock:(FIRComponentCreationBlock)creationBlock;
   28|       |
   29|       |@end
   30|       |
   31|       |@implementation FIRComponent
   32|       |
   33|       |+ (instancetype)componentWithProtocol:(Protocol *)protocol
   34|      0|                        creationBlock:(FIRComponentCreationBlock)creationBlock {
   35|      0|  return [[FIRComponent alloc] initWithProtocol:protocol
   36|      0|                            instantiationTiming:FIRInstantiationTimingLazy
   37|      0|                                   dependencies:@[]
   38|      0|                                  creationBlock:creationBlock];
   39|      0|}
   40|       |
   41|       |+ (instancetype)componentWithProtocol:(Protocol *)protocol
   42|       |                  instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   43|       |                         dependencies:(NSArray<FIRDependency *> *)dependencies
   44|      2|                        creationBlock:(FIRComponentCreationBlock)creationBlock {
   45|      2|  return [[FIRComponent alloc] initWithProtocol:protocol
   46|      2|                            instantiationTiming:instantiationTiming
   47|      2|                                   dependencies:dependencies
   48|      2|                                  creationBlock:creationBlock];
   49|      2|}
   50|       |
   51|       |- (instancetype)initWithProtocol:(Protocol *)protocol
   52|       |             instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   53|       |                    dependencies:(NSArray<FIRDependency *> *)dependencies
   54|      2|                   creationBlock:(FIRComponentCreationBlock)creationBlock {
   55|      2|  self = [super init];
   56|      2|  if (self) {
   57|      2|    _protocol = protocol;
   58|      2|    _instantiationTiming = instantiationTiming;
   59|      2|    _dependencies = [dependencies copy];
   60|      2|    _creationBlock = creationBlock;
   61|      2|  }
   62|      2|  return self;
   63|      2|}
   64|       |
   65|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRComponentContainer.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRComponentContainer.h"
   18|       |
   19|       |#import "FirebaseCore/Sources/Private/FIRAppInternal.h"
   20|       |#import "FirebaseCore/Sources/Private/FIRComponent.h"
   21|       |#import "FirebaseCore/Sources/Private/FIRLibrary.h"
   22|       |#import "FirebaseCore/Sources/Private/FIRLogger.h"
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@interface FIRComponentContainer ()
   27|       |
   28|       |/// The dictionary of components that are registered for a particular app. The key is an `NSString`
   29|       |/// of the protocol.
   30|       |@property(nonatomic, strong) NSMutableDictionary<NSString *, FIRComponentCreationBlock> *components;
   31|       |
   32|       |/// Cached instances of components that requested to be cached.
   33|       |@property(nonatomic, strong) NSMutableDictionary<NSString *, id> *cachedInstances;
   34|       |
   35|       |/// Protocols of components that have requested to be eagerly instantiated.
   36|       |@property(nonatomic, strong, nullable) NSMutableArray<Protocol *> *eagerProtocolsToInstantiate;
   37|       |
   38|       |@end
   39|       |
   40|       |@implementation FIRComponentContainer
   41|       |
   42|       |// Collection of all classes that register to provide components.
   43|       |static NSMutableSet<Class> *sFIRComponentRegistrants;
   44|       |
   45|       |#pragma mark - Public Registration
   46|       |
   47|      2|+ (void)registerAsComponentRegistrant:(Class<FIRLibrary>)klass {
   48|      2|  static dispatch_once_t onceToken;
   49|      2|  dispatch_once(&onceToken, ^{
   50|      1|    sFIRComponentRegistrants = [[NSMutableSet<Class> alloc] init];
   51|      1|  });
   52|      2|
   53|      2|  [self registerAsComponentRegistrant:klass inSet:sFIRComponentRegistrants];
   54|      2|}
   55|       |
   56|       |+ (void)registerAsComponentRegistrant:(Class<FIRLibrary>)klass
   57|      2|                                inSet:(NSMutableSet<Class> *)allRegistrants {
   58|      2|  [allRegistrants addObject:klass];
   59|      2|}
   60|       |
   61|       |#pragma mark - Internal Initialization
   62|       |
   63|      1|- (instancetype)initWithApp:(FIRApp *)app {
   64|      1|  return [self initWithApp:app registrants:sFIRComponentRegistrants];
   65|      1|}
   66|       |
   67|      1|- (instancetype)initWithApp:(FIRApp *)app registrants:(NSMutableSet<Class> *)allRegistrants {
   68|      1|  self = [super init];
   69|      1|  if (self) {
   70|      1|    _app = app;
   71|      1|    _cachedInstances = [NSMutableDictionary<NSString *, id> dictionary];
   72|      1|    _components = [NSMutableDictionary<NSString *, FIRComponentCreationBlock> dictionary];
   73|      1|
   74|      1|    [self populateComponentsFromRegisteredClasses:allRegistrants forApp:app];
   75|      1|  }
   76|      1|  return self;
   77|      1|}
   78|       |
   79|      1|- (void)populateComponentsFromRegisteredClasses:(NSSet<Class> *)classes forApp:(FIRApp *)app {
   80|      1|  // Keep track of any components that need to eagerly instantiate after all components are added.
   81|      1|  self.eagerProtocolsToInstantiate = [[NSMutableArray alloc] init];
   82|      1|
   83|      1|  // Loop through the verified component registrants and populate the components array.
   84|      2|  for (Class<FIRLibrary> klass in classes) {
   85|      2|    // Loop through all the components being registered and store them as appropriate.
   86|      2|    // Classes which do not provide functionality should use a dummy FIRComponentRegistrant
   87|      2|    // protocol.
   88|      2|    for (FIRComponent *component in [klass componentsToRegister]) {
   89|      2|      // Check if the component has been registered before, and error out if so.
   90|      2|      NSString *protocolName = NSStringFromProtocol(component.protocol);
   91|      2|      if (self.components[protocolName]) {
   92|      0|        FIRLogError(kFIRLoggerCore, @"I-COR000029",
   93|      0|                    @"Attempted to register protocol %@, but it already has an implementation.",
   94|      0|                    protocolName);
   95|      0|        continue;
   96|      0|      }
   97|      2|
   98|      2|      // Store the creation block for later usage.
   99|      2|      self.components[protocolName] = component.creationBlock;
  100|      2|
  101|      2|      // Queue any protocols that should be eagerly instantiated. Don't instantiate them yet
  102|      2|      // because they could depend on other components that haven't been added to the components
  103|      2|      // array yet.
  104|      2|      BOOL shouldInstantiateEager =
  105|      2|          (component.instantiationTiming == FIRInstantiationTimingAlwaysEager);
  106|      2|      BOOL shouldInstantiateDefaultEager =
  107|      2|          (component.instantiationTiming == FIRInstantiationTimingEagerInDefaultApp &&
  108|      2|           [app isDefaultApp]);
  109|      2|      if (shouldInstantiateEager || shouldInstantiateDefaultEager) {
  110|      1|        [self.eagerProtocolsToInstantiate addObject:component.protocol];
  111|      1|      }
  112|      2|    }
  113|      2|  }
  114|      1|}
  115|       |
  116|       |#pragma mark - Instance Creation
  117|       |
  118|      1|- (void)instantiateEagerComponents {
  119|      1|  // After all components are registered, instantiate the ones that are requesting eager
  120|      1|  // instantiation.
  121|      1|  @synchronized(self) {
  122|      1|    for (Protocol *protocol in self.eagerProtocolsToInstantiate) {
  123|      1|      // Get an instance for the protocol, which will instantiate it since it couldn't have been
  124|      1|      // cached yet. Ignore the instance coming back since we don't need it.
  125|      1|      __unused id unusedInstance = [self instanceForProtocol:protocol];
  126|      1|    }
  127|      1|
  128|      1|    // All eager instantiation is complete, clear the stored property now.
  129|      1|    self.eagerProtocolsToInstantiate = nil;
  130|      1|  }
  131|      1|}
  132|       |
  133|       |/// Instantiate an instance of a class that conforms to the specified protocol.
  134|       |/// This will:
  135|       |///   - Call the block to create an instance if possible,
  136|       |///   - Validate that the instance returned conforms to the protocol it claims to,
  137|       |///   - Cache the instance if the block requests it
  138|       |///
  139|       |/// Note that this method assumes the caller already has @sychronized on self.
  140|       |- (nullable id)instantiateInstanceForProtocol:(Protocol *)protocol
  141|      1|                                    withBlock:(FIRComponentCreationBlock)creationBlock {
  142|      1|  if (!creationBlock) {
  143|      0|    return nil;
  144|      0|  }
  145|      1|
  146|      1|  // Create an instance using the creation block.
  147|      1|  BOOL shouldCache = NO;
  148|      1|  id instance = creationBlock(self, &shouldCache);
  149|      1|  if (!instance) {
  150|      0|    return nil;
  151|      0|  }
  152|      1|
  153|      1|  // An instance was created, validate that it conforms to the protocol it claims to.
  154|      1|  NSString *protocolName = NSStringFromProtocol(protocol);
  155|      1|  if (![instance conformsToProtocol:protocol]) {
  156|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000030",
  157|      0|                @"An instance conforming to %@ was requested, but the instance provided does not "
  158|      0|                @"conform to the protocol",
  159|      0|                protocolName);
  160|      0|  }
  161|      1|
  162|      1|  // The instance is ready to be returned, but check if it should be cached first before returning.
  163|      1|  if (shouldCache) {
  164|      1|    self.cachedInstances[protocolName] = instance;
  165|      1|  }
  166|      1|
  167|      1|  return instance;
  168|      1|}
  169|       |
  170|       |#pragma mark - Internal Retrieval
  171|       |
  172|      2|- (nullable id)instanceForProtocol:(Protocol *)protocol {
  173|      2|  // Check if there is a cached instance, and return it if so.
  174|      2|  NSString *protocolName = NSStringFromProtocol(protocol);
  175|      2|
  176|      2|  id cachedInstance;
  177|      2|  @synchronized(self) {
  178|      2|    cachedInstance = self.cachedInstances[protocolName];
  179|      2|    if (!cachedInstance) {
  180|      1|      // Use the creation block to instantiate an instance and return it.
  181|      1|      FIRComponentCreationBlock creationBlock = self.components[protocolName];
  182|      1|      cachedInstance = [self instantiateInstanceForProtocol:protocol withBlock:creationBlock];
  183|      1|    }
  184|      2|  }
  185|      2|  return cachedInstance;
  186|      2|}
  187|       |
  188|       |#pragma mark - Lifecycle
  189|       |
  190|      0|- (void)removeAllCachedInstances {
  191|      0|  @synchronized(self) {
  192|      0|    // Loop through the cache and notify each instance that is a maintainer to clean up after
  193|      0|    // itself.
  194|      0|    for (id instance in self.cachedInstances.allValues) {
  195|      0|      if ([instance conformsToProtocol:@protocol(FIRComponentLifecycleMaintainer)] &&
  196|      0|          [instance respondsToSelector:@selector(appWillBeDeleted:)]) {
  197|      0|        [instance appWillBeDeleted:self.app];
  198|      0|      }
  199|      0|    }
  200|      0|
  201|      0|    // Empty the cache.
  202|      0|    [self.cachedInstances removeAllObjects];
  203|      0|  }
  204|      0|}
  205|       |
  206|      0|- (void)removeAllComponents {
  207|      0|  @synchronized(self) {
  208|      0|    [self.components removeAllObjects];
  209|      0|  }
  210|      0|}
  211|       |
  212|       |@end
  213|       |
  214|       |NS_ASSUME_NONNULL_END

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRComponentType.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRComponentType.h"
   18|       |
   19|       |#import "FirebaseCore/Sources/Private/FIRComponentContainerInternal.h"
   20|       |
   21|       |@implementation FIRComponentType
   22|       |
   23|      1|+ (id)instanceForProtocol:(Protocol *)protocol inContainer:(FIRComponentContainer *)container {
   24|      1|  // Forward the call to the container.
   25|      1|  return [container instanceForProtocol:protocol];
   26|      1|}
   27|       |
   28|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRConfiguration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/Private/FIRConfigurationInternal.h"
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRAnalyticsConfiguration.h"
   18|       |
   19|       |extern void FIRSetLoggerLevel(FIRLoggerLevel loggerLevel);
   20|       |
   21|       |@implementation FIRConfiguration
   22|       |
   23|      1|+ (instancetype)sharedInstance {
   24|      1|  static FIRConfiguration *sharedInstance = nil;
   25|      1|  static dispatch_once_t onceToken;
   26|      1|  dispatch_once(&onceToken, ^{
   27|      1|    sharedInstance = [[FIRConfiguration alloc] init];
   28|      1|  });
   29|      1|  return sharedInstance;
   30|      1|}
   31|       |
   32|      1|- (instancetype)init {
   33|      1|  self = [super init];
   34|      1|  if (self) {
   35|      1|    _analyticsConfiguration = [FIRAnalyticsConfiguration sharedInstance];
   36|      1|  }
   37|      1|  return self;
   38|      1|}
   39|       |
   40|      0|- (void)setLoggerLevel:(FIRLoggerLevel)loggerLevel {
   41|      0|  NSAssert(loggerLevel <= FIRLoggerLevelMax && loggerLevel >= FIRLoggerLevelMin,
   42|      0|           @"Invalid logger level, %ld", (long)loggerLevel);
   43|      0|  FIRSetLoggerLevel(loggerLevel);
   44|      0|}
   45|       |
   46|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRCoreDiagnosticsConnector.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRCoreDiagnosticsConnector.h"
   18|       |
   19|       |#import <FirebaseCoreDiagnosticsInterop/FIRCoreDiagnosticsInterop.h>
   20|       |
   21|       |#import <FirebaseCore/FIROptions.h>
   22|       |
   23|       |#import "FirebaseCore/Sources/Private/FIRAppInternal.h"
   24|       |#import "FirebaseCore/Sources/Private/FIRDiagnosticsData.h"
   25|       |#import "FirebaseCore/Sources/Private/FIROptionsInternal.h"
   26|       |
   27|       |// Define the interop class symbol declared as an extern in FIRCoreDiagnosticsInterop.
   28|       |Class<FIRCoreDiagnosticsInterop> FIRCoreDiagnosticsImplementation;
   29|       |
   30|       |@implementation FIRCoreDiagnosticsConnector
   31|       |
   32|      1|+ (void)initialize {
   33|      1|  if (!FIRCoreDiagnosticsImplementation) {
   34|      1|    FIRCoreDiagnosticsImplementation = NSClassFromString(@"FIRCoreDiagnostics");
   35|      1|    if (FIRCoreDiagnosticsImplementation) {
   36|      1|      NSAssert([FIRCoreDiagnosticsImplementation
   37|      1|                   conformsToProtocol:@protocol(FIRCoreDiagnosticsInterop)],
   38|      1|               @"If FIRCoreDiagnostics is implemented, it must conform to the interop protocol.");
   39|      1|      NSAssert(
   40|      1|          [FIRCoreDiagnosticsImplementation respondsToSelector:@selector(sendDiagnosticsData:)],
   41|      1|          @"If FIRCoreDiagnostics is implemented, it must implement +sendDiagnosticsData.");
   42|      1|    }
   43|      1|  }
   44|      1|}
   45|       |
   46|      2|+ (void)logCoreTelemetryWithOptions:(FIROptions *)options {
   47|      2|  if (FIRCoreDiagnosticsImplementation) {
   48|      2|    FIRDiagnosticsData *diagnosticsData = [[FIRDiagnosticsData alloc] init];
   49|      2|    [diagnosticsData insertValue:@(YES) forKey:kFIRCDIsDataCollectionDefaultEnabledKey];
   50|      2|    [diagnosticsData insertValue:[FIRApp firebaseUserAgent] forKey:kFIRCDFirebaseUserAgentKey];
   51|      2|    [diagnosticsData insertValue:@(FIRConfigTypeCore) forKey:kFIRCDConfigurationTypeKey];
   52|      2|    [diagnosticsData insertValue:options.googleAppID forKey:kFIRCDGoogleAppIDKey];
   53|      2|    [diagnosticsData insertValue:options.bundleID forKey:kFIRCDBundleIDKey];
   54|      2|    [diagnosticsData insertValue:@(options.usingOptionsFromDefaultPlist)
   55|      2|                          forKey:kFIRCDUsingOptionsFromDefaultPlistKey];
   56|      2|    [diagnosticsData insertValue:options.libraryVersionID forKey:kFIRCDLibraryVersionIDKey];
   57|      2|    [FIRCoreDiagnosticsImplementation sendDiagnosticsData:diagnosticsData];
   58|      2|  }
   59|      2|}
   60|       |
   61|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRDependency.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRDependency.h"
   18|       |
   19|       |@interface FIRDependency ()
   20|       |
   21|       |- (instancetype)initWithProtocol:(Protocol *)protocol isRequired:(BOOL)required;
   22|       |
   23|       |@end
   24|       |
   25|       |@implementation FIRDependency
   26|       |
   27|      0|+ (instancetype)dependencyWithProtocol:(Protocol *)protocol {
   28|      0|  return [[self alloc] initWithProtocol:protocol isRequired:YES];
   29|      0|}
   30|       |
   31|      0|+ (instancetype)dependencyWithProtocol:(Protocol *)protocol isRequired:(BOOL)required {
   32|      0|  return [[self alloc] initWithProtocol:protocol isRequired:required];
   33|      0|}
   34|       |
   35|      0|- (instancetype)initWithProtocol:(Protocol *)protocol isRequired:(BOOL)required {
   36|      0|  self = [super init];
   37|      0|  if (self) {
   38|      0|    _protocol = protocol;
   39|      0|    _isRequired = required;
   40|      0|  }
   41|      0|  return self;
   42|      0|}
   43|       |
   44|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRDiagnosticsData.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FirebaseCore/Sources/Private/FIRDiagnosticsData.h"
   18|       |
   19|       |#import <FirebaseCore/FIRApp.h>
   20|       |
   21|       |#import "FirebaseCore/Sources/Private/FIRAppInternal.h"
   22|       |#import "FirebaseCore/Sources/Private/FIROptionsInternal.h"
   23|       |
   24|       |@implementation FIRDiagnosticsData {
   25|       |  /** Backing ivar for the diagnosticObjects property. */
   26|       |  NSMutableDictionary<NSString *, id> *_diagnosticObjects;
   27|       |}
   28|       |
   29|      2|- (instancetype)init {
   30|      2|  self = [super init];
   31|      2|  if (self) {
   32|      2|    _diagnosticObjects = [[NSMutableDictionary alloc] init];
   33|      2|  }
   34|      2|  return self;
   35|      2|}
   36|       |
   37|     14|- (void)insertValue:(nullable id)value forKey:(NSString *)key {
   38|     14|  if (key) {
   39|     14|    _diagnosticObjects[key] = value;
   40|     14|  }
   41|     14|}
   42|       |
   43|       |#pragma mark - FIRCoreDiagnosticsData
   44|       |
   45|      2|- (NSDictionary<NSString *, id> *)diagnosticObjects {
   46|      2|  if (!_diagnosticObjects[kFIRCDllAppsCountKey]) {
   47|      2|    _diagnosticObjects[kFIRCDllAppsCountKey] = @([FIRApp allApps].count);
   48|      2|  }
   49|      2|  if (!_diagnosticObjects[kFIRCDIsDataCollectionDefaultEnabledKey]) {
   50|      0|    _diagnosticObjects[kFIRCDIsDataCollectionDefaultEnabledKey] =
   51|      0|        @([[FIRApp defaultApp] isDataCollectionDefaultEnabled]);
   52|      0|  }
   53|      2|  if (!_diagnosticObjects[kFIRCDFirebaseUserAgentKey]) {
   54|      0|    _diagnosticObjects[kFIRCDFirebaseUserAgentKey] = [FIRApp firebaseUserAgent];
   55|      0|  }
   56|      2|  return _diagnosticObjects;
   57|      2|}
   58|       |
   59|       |#pragma clang diagnostic push
   60|       |#pragma clang diagnostic ignored "-Wunused-parameter"
   61|      0|- (void)setDiagnosticObjects:(NSDictionary<NSString *, id> *)diagnosticObjects {
   62|      0|  NSAssert(NO, @"Please use -insertValue:forKey:");
   63|      0|}
   64|       |#pragma clang diagnostic pop
   65|       |
   66|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRHeartbeatInfo.m:
    1|       |// Copyright 2019 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/Private/FIRHeartbeatInfo.h"
   16|       |#import <GoogleUtilities/GULHeartbeatDateStorage.h>
   17|       |#import <GoogleUtilities/GULLogger.h>
   18|       |
   19|       |const static long secondsInDay = 86400;
   20|       |@implementation FIRHeartbeatInfo : NSObject
   21|       |
   22|       |/** Updates the storage with the heartbeat information corresponding to this tag.
   23|       | * @param heartbeatTag Tag which could either be sdk specific tag or the global tag.
   24|       | * @return Boolean representing whether the heartbeat needs to be sent for this tag or not.
   25|       | */
   26|      0|+ (BOOL)updateIfNeededHeartbeatDateForTag:(NSString *)heartbeatTag {
   27|      0|  @synchronized(self) {
   28|      0|    NSString *const kHeartbeatStorageFile = @"HEARTBEAT_INFO_STORAGE";
   29|      0|    GULHeartbeatDateStorage *dataStorage =
   30|      0|        [[GULHeartbeatDateStorage alloc] initWithFileName:kHeartbeatStorageFile];
   31|      0|    NSDate *heartbeatTime = [dataStorage heartbeatDateForTag:heartbeatTag];
   32|      0|    NSDate *currentDate = [NSDate date];
   33|      0|    if (heartbeatTime != nil) {
   34|      0|      NSTimeInterval secondsBetween = [currentDate timeIntervalSinceDate:heartbeatTime];
   35|      0|      if (secondsBetween < secondsInDay) {
   36|      0|        return false;
   37|      0|      }
   38|      0|    }
   39|      0|    return [dataStorage setHearbeatDate:currentDate forTag:heartbeatTag];
   40|      0|  }
   41|      0|}
   42|       |
   43|      0|+ (FIRHeartbeatInfoCode)heartbeatCodeForTag:(NSString *)heartbeatTag {
   44|      0|  NSString *globalTag = @"GLOBAL";
   45|      0|  BOOL isSdkHeartbeatNeeded = [FIRHeartbeatInfo updateIfNeededHeartbeatDateForTag:heartbeatTag];
   46|      0|  BOOL isGlobalHeartbeatNeeded = [FIRHeartbeatInfo updateIfNeededHeartbeatDateForTag:globalTag];
   47|      0|  if (!isSdkHeartbeatNeeded && !isGlobalHeartbeatNeeded) {
   48|      0|    // Both sdk and global heartbeat not needed.
   49|      0|    return FIRHeartbeatInfoCodeNone;
   50|      0|  } else if (isSdkHeartbeatNeeded && !isGlobalHeartbeatNeeded) {
   51|      0|    // Only SDK heartbeat needed.
   52|      0|    return FIRHeartbeatInfoCodeSDK;
   53|      0|  } else if (!isSdkHeartbeatNeeded && isGlobalHeartbeatNeeded) {
   54|      0|    // Only global heartbeat needed.
   55|      0|    return FIRHeartbeatInfoCodeGlobal;
   56|      0|  } else {
   57|      0|    // Both sdk and global heartbeat are needed.
   58|      0|    return FIRHeartbeatInfoCodeCombined;
   59|      0|  }
   60|      0|}
   61|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIRLogger.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/Private/FIRLogger.h"
   16|       |
   17|       |#import <FirebaseCore/FIRLoggerLevel.h>
   18|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |
   21|       |#import "FirebaseCore/Sources/FIRVersion.h"
   22|       |
   23|       |FIRLoggerService kFIRLoggerCore = @"[Firebase/Core]";
   24|       |
   25|       |// All the FIRLoggerService definitions should be migrated to clients. Do not add new ones!
   26|       |FIRLoggerService kFIRLoggerABTesting = @"[Firebase/ABTesting]";
   27|       |FIRLoggerService kFIRLoggerAdMob = @"[Firebase/AdMob]";
   28|       |FIRLoggerService kFIRLoggerAnalytics = @"[Firebase/Analytics]";
   29|       |FIRLoggerService kFIRLoggerAuth = @"[Firebase/Auth]";
   30|       |FIRLoggerService kFIRLoggerCrash = @"[Firebase/Crash]";
   31|       |FIRLoggerService kFIRLoggerMLKit = @"[Firebase/MLKit]";
   32|       |FIRLoggerService kFIRLoggerPerf = @"[Firebase/Performance]";
   33|       |FIRLoggerService kFIRLoggerRemoteConfig = @"[Firebase/RemoteConfig]";
   34|       |
   35|       |/// Arguments passed on launch.
   36|       |NSString *const kFIRDisableDebugModeApplicationArgument = @"-FIRDebugDisabled";
   37|       |NSString *const kFIREnableDebugModeApplicationArgument = @"-FIRDebugEnabled";
   38|       |NSString *const kFIRLoggerForceSDTERRApplicationArgument = @"-FIRLoggerForceSTDERR";
   39|       |
   40|       |/// Key for the debug mode bit in NSUserDefaults.
   41|       |NSString *const kFIRPersistedDebugModeKey = @"/google/firebase/debug_mode";
   42|       |
   43|       |/// NSUserDefaults that should be used to store and read variables. If nil, `standardUserDefaults`
   44|       |/// will be used.
   45|       |static NSUserDefaults *sFIRLoggerUserDefaults;
   46|       |
   47|       |static dispatch_once_t sFIRLoggerOnceToken;
   48|       |
   49|       |// The sFIRAnalyticsDebugMode flag is here to support the -FIRDebugEnabled/-FIRDebugDisabled
   50|       |// flags used by Analytics. Users who use those flags expect Analytics to log verbosely,
   51|       |// while the rest of Firebase logs at the default level. This flag is introduced to support
   52|       |// that behavior.
   53|       |static BOOL sFIRAnalyticsDebugMode;
   54|       |
   55|       |#ifdef DEBUG
   56|       |/// The regex pattern for the message code.
   57|       |static NSString *const kMessageCodePattern = @"^I-[A-Z]{3}[0-9]{6}$";
   58|       |static NSRegularExpression *sMessageCodeRegex;
   59|       |#endif
   60|       |
   61|      4|void FIRLoggerInitializeASL() {
   62|      4|  dispatch_once(&sFIRLoggerOnceToken, ^{
   63|      1|    // Register Firebase Version with GULLogger.
   64|      1|    GULLoggerRegisterVersion(FIRVersionString);
   65|      1|
   66|      1|    // Override the aslOptions to ASL_OPT_STDERR if the override argument is passed in.
   67|      1|    NSArray *arguments = [NSProcessInfo processInfo].arguments;
   68|      1|    BOOL overrideSTDERR = [arguments containsObject:kFIRLoggerForceSDTERRApplicationArgument];
   69|      1|
   70|      1|    // Use the standard NSUserDefaults if it hasn't been explicitly set.
   71|      1|    if (sFIRLoggerUserDefaults == nil) {
   72|      1|      sFIRLoggerUserDefaults = [NSUserDefaults standardUserDefaults];
   73|      1|    }
   74|      1|
   75|      1|    BOOL forceDebugMode = NO;
   76|      1|    BOOL debugMode = [sFIRLoggerUserDefaults boolForKey:kFIRPersistedDebugModeKey];
   77|      1|    if ([arguments containsObject:kFIRDisableDebugModeApplicationArgument]) {  // Default mode
   78|      0|      [sFIRLoggerUserDefaults removeObjectForKey:kFIRPersistedDebugModeKey];
   79|      1|    } else if ([arguments containsObject:kFIREnableDebugModeApplicationArgument] ||
   80|      1|               debugMode) {  // Debug mode
   81|      0|      [sFIRLoggerUserDefaults setBool:YES forKey:kFIRPersistedDebugModeKey];
   82|      0|      forceDebugMode = YES;
   83|      0|    }
   84|      1|    GULLoggerInitializeASL();
   85|      1|    if (overrideSTDERR) {
   86|      0|      GULLoggerEnableSTDERR();
   87|      0|    }
   88|      1|    if (forceDebugMode) {
   89|      0|      GULLoggerForceDebug();
   90|      0|    }
   91|      1|  });
   92|      4|}
   93|       |
   94|      0|__attribute__((no_sanitize("thread"))) void FIRSetAnalyticsDebugMode(BOOL analyticsDebugMode) {
   95|      0|  sFIRAnalyticsDebugMode = analyticsDebugMode;
   96|      0|}
   97|       |
   98|      0|void FIRSetLoggerLevel(FIRLoggerLevel loggerLevel) {
   99|      0|  FIRLoggerInitializeASL();
  100|      0|  GULSetLoggerLevel((GULLoggerLevel)loggerLevel);
  101|      0|}
  102|       |
  103|       |#ifdef DEBUG
  104|      0|void FIRResetLogger() {
  105|      0|  extern void GULResetLogger(void);
  106|      0|  sFIRLoggerOnceToken = 0;
  107|      0|  [sFIRLoggerUserDefaults removeObjectForKey:kFIRPersistedDebugModeKey];
  108|      0|  sFIRLoggerUserDefaults = nil;
  109|      0|  GULResetLogger();
  110|      0|}
  111|       |
  112|      0|void FIRSetLoggerUserDefaults(NSUserDefaults *defaults) {
  113|      0|  sFIRLoggerUserDefaults = defaults;
  114|      0|}
  115|       |#endif
  116|       |
  117|       |/**
  118|       | * Check if the level is high enough to be loggable.
  119|       | *
  120|       | * Analytics can override the log level with an intentional race condition.
  121|       | * Add the attribute to get a clean thread sanitizer run.
  122|       | */
  123|       |__attribute__((no_sanitize("thread"))) BOOL FIRIsLoggableLevel(FIRLoggerLevel loggerLevel,
  124|      0|                                                               BOOL analyticsComponent) {
  125|      0|  FIRLoggerInitializeASL();
  126|      0|  if (sFIRAnalyticsDebugMode && analyticsComponent) {
  127|      0|    return YES;
  128|      0|  }
  129|      0|  return GULIsLoggableLevel((GULLoggerLevel)loggerLevel);
  130|      0|}
  131|       |
  132|       |void FIRLogBasic(FIRLoggerLevel level,
  133|       |                 FIRLoggerService service,
  134|       |                 NSString *messageCode,
  135|       |                 NSString *message,
  136|      4|                 va_list args_ptr) {
  137|      4|  FIRLoggerInitializeASL();
  138|      4|  GULLogBasic((GULLoggerLevel)level, service,
  139|      4|              sFIRAnalyticsDebugMode && [kFIRLoggerAnalytics isEqualToString:service], messageCode,
  140|      4|              message, args_ptr);
  141|      4|}
  142|       |
  143|       |/**
  144|       | * Generates the logging functions using macros.
  145|       | *
  146|       | * Calling FIRLogError(kFIRLoggerCore, @"I-COR000001", @"Configure %@ failed.", @"blah") shows:
  147|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Error> [Firebase/Core][I-COR000001] Configure blah failed.
  148|       | * Calling FIRLogDebug(kFIRLoggerCore, @"I-COR000001", @"Configure succeed.") shows:
  149|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Debug> [Firebase/Core][I-COR000001] Configure succeed.
  150|       | */
  151|       |#define FIR_LOGGING_FUNCTION(level)                                                             \
  152|      4|  void FIRLog##level(FIRLoggerService service, NSString *messageCode, NSString *message, ...) { \
  153|      4|    va_list args_ptr;                                                                           \
  154|      4|    va_start(args_ptr, message);                                                                \
  155|      4|    FIRLogBasic(FIRLoggerLevel##level, service, messageCode, message, args_ptr);                \
  156|      4|    va_end(args_ptr);                                                                           \
  157|      4|  }
  ------------------
  | Unexecuted instantiation: FIRLogError
  ------------------
  | Unexecuted instantiation: FIRLogWarning
  ------------------
  | Unexecuted instantiation: FIRLogNotice
  ------------------
  | Unexecuted instantiation: FIRLogInfo
  ------------------
  | FIRLogDebug:
  |  152|      4|  void FIRLog##level(FIRLoggerService service, NSString *messageCode, NSString *message, ...) { \
  |  153|      4|    va_list args_ptr;                                                                           \
  |  154|      4|    va_start(args_ptr, message);                                                                \
  |  155|      4|    FIRLogBasic(FIRLoggerLevel##level, service, messageCode, message, args_ptr);                \
  |  156|      4|    va_end(args_ptr);                                                                           \
  |  157|      4|  }
  ------------------
  158|       |
  159|       |FIR_LOGGING_FUNCTION(Error)
  160|       |FIR_LOGGING_FUNCTION(Warning)
  161|       |FIR_LOGGING_FUNCTION(Notice)
  162|       |FIR_LOGGING_FUNCTION(Info)
  163|       |FIR_LOGGING_FUNCTION(Debug)
  164|       |
  165|       |#undef FIR_MAKE_LOGGER
  166|       |
  167|       |#pragma mark - FIRLoggerWrapper
  168|       |
  169|       |@implementation FIRLoggerWrapper
  170|       |
  171|       |+ (void)logWithLevel:(FIRLoggerLevel)level
  172|       |         withService:(FIRLoggerService)service
  173|       |            withCode:(NSString *)messageCode
  174|       |         withMessage:(NSString *)message
  175|      0|            withArgs:(va_list)args {
  176|      0|  FIRLogBasic(level, service, messageCode, message, args);
  177|      0|}
  178|       |
  179|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/FIROptions.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FirebaseCore/Sources/FIRBundleUtil.h"
   16|       |#import "FirebaseCore/Sources/FIRVersion.h"
   17|       |#import "FirebaseCore/Sources/Private/FIRAppInternal.h"
   18|       |#import "FirebaseCore/Sources/Private/FIRLogger.h"
   19|       |#import "FirebaseCore/Sources/Private/FIROptionsInternal.h"
   20|       |
   21|       |// Keys for the strings in the plist file.
   22|       |NSString *const kFIRAPIKey = @"API_KEY";
   23|       |NSString *const kFIRTrackingID = @"TRACKING_ID";
   24|       |NSString *const kFIRGoogleAppID = @"GOOGLE_APP_ID";
   25|       |NSString *const kFIRClientID = @"CLIENT_ID";
   26|       |NSString *const kFIRGCMSenderID = @"GCM_SENDER_ID";
   27|       |NSString *const kFIRAndroidClientID = @"ANDROID_CLIENT_ID";
   28|       |NSString *const kFIRDatabaseURL = @"DATABASE_URL";
   29|       |NSString *const kFIRStorageBucket = @"STORAGE_BUCKET";
   30|       |// The key to locate the expected bundle identifier in the plist file.
   31|       |NSString *const kFIRBundleID = @"BUNDLE_ID";
   32|       |// The key to locate the project identifier in the plist file.
   33|       |NSString *const kFIRProjectID = @"PROJECT_ID";
   34|       |
   35|       |NSString *const kFIRIsMeasurementEnabled = @"IS_MEASUREMENT_ENABLED";
   36|       |NSString *const kFIRIsAnalyticsCollectionEnabled = @"FIREBASE_ANALYTICS_COLLECTION_ENABLED";
   37|       |NSString *const kFIRIsAnalyticsCollectionDeactivated = @"FIREBASE_ANALYTICS_COLLECTION_DEACTIVATED";
   38|       |
   39|       |NSString *const kFIRIsAnalyticsEnabled = @"IS_ANALYTICS_ENABLED";
   40|       |NSString *const kFIRIsSignInEnabled = @"IS_SIGNIN_ENABLED";
   41|       |
   42|       |// Library version ID formatted like:
   43|       |// @"5"     // Major version (one or more digits)
   44|       |// @"04"    // Minor version (exactly 2 digits)
   45|       |// @"01"    // Build number (exactly 2 digits)
   46|       |// @"000";  // Fixed "000"
   47|       |NSString *kFIRLibraryVersionID;
   48|       |
   49|       |// Plist file name.
   50|       |NSString *const kServiceInfoFileName = @"GoogleService-Info";
   51|       |// Plist file type.
   52|       |NSString *const kServiceInfoFileType = @"plist";
   53|       |
   54|       |// Exception raised from attempting to modify a FIROptions after it's been copied to a FIRApp.
   55|       |NSString *const kFIRExceptionBadModification =
   56|       |    @"Attempted to modify options after it's set on FIRApp. Please modify all properties before "
   57|       |    @"initializing FIRApp.";
   58|       |
   59|       |@interface FIROptions ()
   60|       |
   61|       |/**
   62|       | * This property maintains the actual configuration key-value pairs.
   63|       | */
   64|       |@property(nonatomic, readwrite) NSMutableDictionary *optionsDictionary;
   65|       |
   66|       |/**
   67|       | * Calls `analyticsOptionsDictionaryWithInfoDictionary:` using [NSBundle mainBundle].infoDictionary.
   68|       | * It combines analytics options from both the infoDictionary and the GoogleService-Info.plist.
   69|       | * Values which are present in the main plist override values from the GoogleService-Info.plist.
   70|       | */
   71|       |@property(nonatomic, readonly) NSDictionary *analyticsOptionsDictionary;
   72|       |
   73|       |/**
   74|       | * Combination of analytics options from both the infoDictionary and the GoogleService-Info.plist.
   75|       | * Values which are present in the infoDictionary override values from the GoogleService-Info.plist.
   76|       | */
   77|       |- (NSDictionary *)analyticsOptionsDictionaryWithInfoDictionary:(NSDictionary *)infoDictionary;
   78|       |
   79|       |/**
   80|       | * Throw exception if editing is locked when attempting to modify an option.
   81|       | */
   82|       |- (void)checkEditingLocked;
   83|       |
   84|       |@end
   85|       |
   86|       |@implementation FIROptions {
   87|       |  /// Backing variable for self.analyticsOptionsDictionary.
   88|       |  NSDictionary *_analyticsOptionsDictionary;
   89|       |}
   90|       |
   91|       |static FIROptions *sDefaultOptions = nil;
   92|       |static NSDictionary *sDefaultOptionsDictionary = nil;
   93|       |
   94|       |#pragma mark - Public only for internal class methods
   95|       |
   96|      1|+ (FIROptions *)defaultOptions {
   97|      1|  if (sDefaultOptions != nil) {
   98|      0|    return sDefaultOptions;
   99|      0|  }
  100|      1|
  101|      1|  NSDictionary *defaultOptionsDictionary = [self defaultOptionsDictionary];
  102|      1|  if (defaultOptionsDictionary == nil) {
  103|      0|    return nil;
  104|      0|  }
  105|      1|
  106|      1|  sDefaultOptions = [[FIROptions alloc] initInternalWithOptionsDictionary:defaultOptionsDictionary];
  107|      1|  return sDefaultOptions;
  108|      1|}
  109|       |
  110|       |#pragma mark - Private class methods
  111|       |
  112|      2|+ (NSDictionary *)defaultOptionsDictionary {
  113|      2|  if (sDefaultOptionsDictionary != nil) {
  114|      1|    return sDefaultOptionsDictionary;
  115|      1|  }
  116|      1|  NSString *plistFilePath = [FIROptions plistFilePathWithName:kServiceInfoFileName];
  117|      1|  if (plistFilePath == nil) {
  118|      0|    return nil;
  119|      0|  }
  120|      1|  sDefaultOptionsDictionary = [NSDictionary dictionaryWithContentsOfFile:plistFilePath];
  121|      1|  if (sDefaultOptionsDictionary == nil) {
  122|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000011",
  123|      0|                @"The configuration file is not a dictionary: "
  124|      0|                @"'%@.%@'.",
  125|      0|                kServiceInfoFileName, kServiceInfoFileType);
  126|      0|  }
  127|      1|  return sDefaultOptionsDictionary;
  128|      1|}
  129|       |
  130|       |// Returns the path of the plist file with a given file name.
  131|      1|+ (NSString *)plistFilePathWithName:(NSString *)fileName {
  132|      1|  NSArray *bundles = [FIRBundleUtil relevantBundles];
  133|      1|  NSString *plistFilePath =
  134|      1|      [FIRBundleUtil optionsDictionaryPathWithResourceName:fileName
  135|      1|                                               andFileType:kServiceInfoFileType
  136|      1|                                                 inBundles:bundles];
  137|      1|  if (plistFilePath == nil) {
  138|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000012", @"Could not locate configuration file: '%@.%@'.",
  139|      0|                fileName, kServiceInfoFileType);
  140|      0|  }
  141|      1|  return plistFilePath;
  142|      1|}
  143|       |
  144|      0|+ (void)resetDefaultOptions {
  145|      0|  sDefaultOptions = nil;
  146|      0|  sDefaultOptionsDictionary = nil;
  147|      0|}
  148|       |
  149|       |#pragma mark - Private instance methods
  150|       |
  151|      1|- (instancetype)initInternalWithOptionsDictionary:(NSDictionary *)optionsDictionary {
  152|      1|  self = [super init];
  153|      1|  if (self) {
  154|      1|    _optionsDictionary = [optionsDictionary mutableCopy];
  155|      1|    _usingOptionsFromDefaultPlist = YES;
  156|      1|  }
  157|      1|  return self;
  158|      1|}
  159|       |
  160|      4|- (id)copyWithZone:(NSZone *)zone {
  161|      4|  FIROptions *newOptions = [[[self class] allocWithZone:zone] init];
  162|      4|  if (newOptions) {
  163|      4|    newOptions.optionsDictionary = self.optionsDictionary;
  164|      4|    newOptions.deepLinkURLScheme = self.deepLinkURLScheme;
  165|      4|    newOptions.appGroupID = self.appGroupID;
  166|      4|    newOptions.editingLocked = self.isEditingLocked;
  167|      4|    newOptions.usingOptionsFromDefaultPlist = self.usingOptionsFromDefaultPlist;
  168|      4|  }
  169|      4|  return newOptions;
  170|      4|}
  171|       |
  172|       |#pragma mark - Public instance methods
  173|       |
  174|      0|- (instancetype)initWithContentsOfFile:(NSString *)plistPath {
  175|      0|  self = [super init];
  176|      0|  if (self) {
  177|      0|    if (plistPath == nil) {
  178|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000013", @"The plist file path is nil.");
  179|      0|      return nil;
  180|      0|    }
  181|      0|    _optionsDictionary = [[NSDictionary dictionaryWithContentsOfFile:plistPath] mutableCopy];
  182|      0|    if (_optionsDictionary == nil) {
  183|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000014",
  184|      0|                  @"The configuration file at %@ does not exist or "
  185|      0|                  @"is not a well-formed plist file.",
  186|      0|                  plistPath);
  187|      0|      return nil;
  188|      0|    }
  189|      0|    // TODO: Do we want to validate the dictionary here? It says we do that already in
  190|      0|    // the public header.
  191|      0|  }
  192|      0|  return self;
  193|      0|}
  194|       |
  195|      0|- (instancetype)initWithGoogleAppID:(NSString *)googleAppID GCMSenderID:(NSString *)GCMSenderID {
  196|      0|  self = [super init];
  197|      0|  if (self) {
  198|      0|    NSMutableDictionary *mutableOptionsDict = [NSMutableDictionary dictionary];
  199|      0|    [mutableOptionsDict setValue:googleAppID forKey:kFIRGoogleAppID];
  200|      0|    [mutableOptionsDict setValue:GCMSenderID forKey:kFIRGCMSenderID];
  201|      0|    [mutableOptionsDict setValue:[[NSBundle mainBundle] bundleIdentifier] forKey:kFIRBundleID];
  202|      0|    self.optionsDictionary = mutableOptionsDict;
  203|      0|  }
  204|      0|  return self;
  205|      0|}
  206|       |
  207|      2|- (NSString *)APIKey {
  208|      2|  return self.optionsDictionary[kFIRAPIKey];
  209|      2|}
  210|       |
  211|      8|- (void)checkEditingLocked {
  212|      8|  if (self.isEditingLocked) {
  213|      0|    [NSException raise:kFirebaseCoreErrorDomain format:kFIRExceptionBadModification];
  214|      0|  }
  215|      8|}
  216|       |
  217|      0|- (void)setAPIKey:(NSString *)APIKey {
  218|      0|  [self checkEditingLocked];
  219|      0|  _optionsDictionary[kFIRAPIKey] = [APIKey copy];
  220|      0|}
  221|       |
  222|      0|- (NSString *)clientID {
  223|      0|  return self.optionsDictionary[kFIRClientID];
  224|      0|}
  225|       |
  226|      0|- (void)setClientID:(NSString *)clientID {
  227|      0|  [self checkEditingLocked];
  228|      0|  _optionsDictionary[kFIRClientID] = [clientID copy];
  229|      0|}
  230|       |
  231|      0|- (NSString *)trackingID {
  232|      0|  return self.optionsDictionary[kFIRTrackingID];
  233|      0|}
  234|       |
  235|      0|- (void)setTrackingID:(NSString *)trackingID {
  236|      0|  [self checkEditingLocked];
  237|      0|  _optionsDictionary[kFIRTrackingID] = [trackingID copy];
  238|      0|}
  239|       |
  240|      1|- (NSString *)GCMSenderID {
  241|      1|  return self.optionsDictionary[kFIRGCMSenderID];
  242|      1|}
  243|       |
  244|      0|- (void)setGCMSenderID:(NSString *)GCMSenderID {
  245|      0|  [self checkEditingLocked];
  246|      0|  _optionsDictionary[kFIRGCMSenderID] = [GCMSenderID copy];
  247|      0|}
  248|       |
  249|      2|- (NSString *)projectID {
  250|      2|  return self.optionsDictionary[kFIRProjectID];
  251|      2|}
  252|       |
  253|      0|- (void)setProjectID:(NSString *)projectID {
  254|      0|  [self checkEditingLocked];
  255|      0|  _optionsDictionary[kFIRProjectID] = [projectID copy];
  256|      0|}
  257|       |
  258|      0|- (NSString *)androidClientID {
  259|      0|  return self.optionsDictionary[kFIRAndroidClientID];
  260|      0|}
  261|       |
  262|      0|- (void)setAndroidClientID:(NSString *)androidClientID {
  263|      0|  [self checkEditingLocked];
  264|      0|  _optionsDictionary[kFIRAndroidClientID] = [androidClientID copy];
  265|      0|}
  266|       |
  267|      7|- (NSString *)googleAppID {
  268|      7|  return self.optionsDictionary[kFIRGoogleAppID];
  269|      7|}
  270|       |
  271|      0|- (void)setGoogleAppID:(NSString *)googleAppID {
  272|      0|  [self checkEditingLocked];
  273|      0|  _optionsDictionary[kFIRGoogleAppID] = [googleAppID copy];
  274|      0|}
  275|       |
  276|      2|- (NSString *)libraryVersionID {
  277|      2|  static dispatch_once_t onceToken;
  278|      2|  dispatch_once(&onceToken, ^{
  279|      1|    // The unit tests are set up to catch anything that does not properly convert.
  280|      1|    NSString *version = [NSString stringWithUTF8String:FIRCoreVersionString];
  281|      1|    NSArray *components = [version componentsSeparatedByString:@"."];
  282|      1|    NSString *major = [components objectAtIndex:0];
  283|      1|    NSString *minor = [NSString stringWithFormat:@"%02d", [[components objectAtIndex:1] intValue]];
  284|      1|    NSString *patch = [NSString stringWithFormat:@"%02d", [[components objectAtIndex:2] intValue]];
  285|      1|    kFIRLibraryVersionID = [NSString stringWithFormat:@"%@%@%@000", major, minor, patch];
  286|      1|  });
  287|      2|  return kFIRLibraryVersionID;
  288|      2|}
  289|       |
  290|      0|- (void)setLibraryVersionID:(NSString *)libraryVersionID {
  291|      0|  _optionsDictionary[kFIRLibraryVersionID] = [libraryVersionID copy];
  292|      0|}
  293|       |
  294|      0|- (NSString *)databaseURL {
  295|      0|  return self.optionsDictionary[kFIRDatabaseURL];
  296|      0|}
  297|       |
  298|      0|- (void)setDatabaseURL:(NSString *)databaseURL {
  299|      0|  [self checkEditingLocked];
  300|      0|
  301|      0|  _optionsDictionary[kFIRDatabaseURL] = [databaseURL copy];
  302|      0|}
  303|       |
  304|      0|- (NSString *)storageBucket {
  305|      0|  return self.optionsDictionary[kFIRStorageBucket];
  306|      0|}
  307|       |
  308|      0|- (void)setStorageBucket:(NSString *)storageBucket {
  309|      0|  [self checkEditingLocked];
  310|      0|  _optionsDictionary[kFIRStorageBucket] = [storageBucket copy];
  311|      0|}
  312|       |
  313|      4|- (void)setDeepLinkURLScheme:(NSString *)deepLinkURLScheme {
  314|      4|  [self checkEditingLocked];
  315|      4|  _deepLinkURLScheme = [deepLinkURLScheme copy];
  316|      4|}
  317|       |
  318|      3|- (NSString *)bundleID {
  319|      3|  return self.optionsDictionary[kFIRBundleID];
  320|      3|}
  321|       |
  322|      0|- (void)setBundleID:(NSString *)bundleID {
  323|      0|  [self checkEditingLocked];
  324|      0|  _optionsDictionary[kFIRBundleID] = [bundleID copy];
  325|      0|}
  326|       |
  327|      4|- (void)setAppGroupID:(NSString *)appGroupID {
  328|      4|  [self checkEditingLocked];
  329|      4|  _appGroupID = [appGroupID copy];
  330|      4|}
  331|       |
  332|       |#pragma mark - Equality
  333|       |
  334|      0|- (BOOL)isEqual:(id)object {
  335|      0|  if (!object || ![object isKindOfClass:[FIROptions class]]) {
  336|      0|    return NO;
  337|      0|  }
  338|      0|
  339|      0|  return [self isEqualToOptions:(FIROptions *)object];
  340|      0|}
  341|       |
  342|      0|- (BOOL)isEqualToOptions:(FIROptions *)options {
  343|      0|  // Skip any non-FIROptions classes.
  344|      0|  if (![options isKindOfClass:[FIROptions class]]) {
  345|      0|    return NO;
  346|      0|  }
  347|      0|
  348|      0|  // Check the internal dictionary and custom properties for differences.
  349|      0|  if (![options.optionsDictionary isEqualToDictionary:self.optionsDictionary]) {
  350|      0|    return NO;
  351|      0|  }
  352|      0|
  353|      0|  // Validate extra properties not contained in the dictionary. Only validate it if one of the
  354|      0|  // objects has the property set.
  355|      0|  if ((options.deepLinkURLScheme != nil || self.deepLinkURLScheme != nil) &&
  356|      0|      ![options.deepLinkURLScheme isEqualToString:self.deepLinkURLScheme]) {
  357|      0|    return NO;
  358|      0|  }
  359|      0|
  360|      0|  if ((options.appGroupID != nil || self.appGroupID != nil) &&
  361|      0|      ![options.appGroupID isEqualToString:self.appGroupID]) {
  362|      0|    return NO;
  363|      0|  }
  364|      0|
  365|      0|  // Validate the Analytics options haven't changed with the Info.plist.
  366|      0|  if (![options.analyticsOptionsDictionary isEqualToDictionary:self.analyticsOptionsDictionary]) {
  367|      0|    return NO;
  368|      0|  }
  369|      0|
  370|      0|  // We don't care about the `editingLocked` or `usingOptionsFromDefaultPlist` properties since
  371|      0|  // those relate to lifecycle and construction, we only care if the contents of the options
  372|      0|  // themselves are equal.
  373|      0|  return YES;
  374|      0|}
  375|       |
  376|      0|- (NSUInteger)hash {
  377|      0|  // This is strongly recommended for any object that implements a custom `isEqual:` method to
  378|      0|  // ensure that dictionary and set behavior matches other `isEqual:` checks.
  379|      0|  // Note: `self.analyticsOptionsDictionary` was left out here since it solely relies on the
  380|      0|  // contents of the main bundle's `Info.plist`. We should avoid reading that file and the contents
  381|      0|  // should be identical.
  382|      0|  return self.optionsDictionary.hash ^ self.deepLinkURLScheme.hash ^ self.appGroupID.hash;
  383|      0|}
  384|       |
  385|       |#pragma mark - Internal instance methods
  386|       |
  387|      5|- (NSDictionary *)analyticsOptionsDictionaryWithInfoDictionary:(NSDictionary *)infoDictionary {
  388|      5|  if (_analyticsOptionsDictionary == nil) {
  389|      1|    NSMutableDictionary *tempAnalyticsOptions = [[NSMutableDictionary alloc] init];
  390|      1|    NSArray *measurementKeys = @[
  391|      1|      kFIRIsMeasurementEnabled, kFIRIsAnalyticsCollectionEnabled,
  392|      1|      kFIRIsAnalyticsCollectionDeactivated
  393|      1|    ];
  394|      3|    for (NSString *key in measurementKeys) {
  395|      3|      id value = infoDictionary[key] ?: self.optionsDictionary[key] ?: nil;
  396|      3|      if (!value) {
  397|      3|        continue;
  398|      3|      }
  399|      0|      tempAnalyticsOptions[key] = value;
  400|      0|    }
  401|      1|    _analyticsOptionsDictionary = tempAnalyticsOptions;
  402|      1|  }
  403|      5|  return _analyticsOptionsDictionary;
  404|      5|}
  405|       |
  406|      5|- (NSDictionary *)analyticsOptionsDictionary {
  407|      5|  return [self analyticsOptionsDictionaryWithInfoDictionary:[NSBundle mainBundle].infoDictionary];
  408|      5|}
  409|       |
  410|       |/**
  411|       | * Whether or not Measurement was enabled. Measurement is enabled unless explicitly disabled in
  412|       | * GoogleService-Info.plist. This uses the old plist flag IS_MEASUREMENT_ENABLED, which should still
  413|       | * be supported.
  414|       | */
  415|      1|- (BOOL)isMeasurementEnabled {
  416|      1|  if (self.isAnalyticsCollectionDeactivated) {
  417|      0|    return NO;
  418|      0|  }
  419|      1|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsMeasurementEnabled];
  420|      1|  if (value == nil) {
  421|      1|    // TODO: This could probably be cleaned up since FIROptions shouldn't know about FIRApp or have
  422|      1|    //       to check if it's the default app. The FIROptions instance can't be modified after
  423|      1|    //       `+configure` is called, so it's not a good place to copy it either in case the flag is
  424|      1|    //       changed at runtime.
  425|      1|
  426|      1|    // If no values are set for Analytics, fall back to the global collection switch in FIRApp.
  427|      1|    // Analytics only supports the default FIRApp, so check that first.
  428|      1|    if (![FIRApp isDefaultAppConfigured]) {
  429|      0|      return NO;
  430|      0|    }
  431|      1|
  432|      1|    // Fall back to the default app's collection switch when the key is not in the dictionary.
  433|      1|    return [FIRApp defaultApp].isDataCollectionDefaultEnabled;
  434|      1|  }
  435|      0|  return [value boolValue];
  436|      0|}
  437|       |
  438|      0|- (BOOL)isAnalyticsCollectionExplicitlySet {
  439|      0|  // If it's de-activated, it classifies as explicity set. If not, it's not a good enough indication
  440|      0|  // that the developer wants FirebaseAnalytics enabled so continue checking.
  441|      0|  if (self.isAnalyticsCollectionDeactivated) {
  442|      0|    return YES;
  443|      0|  }
  444|      0|
  445|      0|  // Check if the current Analytics flag is set.
  446|      0|  id collectionEnabledObject = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionEnabled];
  447|      0|  if (collectionEnabledObject && [collectionEnabledObject isKindOfClass:[NSNumber class]]) {
  448|      0|    // It doesn't matter what the value is, it's explicitly set.
  449|      0|    return YES;
  450|      0|  }
  451|      0|
  452|      0|  // Check if the old measurement flag is set.
  453|      0|  id measurementEnabledObject = self.analyticsOptionsDictionary[kFIRIsMeasurementEnabled];
  454|      0|  if (measurementEnabledObject && [measurementEnabledObject isKindOfClass:[NSNumber class]]) {
  455|      0|    // It doesn't matter what the value is, it's explicitly set.
  456|      0|    return YES;
  457|      0|  }
  458|      0|
  459|      0|  // No flags are set to explicitly enable or disable FirebaseAnalytics.
  460|      0|  return NO;
  461|      0|}
  462|       |
  463|      1|- (BOOL)isAnalyticsCollectionEnabled {
  464|      1|  if (self.isAnalyticsCollectionDeactivated) {
  465|      0|    return NO;
  466|      0|  }
  467|      1|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionEnabled];
  468|      1|  if (value == nil) {
  469|      1|    return self.isMeasurementEnabled;  // Fall back to older plist flag.
  470|      1|  }
  471|      0|  return [value boolValue];
  472|      0|}
  473|       |
  474|      3|- (BOOL)isAnalyticsCollectionDeactivated {
  475|      3|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionDeactivated];
  476|      3|  if (value == nil) {
  477|      3|    return NO;  // Analytics Collection is not deactivated when the key is not in the dictionary.
  478|      3|  }
  479|      0|  return [value boolValue];
  480|      0|}
  481|       |
  482|      0|- (BOOL)isAnalyticsEnabled {
  483|      0|  return [self.optionsDictionary[kFIRIsAnalyticsEnabled] boolValue];
  484|      0|}
  485|       |
  486|      0|- (BOOL)isSignInEnabled {
  487|      0|  return [self.optionsDictionary[kFIRIsSignInEnabled] boolValue];
  488|      0|}
  489|       |
  490|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCore/FirebaseCore/Sources/Private/FIRComponentContainer.h:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |#import <Foundation/Foundation.h>
   17|       |
   18|       |#import <FirebaseCore/FIRComponentType.h>
   19|       |#import <FirebaseCore/FIRLibrary.h>
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/// A type-safe macro to retrieve a component from a container. This should be used to retrieve
   24|       |/// components instead of using the container directly.
   25|       |#define FIR_COMPONENT(type, container) \
   26|      1|  [FIRComponentType<id<type>> instanceForProtocol:@protocol(type) inContainer:container]
   27|       |
   28|       |@class FIRApp;
   29|       |
   30|       |/// A container that holds different components that are registered via the
   31|       |/// `registerAsComponentRegistrant:` call. These classes should conform to `FIRComponentRegistrant`
   32|       |/// in order to properly register components for Core.
   33|       |NS_SWIFT_NAME(FirebaseComponentContainer)
   34|       |@interface FIRComponentContainer : NSObject
   35|       |
   36|       |/// A weak reference to the app that an instance of the container belongs to.
   37|       |@property(nonatomic, weak, readonly) FIRApp *app;
   38|       |
   39|       |/// Unavailable. Use the `container` property on `FIRApp`.
   40|       |- (instancetype)init NS_UNAVAILABLE;
   41|       |
   42|       |@end
   43|       |
   44|       |NS_ASSUME_NONNULL_END

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCoreDiagnostics/Firebase/CoreDiagnostics/FIRCDLibrary/FIRCoreDiagnostics.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <objc/runtime.h>
   18|       |#include <sys/utsname.h>
   19|       |
   20|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   21|       |#import <GoogleDataTransport/GDTCOREvent.h>
   22|       |#import <GoogleDataTransport/GDTCORTargets.h>
   23|       |#import <GoogleDataTransport/GDTCORTransport.h>
   24|       |
   25|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   26|       |#import <GoogleUtilities/GULHeartbeatDateStorage.h>
   27|       |#import <GoogleUtilities/GULLogger.h>
   28|       |
   29|       |#import <FirebaseCoreDiagnosticsInterop/FIRCoreDiagnosticsData.h>
   30|       |#import <FirebaseCoreDiagnosticsInterop/FIRCoreDiagnosticsInterop.h>
   31|       |
   32|       |#import <nanopb/pb.h>
   33|       |#import <nanopb/pb_decode.h>
   34|       |#import <nanopb/pb_encode.h>
   35|       |
   36|       |#import "FIRCDLibrary/Protogen/nanopb/firebasecore.nanopb.h"
   37|       |
   38|       |/** The logger service string to use when printing to the console. */
   39|       |static GULLoggerService kFIRCoreDiagnostics = @"[FirebaseCoreDiagnostics/FIRCoreDiagnostics]";
   40|       |
   41|       |#ifdef FIREBASE_BUILD_ZIP_FILE
   42|       |static BOOL kUsingZipFile = YES;
   43|       |#else   // FIREBASE_BUILD_ZIP_FILE
   44|       |static BOOL kUsingZipFile = NO;
   45|       |#endif  // FIREBASE_BUILD_ZIP_FILE
   46|       |
   47|       |#ifdef FIREBASE_BUILD_CARTHAGE
   48|       |#define kDeploymentType logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_CARTHAGE
   49|       |#elif FIREBASE_BUILD_ZIP_FILE
   50|       |#define kDeploymentType logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_ZIP_FILE
   51|       |#else
   52|      2|#define kDeploymentType logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_COCOAPODS
   53|       |#endif
   54|       |
   55|       |static NSString *const kFIRServiceMLVisionOnDeviceAutoML = @"MLVisionOnDeviceAutoML";
   56|       |static NSString *const kFIRServiceMLVisionOnDeviceFace = @"MLVisionOnDeviceFace";
   57|       |static NSString *const kFIRServiceMLVisionOnDeviceBarcode = @"MLVisionOnDeviceBarcode";
   58|       |static NSString *const kFIRServiceMLVisionOnDeviceText = @"MLVisionOnDeviceText";
   59|       |static NSString *const kFIRServiceMLVisionOnDeviceLabel = @"MLVisionOnDeviceLabel";
   60|       |static NSString *const kFIRServiceMLVisionOnDeviceObjectDetection =
   61|       |    @"MLVisionOnDeviceObjectDetection";
   62|       |static NSString *const kFIRServiceMLModelInterpreter = @"MLModelInterpreter";
   63|       |
   64|       |static NSString *const kFIRServiceAdMob = @"AdMob";
   65|       |static NSString *const kFIRServiceAuth = @"Auth";
   66|       |static NSString *const kFIRServiceAuthUI = @"AuthUI";
   67|       |static NSString *const kFIRServiceCrash = @"Crash";
   68|       |static NSString *const kFIRServiceDatabase = @"Database";
   69|       |static NSString *const kFIRServiceDynamicLinks = @"DynamicLinks";
   70|       |static NSString *const kFIRServiceFirestore = @"Firestore";
   71|       |static NSString *const kFIRServiceFunctions = @"Functions";
   72|       |static NSString *const kFIRServiceIAM = @"InAppMessaging";
   73|       |static NSString *const kFIRServiceInstanceID = @"InstanceID";
   74|       |static NSString *const kFIRServiceInvites = @"Invites";
   75|       |static NSString *const kFIRServiceMessaging = @"Messaging";
   76|       |static NSString *const kFIRServiceMeasurement = @"Measurement";
   77|       |static NSString *const kFIRServicePerformance = @"Performance";
   78|       |static NSString *const kFIRServiceRemoteConfig = @"RemoteConfig";
   79|       |static NSString *const kFIRServiceStorage = @"Storage";
   80|       |static NSString *const kGGLServiceAnalytics = @"Analytics";
   81|       |static NSString *const kGGLServiceSignIn = @"SignIn";
   82|       |static NSString *const kFIRAppDiagnosticsConfigurationTypeKey =
   83|       |    @"FIRAppDiagnosticsConfigurationTypeKey";
   84|       |static NSString *const kFIRAppDiagnosticsFIRAppKey = @"FIRAppDiagnosticsFIRAppKey";
   85|       |static NSString *const kFIRAppDiagnosticsSDKNameKey = @"FIRAppDiagnosticsSDKNameKey";
   86|       |static NSString *const kFIRAppDiagnosticsSDKVersionKey = @"FIRAppDiagnosticsSDKVersionKey";
   87|       |static NSString *const kFIRCoreDiagnosticsHeartbeatTag = @"FIRCoreDiagnostics";
   88|       |
   89|       |/**
   90|       | * The file name to the recent heartbeat date.
   91|       | */
   92|       |NSString *const kFIRCoreDiagnosticsHeartbeatDateFileName = @"FIREBASE_DIAGNOSTICS_HEARTBEAT_DATE";
   93|       |
   94|       |/**
   95|       | * @note This should implement the GDTCOREventDataObject protocol, but can't because of
   96|       | * weak-linking.
   97|       | */
   98|       |@interface FIRCoreDiagnosticsLog : NSObject
   99|       |
  100|       |/** The config that will be converted to proto bytes. */
  101|       |@property(nonatomic) logs_proto_mobilesdk_ios_ICoreConfiguration config;
  102|       |
  103|       |@end
  104|       |
  105|       |@implementation FIRCoreDiagnosticsLog
  106|       |
  107|      2|- (instancetype)initWithConfig:(logs_proto_mobilesdk_ios_ICoreConfiguration)config {
  108|      2|  self = [super init];
  109|      2|  if (self) {
  110|      2|    _config = config;
  111|      2|  }
  112|      2|  return self;
  113|      2|}
  114|       |
  115|       |// Provided and required by the GDTCOREventDataObject protocol.
  116|      4|- (NSData *)transportBytes {
  117|      4|  pb_ostream_t sizestream = PB_OSTREAM_SIZING;
  118|      4|
  119|      4|  // Encode 1 time to determine the size.
  120|      4|  if (!pb_encode(&sizestream, logs_proto_mobilesdk_ios_ICoreConfiguration_fields, &_config)) {
  121|      0|    GDTCORLogError(GDTCORMCETransportBytesError, @"Error in nanopb encoding for size: %s",
  122|      0|                   PB_GET_ERROR(&sizestream));
  123|      0|  }
  124|      4|
  125|      4|  // Encode a 2nd time to actually get the bytes from it.
  126|      4|  size_t bufferSize = sizestream.bytes_written;
  127|      4|  CFMutableDataRef dataRef = CFDataCreateMutable(CFAllocatorGetDefault(), bufferSize);
  128|      4|  CFDataSetLength(dataRef, bufferSize);
  129|      4|  pb_ostream_t ostream = pb_ostream_from_buffer((void *)CFDataGetBytePtr(dataRef), bufferSize);
  130|      4|  if (!pb_encode(&ostream, logs_proto_mobilesdk_ios_ICoreConfiguration_fields, &_config)) {
  131|      0|    GDTCORLogError(GDTCORMCETransportBytesError, @"Error in nanopb encoding for bytes: %s",
  132|      0|                   PB_GET_ERROR(&ostream));
  133|      0|  }
  134|      4|  CFDataSetLength(dataRef, ostream.bytes_written);
  135|      4|
  136|      4|  return CFBridgingRelease(dataRef);
  137|      4|}
  138|       |
  139|      2|- (void)dealloc {
  140|      2|  pb_release(logs_proto_mobilesdk_ios_ICoreConfiguration_fields, &_config);
  141|      2|}
  142|       |
  143|       |@end
  144|       |
  145|       |NS_ASSUME_NONNULL_BEGIN
  146|       |
  147|       |/** This class produces a protobuf containing diagnostics and usage data to be logged. */
  148|       |@interface FIRCoreDiagnostics : NSObject <FIRCoreDiagnosticsInterop>
  149|       |
  150|       |/** The queue on which all diagnostics collection will occur. */
  151|       |@property(nonatomic, readonly) dispatch_queue_t diagnosticsQueue;
  152|       |
  153|       |/** The transport object used to send data. */
  154|       |@property(nonatomic, readonly) GDTCORTransport *transport;
  155|       |
  156|       |/** The storage to store the date of the last sent heartbeat. */
  157|       |@property(nonatomic, readonly) GULHeartbeatDateStorage *heartbeatDateStorage;
  158|       |
  159|       |@end
  160|       |
  161|       |NS_ASSUME_NONNULL_END
  162|       |
  163|       |@implementation FIRCoreDiagnostics
  164|       |
  165|      2|+ (instancetype)sharedInstance {
  166|      2|  static FIRCoreDiagnostics *sharedInstance;
  167|      2|  static dispatch_once_t onceToken;
  168|      2|  dispatch_once(&onceToken, ^{
  169|      1|    sharedInstance = [[FIRCoreDiagnostics alloc] init];
  170|      1|  });
  171|      2|  return sharedInstance;
  172|      2|}
  173|       |
  174|      1|- (instancetype)init {
  175|      1|  GDTCORTransport *transport = [[GDTCORTransport alloc] initWithMappingID:@"137"
  176|      1|                                                             transformers:nil
  177|      1|                                                                   target:kGDTCORTargetFLL];
  178|      1|
  179|      1|  GULHeartbeatDateStorage *dateStorage =
  180|      1|      [[GULHeartbeatDateStorage alloc] initWithFileName:kFIRCoreDiagnosticsHeartbeatDateFileName];
  181|      1|
  182|      1|  return [self initWithTransport:transport heartbeatDateStorage:dateStorage];
  183|      1|}
  184|       |
  185|       |/** Initializer for unit tests.
  186|       | *
  187|       | * @param transport A `GDTCORTransport` instance which that be used to send event.
  188|       | * @param heartbeatDateStorage An instanse of date storage to track heartbeat sending.
  189|       | * @return Returns the initialized `FIRCoreDiagnostics` instance.
  190|       | */
  191|       |- (instancetype)initWithTransport:(GDTCORTransport *)transport
  192|      1|             heartbeatDateStorage:(GULHeartbeatDateStorage *)heartbeatDateStorage {
  193|      1|  self = [super init];
  194|      1|  if (self) {
  195|      1|    _diagnosticsQueue =
  196|      1|        dispatch_queue_create("com.google.FIRCoreDiagnostics", DISPATCH_QUEUE_SERIAL);
  197|      1|    _transport = transport;
  198|      1|    _heartbeatDateStorage = heartbeatDateStorage;
  199|      1|  }
  200|      1|  return self;
  201|      1|}
  202|       |
  203|       |#pragma mark - Metadata helpers
  204|       |
  205|       |/** Returns the model of iOS device. Sample platform strings are @"iPhone7,1" for iPhone 6 Plus,
  206|       | * @"iPhone7,2" for iPhone 6, etc. Refer to the Hardware strings at
  207|       | * https://en.wikipedia.org/wiki/List_of_iOS_devices
  208|       | *
  209|       | * @return The device model as an NSString.
  210|       | */
  211|      2|+ (NSString *)deviceModel {
  212|      2|  static NSString *deviceModel = nil;
  213|      2|  if (deviceModel == nil) {
  214|      1|    struct utsname systemInfo;
  215|      1|    uname(&systemInfo);
  216|      1|    deviceModel = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];
  217|      1|  }
  218|      2|  return deviceModel;
  219|      2|}
  220|       |
  221|       |#pragma mark - nanopb helper functions
  222|       |
  223|       |/** Mallocs a pb_bytes_array and copies the given NSString's bytes into the bytes array.
  224|       | *
  225|       | * @note Memory needs to be free manually, through pb_free or pb_release.
  226|       | * @param string The string to encode as pb_bytes.
  227|       | */
  228|     16|pb_bytes_array_t *FIREncodeString(NSString *string) {
  229|     16|  NSData *stringBytes = [string dataUsingEncoding:NSUTF8StringEncoding];
  230|     16|  return FIREncodeData(stringBytes);
  231|     16|}
  232|       |
  233|       |/** Mallocs a pb_bytes_array and copies the given NSData bytes into the bytes array.
  234|       | *
  235|       | * @note Memory needs to be free manually, through pb_free or pb_release.
  236|       | * @param data The data to copy into the new bytes array.
  237|       | */
  238|     16|pb_bytes_array_t *FIREncodeData(NSData *data) {
  239|     16|  pb_bytes_array_t *pbBytes = malloc(PB_BYTES_ARRAY_T_ALLOCSIZE(data.length));
  240|     16|  if (pbBytes != NULL) {
  241|     16|    memcpy(pbBytes->bytes, [data bytes], data.length);
  242|     16|    pbBytes->size = (pb_size_t)data.length;
  243|     16|  }
  244|     16|  return pbBytes;
  245|     16|}
  246|       |
  247|       |/** Maps a service string to the representative nanopb enum.
  248|       | *
  249|       | * @param serviceString The SDK service string to convert.
  250|       | * @return The representative nanopb enum.
  251|       | */
  252|       |logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType FIRMapFromServiceStringToTypeEnum(
  253|      2|    NSString *serviceString) {
  254|      2|  static NSDictionary<NSString *, NSNumber *> *serviceStringToTypeEnum;
  255|      2|  if (serviceStringToTypeEnum == nil) {
  256|      1|    serviceStringToTypeEnum = @{
  257|      1|      kFIRServiceAdMob : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ADMOB),
  258|      1|      kFIRServiceMessaging : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MESSAGING),
  259|      1|      kFIRServiceMeasurement :
  260|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MEASUREMENT),
  261|      1|      kFIRServiceRemoteConfig :
  262|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_REMOTE_CONFIG),
  263|      1|      kFIRServiceDatabase : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_DATABASE),
  264|      1|      kFIRServiceDynamicLinks :
  265|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_DYNAMIC_LINKS),
  266|      1|      kFIRServiceAuth : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_AUTH),
  267|      1|      kFIRServiceAuthUI : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_AUTH_UI),
  268|      1|      kFIRServiceFirestore : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_FIRESTORE),
  269|      1|      kFIRServiceFunctions : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_FUNCTIONS),
  270|      1|      kFIRServicePerformance :
  271|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_PERFORMANCE),
  272|      1|      kFIRServiceStorage : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_STORAGE),
  273|      1|      kFIRServiceMLVisionOnDeviceAutoML :
  274|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_AUTOML),
  275|      1|      kFIRServiceMLVisionOnDeviceFace :
  276|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_FACE),
  277|      1|      kFIRServiceMLVisionOnDeviceBarcode :
  278|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_BARCODE),
  279|      1|      kFIRServiceMLVisionOnDeviceText :
  280|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_TEXT),
  281|      1|      kFIRServiceMLVisionOnDeviceLabel :
  282|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_LABEL),
  283|      1|      kFIRServiceMLVisionOnDeviceObjectDetection : @(
  284|      1|          logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_OBJECT_DETECTION),
  285|      1|      kFIRServiceMLModelInterpreter :
  286|      1|          @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_MODEL_INTERPRETER),
  287|      1|      kGGLServiceAnalytics : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ANALYTICS),
  288|      1|      kGGLServiceSignIn : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_SIGN_IN),
  289|      1|      kFIRServiceIAM : @(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_IN_APP_MESSAGING),
  290|      1|    };
  291|      1|  }
  292|      2|  if (serviceStringToTypeEnum[serviceString] != nil) {
  293|      2|    return (int32_t)serviceStringToTypeEnum[serviceString].longLongValue;
  294|      2|  }
  295|      0|  return logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_UNKNOWN_SDK_SERVICE;
  296|      0|}
  297|       |
  298|       |#pragma mark - Proto population functions
  299|       |
  300|       |/** Populates the given proto with data related to an SDK logDiagnostics call from the
  301|       | * diagnosticObjects dictionary.
  302|       | *
  303|       | * @param config The proto to populate
  304|       | * @param diagnosticObjects The dictionary of diagnostics objects.
  305|       | */
  306|       |void FIRPopulateProtoWithInfoFromUserInfoParams(logs_proto_mobilesdk_ios_ICoreConfiguration *config,
  307|      2|                                                NSDictionary<NSString *, id> *diagnosticObjects) {
  308|      2|  NSNumber *configurationType = diagnosticObjects[kFIRCDConfigurationTypeKey];
  309|      2|  if (configurationType != nil) {
  310|      2|    switch (configurationType.integerValue) {
  311|      2|      case logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_CORE:
  312|      2|        config->configuration_type =
  313|      2|            logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_CORE;
  314|      2|        config->has_configuration_type = 1;
  315|      2|        break;
  316|      2|      case logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_SDK:
  317|      0|        config->configuration_type =
  318|      0|            logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_SDK;
  319|      0|        config->has_configuration_type = 1;
  320|      0|        break;
  321|      2|      default:
  322|      0|        break;
  323|      2|    }
  324|      2|  }
  325|      2|
  326|      2|  NSString *sdkName = diagnosticObjects[kFIRCDSdkNameKey];
  327|      2|  if (sdkName) {
  328|      0|    config->sdk_name = FIRMapFromServiceStringToTypeEnum(sdkName);
  329|      0|    config->has_sdk_name = 1;
  330|      0|  }
  331|      2|
  332|      2|  NSString *version = diagnosticObjects[kFIRCDSdkVersionKey];
  333|      2|  if (version) {
  334|      0|    config->sdk_version = FIREncodeString(version);
  335|      0|  }
  336|      2|}
  337|       |
  338|       |/** Populates the given proto with data from the calling FIRApp using the given
  339|       | * diagnosticObjects dictionary.
  340|       | *
  341|       | * @param config The proto to populate
  342|       | * @param diagnosticObjects The dictionary of diagnostics objects.
  343|       | */
  344|       |void FIRPopulateProtoWithCommonInfoFromApp(logs_proto_mobilesdk_ios_ICoreConfiguration *config,
  345|      2|                                           NSDictionary<NSString *, id> *diagnosticObjects) {
  346|      2|  config->pod_name = logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_FIREBASE;
  347|      2|  config->has_pod_name = 1;
  348|      2|
  349|      2|  if (!diagnosticObjects[kFIRCDllAppsCountKey]) {
  350|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"%@",
  351|      0|                   @"App count is a required value in the data dict.");
  352|      0|  }
  353|      2|  config->app_count = (int32_t)[diagnosticObjects[kFIRCDllAppsCountKey] integerValue];
  354|      2|  config->has_app_count = 1;
  355|      2|
  356|      2|  NSString *googleAppID = diagnosticObjects[kFIRCDGoogleAppIDKey];
  357|      2|  if (googleAppID.length) {
  358|      2|    config->app_id = FIREncodeString(googleAppID);
  359|      2|  }
  360|      2|
  361|      2|  NSString *bundleID = diagnosticObjects[kFIRCDBundleIDKey];
  362|      2|  if (bundleID.length) {
  363|      2|    config->bundle_id = FIREncodeString(bundleID);
  364|      2|  }
  365|      2|
  366|      2|  NSString *firebaseUserAgent = diagnosticObjects[kFIRCDFirebaseUserAgentKey];
  367|      2|  if (firebaseUserAgent.length) {
  368|      2|    config->platform_info = FIREncodeString(firebaseUserAgent);
  369|      2|  }
  370|      2|
  371|      2|  NSNumber *usingOptionsFromDefaultPlist = diagnosticObjects[kFIRCDUsingOptionsFromDefaultPlistKey];
  372|      2|  if (usingOptionsFromDefaultPlist != nil) {
  373|      2|    config->use_default_app = [usingOptionsFromDefaultPlist boolValue];
  374|      2|    config->has_use_default_app = 1;
  375|      2|  }
  376|      2|
  377|      2|  NSString *libraryVersionID = diagnosticObjects[kFIRCDLibraryVersionIDKey];
  378|      2|  if (libraryVersionID) {
  379|      2|    config->icore_version = FIREncodeString(libraryVersionID);
  380|      2|  }
  381|      2|
  382|      2|  NSString *deviceModel = [FIRCoreDiagnostics deviceModel];
  383|      2|  if (deviceModel.length) {
  384|      2|    config->device_model = FIREncodeString(deviceModel);
  385|      2|  }
  386|      2|
  387|      2|  NSString *osVersion = [GULAppEnvironmentUtil systemVersion];
  388|      2|  if (osVersion.length) {
  389|      2|    config->os_version = FIREncodeString(osVersion);
  390|      2|  }
  391|      2|
  392|      2|  config->using_zip_file = kUsingZipFile;
  393|      2|  config->has_using_zip_file = 1;
  394|      2|  config->deployment_type = kDeploymentType;
  395|      2|  config->has_deployment_type = 1;
  396|      2|  config->deployed_in_app_store = [GULAppEnvironmentUtil isFromAppStore];
  397|      2|  config->has_deployed_in_app_store = 1;
  398|      2|}
  399|       |
  400|       |/** Populates the given proto with installed services data.
  401|       | *
  402|       | * @param config The proto to populate
  403|       | */
  404|      2|void FIRPopulateProtoWithInstalledServices(logs_proto_mobilesdk_ios_ICoreConfiguration *config) {
  405|      2|  NSMutableArray<NSNumber *> *sdkServiceInstalledArray = [NSMutableArray array];
  406|      2|
  407|      2|  // AdMob
  408|      2|  if (NSClassFromString(@"GADBannerView") != nil) {
  409|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceAdMob))];
  410|      0|  }
  411|      2|  // CloudMessaging
  412|      2|  if (NSClassFromString(@"FIRMessaging") != nil) {
  413|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMessaging))];
  414|      0|  }
  415|      2|  // RemoteConfig
  416|      2|  if (NSClassFromString(@"FIRRemoteConfig") != nil) {
  417|      0|    [sdkServiceInstalledArray
  418|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceRemoteConfig))];
  419|      0|  }
  420|      2|  // Measurement/Analtyics
  421|      2|  if (NSClassFromString(@"FIRAnalytics") != nil) {
  422|      2|    [sdkServiceInstalledArray
  423|      2|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMeasurement))];
  424|      2|  }
  425|      2|  // ML Vision On Device AutoML.
  426|      2|  if (NSClassFromString(@"FIRVisionOnDeviceAutoMLImageLabelerOptions") != nil) {
  427|      0|    [sdkServiceInstalledArray
  428|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceAutoML))];
  429|      0|  }
  430|      2|  // ML Vision On Device Face.
  431|      2|  if (NSClassFromString(@"FIRVisionFaceDetector") != nil &&
  432|      2|      NSClassFromString(@"GMVFaceDetector") != nil) {
  433|      0|    [sdkServiceInstalledArray
  434|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceFace))];
  435|      0|  }
  436|      2|  // ML Vision On Device Barcode.
  437|      2|  if (NSClassFromString(@"FIRVisionBarcodeDetector") != nil &&
  438|      2|      NSClassFromString(@"GMVBarcodeDetector") != nil) {
  439|      0|    [sdkServiceInstalledArray
  440|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceBarcode))];
  441|      0|  }
  442|      2|  // ML Vision On Device Text.
  443|      2|  if (NSClassFromString(@"FIRVisionTextDetector") != nil &&
  444|      2|      NSClassFromString(@"GMVTextDetector") != nil) {
  445|      0|    [sdkServiceInstalledArray
  446|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceText))];
  447|      0|  }
  448|      2|  // ML Vision On Device Image Label.
  449|      2|  if (NSClassFromString(@"FIRVisionLabelDetector") != nil &&
  450|      2|      NSClassFromString(@"GMVLabelDetector") != nil) {
  451|      0|    [sdkServiceInstalledArray
  452|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceLabel))];
  453|      0|  }
  454|      2|  // ML Vision On Device Object.
  455|      2|  if (NSClassFromString(@"FIRVisionObjectDetector") != nil) {
  456|      0|    [sdkServiceInstalledArray
  457|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLVisionOnDeviceObjectDetection))];
  458|      0|  }
  459|      2|  // ML Model Interpreter
  460|      2|  if (NSClassFromString(@"FIRCustomModelInterpreter") != nil) {
  461|      0|    [sdkServiceInstalledArray
  462|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceMLModelInterpreter))];
  463|      0|  }
  464|      2|  // Database
  465|      2|  if (NSClassFromString(@"FIRDatabase") != nil) {
  466|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceDatabase))];
  467|      0|  }
  468|      2|  // DynamicDeepLink
  469|      2|  if (NSClassFromString(@"FIRDynamicLinks") != nil) {
  470|      0|    [sdkServiceInstalledArray
  471|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceDynamicLinks))];
  472|      0|  }
  473|      2|  // Auth
  474|      2|  if (NSClassFromString(@"FIRAuth") != nil) {
  475|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceAuth))];
  476|      0|  }
  477|      2|  // AuthUI
  478|      2|  if (NSClassFromString(@"FUIAuth") != nil) {
  479|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceAuthUI))];
  480|      0|  }
  481|      2|  // Firestore
  482|      2|  if (NSClassFromString(@"FIRFirestore") != nil) {
  483|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceFirestore))];
  484|      0|  }
  485|      2|  // Functions
  486|      2|  if (NSClassFromString(@"FIRFunctions") != nil) {
  487|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceFunctions))];
  488|      0|  }
  489|      2|  // Performance
  490|      2|  if (NSClassFromString(@"FIRPerformance") != nil) {
  491|      0|    [sdkServiceInstalledArray
  492|      0|        addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServicePerformance))];
  493|      0|  }
  494|      2|  // Storage
  495|      2|  if (NSClassFromString(@"FIRStorage") != nil) {
  496|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceStorage))];
  497|      0|  }
  498|      2|  // SignIn via Google pod
  499|      2|  if (NSClassFromString(@"GIDSignIn") != nil && NSClassFromString(@"GGLContext") != nil) {
  500|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kGGLServiceSignIn))];
  501|      0|  }
  502|      2|  // Analytics via Google pod
  503|      2|  if (NSClassFromString(@"GAI") != nil && NSClassFromString(@"GGLContext") != nil) {
  504|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kGGLServiceAnalytics))];
  505|      0|  }
  506|      2|
  507|      2|  // In-App Messaging
  508|      2|  if (NSClassFromString(@"FIRInAppMessaging") != nil) {
  509|      0|    [sdkServiceInstalledArray addObject:@(FIRMapFromServiceStringToTypeEnum(kFIRServiceIAM))];
  510|      0|  }
  511|      2|
  512|      2|  logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType *servicesInstalled =
  513|      2|      malloc(sizeof(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType) *
  514|      2|             sdkServiceInstalledArray.count);
  515|      2|  if (servicesInstalled == NULL) {
  516|      0|    return;
  517|      0|  }
  518|      4|  for (NSUInteger i = 0; i < sdkServiceInstalledArray.count; i++) {
  519|      2|    NSNumber *typeEnum = sdkServiceInstalledArray[i];
  520|      2|    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType serviceType =
  521|      2|        (int32_t)typeEnum.integerValue;
  522|      2|    servicesInstalled[i] = serviceType;
  523|      2|  }
  524|      2|
  525|      2|  config->sdk_service_installed = servicesInstalled;
  526|      2|  config->sdk_service_installed_count = (int32_t)sdkServiceInstalledArray.count;
  527|      2|}
  528|       |
  529|       |/** Populates the proto with the number of linked frameworks.
  530|       | *
  531|       | * @param config The proto to populate.
  532|       | */
  533|       |void FIRPopulateProtoWithNumberOfLinkedFrameworks(
  534|      2|    logs_proto_mobilesdk_ios_ICoreConfiguration *config) {
  535|      2|  int numFrameworks = -1;  // Subtract the app binary itself.
  536|      2|  unsigned int numImages;
  537|      2|  const char **imageNames = objc_copyImageNames(&numImages);
  538|    493|  for (unsigned int i = 0; i < numImages; i++) {
  539|    491|    NSString *imageName = [NSString stringWithUTF8String:imageNames[i]];
  540|    491|    if ([imageName rangeOfString:@"System/Library"].length != 0        // Apple .frameworks
  541|    491|        || [imageName rangeOfString:@"Developer/Library"].length != 0  // Xcode debug .frameworks
  542|    491|        || [imageName rangeOfString:@"usr/lib"].length != 0) {         // Public .dylibs
  543|    477|      continue;
  544|    477|    }
  545|     14|    numFrameworks++;
  546|     14|  }
  547|      2|  free(imageNames);
  548|      2|  config->dynamic_framework_count = numFrameworks;
  549|      2|  config->has_dynamic_framework_count = 1;
  550|      2|}
  551|       |
  552|       |/** Populates the proto with Info.plist values.
  553|       | *
  554|       | * @param config The proto to populate.
  555|       | */
  556|      2|void FIRPopulateProtoWithInfoPlistValues(logs_proto_mobilesdk_ios_ICoreConfiguration *config) {
  557|      2|  NSDictionary<NSString *, id> *info = [[NSBundle mainBundle] infoDictionary];
  558|      2|
  559|      2|  NSString *xcodeVersion = info[@"DTXcodeBuild"] ?: @"";
  560|      2|  NSString *sdkVersion = info[@"DTSDKBuild"] ?: @"";
  561|      2|  NSString *combinedVersions = [NSString stringWithFormat:@"%@-%@", xcodeVersion, sdkVersion];
  562|      2|  config->apple_framework_version = FIREncodeString(combinedVersions);
  563|      2|
  564|      2|  NSString *minVersion = info[@"MinimumOSVersion"];
  565|      2|  if (minVersion) {
  566|      2|    config->min_supported_ios_version = FIREncodeString(minVersion);
  567|      2|  }
  568|      2|
  569|      2|  // Apps can turn off swizzling in the Info.plist, check if they've explicitly set the value and
  570|      2|  // report it. It's enabled by default.
  571|      2|  NSNumber *appDelegateSwizzledNum = info[@"FirebaseAppDelegateProxyEnabled"];
  572|      2|  BOOL appDelegateSwizzled = YES;
  573|      2|  if ([appDelegateSwizzledNum isKindOfClass:[NSNumber class]]) {
  574|      0|    appDelegateSwizzled = [appDelegateSwizzledNum boolValue];
  575|      0|  }
  576|      2|  config->swizzling_enabled = appDelegateSwizzled;
  577|      2|  config->has_swizzling_enabled = 1;
  578|      2|}
  579|       |
  580|       |#pragma mark - FIRCoreDiagnosticsInterop
  581|       |
  582|      2|+ (void)sendDiagnosticsData:(nonnull id<FIRCoreDiagnosticsData>)diagnosticsData {
  583|      2|  FIRCoreDiagnostics *diagnostics = [FIRCoreDiagnostics sharedInstance];
  584|      2|  [diagnostics sendDiagnosticsData:diagnosticsData];
  585|      2|}
  586|       |
  587|      2|- (void)sendDiagnosticsData:(nonnull id<FIRCoreDiagnosticsData>)diagnosticsData {
  588|      2|  dispatch_async(self.diagnosticsQueue, ^{
  589|      2|    NSDictionary<NSString *, id> *diagnosticObjects = diagnosticsData.diagnosticObjects;
  590|      2|    NSNumber *isDataCollectionDefaultEnabled =
  591|      2|        diagnosticObjects[kFIRCDIsDataCollectionDefaultEnabledKey];
  592|      2|    if (isDataCollectionDefaultEnabled && ![isDataCollectionDefaultEnabled boolValue]) {
  593|      0|      return;
  594|      0|    }
  595|      2|
  596|      2|    // Create the proto.
  597|      2|    logs_proto_mobilesdk_ios_ICoreConfiguration icore_config =
  598|      2|        logs_proto_mobilesdk_ios_ICoreConfiguration_init_default;
  599|      2|
  600|      2|    icore_config.using_gdt = 1;
  601|      2|    icore_config.has_using_gdt = 1;
  602|      2|
  603|      2|    // Populate the proto with information.
  604|      2|    FIRPopulateProtoWithInfoFromUserInfoParams(&icore_config, diagnosticObjects);
  605|      2|    FIRPopulateProtoWithCommonInfoFromApp(&icore_config, diagnosticObjects);
  606|      2|    FIRPopulateProtoWithInstalledServices(&icore_config);
  607|      2|    FIRPopulateProtoWithNumberOfLinkedFrameworks(&icore_config);
  608|      2|    FIRPopulateProtoWithInfoPlistValues(&icore_config);
  609|      2|    [self setHeartbeatFlagIfNeededToConfig:&icore_config];
  610|      2|
  611|      2|    // This log object is capable of converting the proto to bytes.
  612|      2|    FIRCoreDiagnosticsLog *log = [[FIRCoreDiagnosticsLog alloc] initWithConfig:icore_config];
  613|      2|
  614|      2|    // Send the log as a telemetry event.
  615|      2|    GDTCOREvent *event = [self.transport eventForTransport];
  616|      2|    event.dataObject = (id<GDTCOREventDataObject>)log;
  617|      2|    [self.transport sendTelemetryEvent:event];
  618|      2|  });
  619|      2|}
  620|       |
  621|       |#pragma mark - Heartbeat
  622|       |
  623|      2|- (void)setHeartbeatFlagIfNeededToConfig:(logs_proto_mobilesdk_ios_ICoreConfiguration *)config {
  624|      2|  // Check if need to send a heartbeat.
  625|      2|  NSDate *currentDate = [NSDate date];
  626|      2|  NSDate *lastCheckin =
  627|      2|      [self.heartbeatDateStorage heartbeatDateForTag:kFIRCoreDiagnosticsHeartbeatTag];
  628|      2|  if (lastCheckin) {
  629|      2|    // Ensure the previous checkin was on a different date in the past.
  630|      2|    if ([self isDate:currentDate inSameDayOrBeforeThan:lastCheckin]) {
  631|      2|      return;
  632|      2|    }
  633|      0|  }
  634|      0|
  635|      0|  // Update heartbeat sent date.
  636|      0|  [self.heartbeatDateStorage setHearbeatDate:currentDate forTag:kFIRCoreDiagnosticsHeartbeatTag];
  637|      0|  // Set the flag.
  638|      0|  config->sdk_name = logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ICORE;
  639|      0|  config->has_sdk_name = 1;
  640|      0|}
  641|       |
  642|      2|- (BOOL)isDate:(NSDate *)date1 inSameDayOrBeforeThan:(NSDate *)date2 {
  643|      2|  return [[NSCalendar currentCalendar] isDate:date1 inSameDayAsDate:date2] ||
  644|      2|         [date1 compare:date2] == NSOrderedAscending;
  645|      2|}
  646|       |
  647|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseCoreDiagnostics/Firebase/CoreDiagnostics/FIRCDLibrary/Protogen/nanopb/firebasecore.nanopb.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |/* Automatically generated nanopb header */
   18|       |/* Generated by nanopb-0.3.9.3 */
   19|       |
   20|       |#ifndef PB_LOGS_PROTO_MOBILESDK_IOS_FIREBASECORE_NANOPB_H_INCLUDED
   21|       |#define PB_LOGS_PROTO_MOBILESDK_IOS_FIREBASECORE_NANOPB_H_INCLUDED
   22|       |#include <nanopb/pb.h>
   23|       |
   24|       |/* @@protoc_insertion_point(includes) */
   25|       |#if PB_PROTO_HEADER_VERSION != 30
   26|       |#error Regenerate this file with the current version of nanopb generator.
   27|       |#endif
   28|       |
   29|       |
   30|       |/* Enum definitions */
   31|       |typedef enum _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType {
   32|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_UNKNOWN_CONFIGURATION_TYPE = 0,
   33|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_CORE = 1,
   34|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_SDK = 2
   35|       |} logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType;
   36|      2|#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_MIN logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_UNKNOWN_CONFIGURATION_TYPE
   37|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_MAX logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_SDK
   38|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_ARRAYSIZE ((logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType)(logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_SDK+1))
   39|       |
   40|       |typedef enum _logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType {
   41|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_UNKNOWN_BUILD_TYPE = 0,
   42|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_INTERNAL = 1,
   43|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_EAP = 2,
   44|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_PROD = 3
   45|       |} logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType;
   46|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_MIN logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_UNKNOWN_BUILD_TYPE
   47|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_MAX logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_PROD
   48|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_ARRAYSIZE ((logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType)(logs_proto_mobilesdk_ios_ICoreConfiguration_BuildType_PROD+1))
   49|       |
   50|       |typedef enum _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType {
   51|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_UNKNOWN_SDK_SERVICE = 0,
   52|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ICORE = 1,
   53|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ADMOB = 2,
   54|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_APP_INVITE = 3,
   55|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_SIGN_IN = 5,
   56|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_GCM = 6,
   57|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MAPS = 7,
   58|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_SCION = 8,
   59|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ANALYTICS = 9,
   60|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_APP_INDEXING = 10,
   61|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_CONFIG = 11,
   62|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_DURABLE_DEEP_LINKS = 12,
   63|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_CRASH = 13,
   64|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_AUTH = 14,
   65|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_DATABASE = 15,
   66|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_STORAGE = 16,
   67|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MESSAGING = 17,
   68|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MEASUREMENT = 18,
   69|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_REMOTE_CONFIG = 19,
   70|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_DYNAMIC_LINKS = 20,
   71|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_INVITES = 21,
   72|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_AUTH_UI = 22,
   73|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_FIRESTORE = 23,
   74|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_PERFORMANCE = 24,
   75|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_FACE = 26,
   76|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_BARCODE = 27,
   77|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_TEXT = 28,
   78|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_LABEL = 29,
   79|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_MODEL_INTERPRETER = 30,
   80|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_IN_APP_MESSAGING = 31,
   81|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_FUNCTIONS = 32,
   82|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_NATURAL_LANGUAGE = 33,
   83|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_AUTOML = 34,
   84|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_OBJECT_DETECTION = 35
   85|       |} logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType;
   86|      2|#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MIN logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_UNKNOWN_SDK_SERVICE
   87|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MAX logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_OBJECT_DETECTION
   88|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ARRAYSIZE ((logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType)(logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_ML_VISION_ON_DEVICE_OBJECT_DETECTION+1))
   89|       |
   90|       |typedef enum _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName {
   91|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_UNKNOWN_POD_NAME = 0,
   92|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_GOOGLE = 1,
   93|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_FIREBASE = 2
   94|       |} logs_proto_mobilesdk_ios_ICoreConfiguration_PodName;
   95|      2|#define _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_MIN logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_UNKNOWN_POD_NAME
   96|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_MAX logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_FIREBASE
   97|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_ARRAYSIZE ((logs_proto_mobilesdk_ios_ICoreConfiguration_PodName)(logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_FIREBASE+1))
   98|       |
   99|       |typedef enum _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType {
  100|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_UNKNOWN = 0,
  101|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_COCOAPODS = 1,
  102|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_ZIP_FILE = 2,
  103|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_CARTHAGE = 3,
  104|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_SPM = 4
  105|       |} logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType;
  106|      2|#define _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_MIN logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_UNKNOWN
  107|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_MAX logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_SPM
  108|       |#define _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_ARRAYSIZE ((logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType)(logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_SPM+1))
  109|       |
  110|       |/* Struct definitions */
  111|       |typedef struct _logs_proto_mobilesdk_ios_ICoreConfiguration {
  112|       |    bool has_configuration_type;
  113|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType configuration_type;
  114|       |    pb_size_t sdk_service_installed_count;
  115|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType *sdk_service_installed;
  116|       |    pb_bytes_array_t *device_model;
  117|       |    pb_bytes_array_t *app_id;
  118|       |    pb_bytes_array_t *bundle_id;
  119|       |    bool has_pod_name;
  120|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_PodName pod_name;
  121|       |    pb_bytes_array_t *icore_version;
  122|       |    pb_bytes_array_t *sdk_version;
  123|       |    bool has_sdk_name;
  124|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType sdk_name;
  125|       |    bool has_app_count;
  126|       |    int32_t app_count;
  127|       |    pb_bytes_array_t *os_version;
  128|       |    pb_bytes_array_t *min_supported_ios_version;
  129|       |    bool has_use_default_app;
  130|       |    bool use_default_app;
  131|       |    bool has_deployed_in_app_store;
  132|       |    bool deployed_in_app_store;
  133|       |    bool has_dynamic_framework_count;
  134|       |    int32_t dynamic_framework_count;
  135|       |    pb_bytes_array_t *apple_framework_version;
  136|       |    bool has_using_zip_file;
  137|       |    bool using_zip_file;
  138|       |    bool has_deployment_type;
  139|       |    logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType deployment_type;
  140|       |    pb_bytes_array_t *platform_info;
  141|       |    bool has_swizzling_enabled;
  142|       |    bool swizzling_enabled;
  143|       |    bool has_using_gdt;
  144|       |    bool using_gdt;
  145|       |/* @@protoc_insertion_point(struct:logs_proto_mobilesdk_ios_ICoreConfiguration) */
  146|       |} logs_proto_mobilesdk_ios_ICoreConfiguration;
  147|       |
  148|       |/* Default values for struct fields */
  149|       |
  150|       |/* Initializer values for message structs */
  151|      2|#define logs_proto_mobilesdk_ios_ICoreConfiguration_init_default {false, _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_MIN, 0, NULL, NULL, NULL, NULL, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_MIN, NULL, NULL, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MIN, false, 0, NULL, NULL, false, 0, false, 0, false, 0, NULL, false, 0, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_MIN, NULL, false, 0, false, 0}
  152|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_init_zero {false, _logs_proto_mobilesdk_ios_ICoreConfiguration_ConfigurationType_MIN, 0, NULL, NULL, NULL, NULL, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_PodName_MIN, NULL, NULL, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_ServiceType_MIN, false, 0, NULL, NULL, false, 0, false, 0, false, 0, NULL, false, 0, false, _logs_proto_mobilesdk_ios_ICoreConfiguration_DeploymentType_MIN, NULL, false, 0, false, 0}
  153|       |
  154|       |/* Field tags (for use in manual encoding/decoding) */
  155|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_pod_name_tag 16
  156|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_configuration_type_tag 1
  157|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_icore_version_tag 18
  158|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_sdk_version_tag 19
  159|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_sdk_service_installed_tag 7
  160|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_sdk_name_tag 20
  161|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_device_model_tag 9
  162|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_os_version_tag 22
  163|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_app_id_tag 10
  164|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_bundle_id_tag 12
  165|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_min_supported_ios_version_tag 24
  166|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_use_default_app_tag 25
  167|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_app_count_tag 21
  168|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_deployed_in_app_store_tag 26
  169|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_dynamic_framework_count_tag 27
  170|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_apple_framework_version_tag 28
  171|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_using_zip_file_tag 29
  172|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_deployment_type_tag 30
  173|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_platform_info_tag 31
  174|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_swizzling_enabled_tag 33
  175|       |#define logs_proto_mobilesdk_ios_ICoreConfiguration_using_gdt_tag 36
  176|       |
  177|       |/* Struct field encoding specification for nanopb */
  178|       |extern const pb_field_t logs_proto_mobilesdk_ios_ICoreConfiguration_fields[22];
  179|       |
  180|       |/* Maximum encoded size of messages (where known) */
  181|       |/* logs_proto_mobilesdk_ios_ICoreConfiguration_size depends on runtime parameters */
  182|       |
  183|       |/* Message IDs (where set with "msgid" option) */
  184|       |#ifdef PB_MSGID
  185|       |
  186|       |#define FIREBASECORE_MESSAGES \
  187|       |
  188|       |
  189|       |#endif
  190|       |
  191|       |/* @@protoc_insertion_point(eof) */
  192|       |
  193|       |#endif

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/Errors/FIRInstallationsErrorUtil.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsErrorUtil.h"
   18|       |
   19|       |#import "FIRInstallationsHTTPError.h"
   20|       |
   21|       |NSString *const kFirebaseInstallationsErrorDomain = @"com.firebase.installations";
   22|       |
   23|      0|void FIRInstallationsItemSetErrorToPointer(NSError *error, NSError **pointer) {
   24|      0|  if (pointer != NULL) {
   25|      0|    *pointer = error;
   26|      0|  }
   27|      0|}
   28|       |
   29|       |@implementation FIRInstallationsErrorUtil
   30|       |
   31|      0|+ (NSError *)keyedArchiverErrorWithException:(NSException *)exception {
   32|      0|  NSString *failureReason = [NSString
   33|      0|      stringWithFormat:@"NSKeyedArchiver exception with name: %@, reason: %@, userInfo: %@",
   34|      0|                       exception.name, exception.reason, exception.userInfo];
   35|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   36|      0|                            failureReason:failureReason
   37|      0|                          underlyingError:nil];
   38|      0|}
   39|       |
   40|      0|+ (NSError *)keyedArchiverErrorWithError:(NSError *)error {
   41|      0|  NSString *failureReason = [NSString stringWithFormat:@"NSKeyedArchiver error."];
   42|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   43|      0|                            failureReason:failureReason
   44|      0|                          underlyingError:error];
   45|      0|}
   46|       |
   47|      0|+ (NSError *)keychainErrorWithFunction:(NSString *)keychainFunction status:(OSStatus)status {
   48|      0|  NSString *failureReason = [NSString stringWithFormat:@"%@ (%li)", keychainFunction, (long)status];
   49|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeKeychain
   50|      0|                            failureReason:failureReason
   51|      0|                          underlyingError:nil];
   52|      0|}
   53|       |
   54|      0|+ (NSError *)installationItemNotFoundForAppID:(NSString *)appID appName:(NSString *)appName {
   55|      0|  NSString *failureReason =
   56|      0|      [NSString stringWithFormat:@"Installation for appID %@ appName %@ not found", appID, appName];
   57|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   58|      0|                            failureReason:failureReason
   59|      0|                          underlyingError:nil];
   60|      0|}
   61|       |
   62|      0|+ (NSError *)corruptedIIDTokenData {
   63|      0|  NSString *failureReason =
   64|      0|      @"IID token data stored in Keychain is corrupted or in an incompatible format.";
   65|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   66|      0|                            failureReason:failureReason
   67|      0|                          underlyingError:nil];
   68|      0|}
   69|       |
   70|       |+ (FIRInstallationsHTTPError *)APIErrorWithHTTPResponse:(NSHTTPURLResponse *)HTTPResponse
   71|      0|                                                   data:(nullable NSData *)data {
   72|      0|  return [[FIRInstallationsHTTPError alloc] initWithHTTPResponse:HTTPResponse data:data];
   73|      0|}
   74|       |
   75|      0|+ (BOOL)isAPIError:(NSError *)error withHTTPCode:(NSInteger)HTTPCode {
   76|      0|  if (![error isKindOfClass:[FIRInstallationsHTTPError class]]) {
   77|      0|    return NO;
   78|      0|  }
   79|      0|
   80|      0|  return [(FIRInstallationsHTTPError *)error HTTPResponse].statusCode == HTTPCode;
   81|      0|}
   82|       |
   83|      0|+ (NSError *)JSONSerializationError:(NSError *)error {
   84|      0|  NSString *failureReason = [NSString stringWithFormat:@"Failed to serialize JSON data."];
   85|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   86|      0|                            failureReason:failureReason
   87|      0|                          underlyingError:nil];
   88|      0|}
   89|       |
   90|      0|+ (NSError *)FIDRegistrationErrorWithResponseMissingField:(NSString *)missingFieldName {
   91|      0|  NSString *failureReason = [NSString
   92|      0|      stringWithFormat:@"A required response field with name %@ is missing", missingFieldName];
   93|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
   94|      0|                            failureReason:failureReason
   95|      0|                          underlyingError:nil];
   96|      0|}
   97|       |
   98|      0|+ (NSError *)networkErrorWithError:(NSError *)error {
   99|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeServerUnreachable
  100|      0|                            failureReason:@"Network connection error."
  101|      0|                          underlyingError:error];
  102|      0|}
  103|       |
  104|      0|+ (NSError *)publicDomainErrorWithError:(NSError *)error {
  105|      0|  if ([error.domain isEqualToString:kFirebaseInstallationsErrorDomain]) {
  106|      0|    return error;
  107|      0|  }
  108|      0|
  109|      0|  return [self installationsErrorWithCode:FIRInstallationsErrorCodeUnknown
  110|      0|                            failureReason:nil
  111|      0|                          underlyingError:error];
  112|      0|}
  113|       |
  114|       |+ (NSError *)installationsErrorWithCode:(FIRInstallationsErrorCode)code
  115|       |                          failureReason:(nullable NSString *)failureReason
  116|      0|                        underlyingError:(nullable NSError *)underlyingError {
  117|      0|  NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
  118|      0|  userInfo[NSUnderlyingErrorKey] = underlyingError;
  119|      0|  userInfo[NSLocalizedFailureReasonErrorKey] = failureReason;
  120|      0|
  121|      0|  return [NSError errorWithDomain:kFirebaseInstallationsErrorDomain code:code userInfo:userInfo];
  122|      0|}
  123|       |
  124|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/Errors/FIRInstallationsHTTPError.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsHTTPError.h"
   18|       |#import "FIRInstallationsErrorUtil.h"
   19|       |
   20|       |@implementation FIRInstallationsHTTPError
   21|       |
   22|       |- (instancetype)initWithHTTPResponse:(NSHTTPURLResponse *)HTTPResponse
   23|      0|                                data:(nullable NSData *)data {
   24|      0|  NSDictionary *userInfo = [FIRInstallationsHTTPError userInfoWithHTTPResponse:HTTPResponse
   25|      0|                                                                          data:data];
   26|      0|  self = [super
   27|      0|      initWithDomain:kFirebaseInstallationsErrorDomain
   28|      0|                code:[FIRInstallationsHTTPError errorCodeWithHTTPCode:HTTPResponse.statusCode]
   29|      0|            userInfo:userInfo];
   30|      0|  if (self) {
   31|      0|    _HTTPResponse = HTTPResponse;
   32|      0|    _data = data;
   33|      0|  }
   34|      0|  return self;
   35|      0|}
   36|       |
   37|      0|+ (FIRInstallationsErrorCode)errorCodeWithHTTPCode:(NSInteger)HTTPCode {
   38|      0|  return FIRInstallationsErrorCodeUnknown;
   39|      0|}
   40|       |
   41|       |+ (NSDictionary *)userInfoWithHTTPResponse:(NSHTTPURLResponse *)HTTPResponse
   42|      0|                                      data:(nullable NSData *)data {
   43|      0|  NSString *responseString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
   44|      0|  NSString *failureReason = [NSString
   45|      0|      stringWithFormat:@"The server responded with an error. HTTP response: %@\nResponse body: %@",
   46|      0|                       HTTPResponse, responseString];
   47|      0|  return @{NSLocalizedFailureReasonErrorKey : failureReason};
   48|      0|}
   49|       |
   50|       |#pragma mark - NSCopying
   51|       |
   52|      0|- (id)copyWithZone:(NSZone *)zone {
   53|      0|  return [[FIRInstallationsHTTPError alloc] initWithHTTPResponse:self.HTTPResponse data:self.data];
   54|      0|}
   55|       |
   56|       |#pragma mark - NSSecureCoding
   57|       |
   58|      0|- (nullable instancetype)initWithCoder:(NSCoder *)coder {
   59|      0|  NSHTTPURLResponse *HTTPResponse = [coder decodeObjectOfClass:[NSHTTPURLResponse class]
   60|      0|                                                        forKey:@"HTTPResponse"];
   61|      0|  if (!HTTPResponse) {
   62|      0|    return nil;
   63|      0|  }
   64|      0|  NSData *data = [coder decodeObjectOfClass:[NSData class] forKey:@"data"];
   65|      0|
   66|      0|  return [self initWithHTTPResponse:HTTPResponse data:data];
   67|      0|}
   68|       |
   69|      0|- (void)encodeWithCoder:(NSCoder *)coder {
   70|      0|  [coder encodeObject:self.HTTPResponse forKey:@"HTTPResponse"];
   71|      0|  [coder encodeObject:self.data forKey:@"data"];
   72|      0|}
   73|       |
   74|      0|+ (BOOL)supportsSecureCoding {
   75|      0|  return YES;
   76|      0|}
   77|       |
   78|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/FIRInstallations.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallations.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import <FirebaseCore/FIRAppInternal.h>
   26|       |#import <FirebaseCore/FIRComponent.h>
   27|       |#import <FirebaseCore/FIRComponentContainer.h>
   28|       |#import <FirebaseCore/FIRLibrary.h>
   29|       |#import <FirebaseCore/FIRLogger.h>
   30|       |#import <FirebaseCore/FIROptions.h>
   31|       |
   32|       |#import "FIRInstallationsAuthTokenResultInternal.h"
   33|       |
   34|       |#import "FIRInstallationsErrorUtil.h"
   35|       |#import "FIRInstallationsIDController.h"
   36|       |#import "FIRInstallationsItem.h"
   37|       |#import "FIRInstallationsLogger.h"
   38|       |#import "FIRInstallationsStoredAuthToken.h"
   39|       |#import "FIRInstallationsVersion.h"
   40|       |
   41|       |NS_ASSUME_NONNULL_BEGIN
   42|       |
   43|       |@protocol FIRInstallationsInstanceProvider <FIRLibrary>
   44|       |@end
   45|       |
   46|       |@interface FIRInstallations () <FIRInstallationsInstanceProvider>
   47|       |@property(nonatomic, readonly) FIROptions *appOptions;
   48|       |@property(nonatomic, readonly) NSString *appName;
   49|       |
   50|       |@property(nonatomic, readonly) FIRInstallationsIDController *installationsIDController;
   51|       |
   52|       |@end
   53|       |
   54|       |@implementation FIRInstallations
   55|       |
   56|       |#pragma mark - Firebase component
   57|       |
   58|      1|+ (void)load {
   59|      1|  [FIRApp registerInternalLibrary:(Class<FIRLibrary>)self
   60|      1|                         withName:@"fire-install"
   61|      1|                      withVersion:[NSString stringWithUTF8String:FIRInstallationsVersionStr]];
   62|      1|}
   63|       |
   64|      1|+ (nonnull NSArray<FIRComponent *> *)componentsToRegister {
   65|      1|  FIRComponentCreationBlock creationBlock =
   66|      1|      ^id _Nullable(FIRComponentContainer *container, BOOL *isCacheable) {
   67|      1|    *isCacheable = YES;
   68|      1|    FIRInstallations *installations = [[FIRInstallations alloc] initWithApp:container.app];
   69|      1|    return installations;
   70|      1|  };
   71|      1|
   72|      1|  FIRComponent *installationsProvider =
   73|      1|      [FIRComponent componentWithProtocol:@protocol(FIRInstallationsInstanceProvider)
   74|      1|                      instantiationTiming:FIRInstantiationTimingAlwaysEager
   75|      1|                             dependencies:@[]
   76|      1|                            creationBlock:creationBlock];
   77|      1|  return @[ installationsProvider ];
   78|      1|}
   79|       |
   80|      1|- (instancetype)initWithApp:(FIRApp *)app {
   81|      1|  return [self initWitAppOptions:app.options appName:app.name];
   82|      1|}
   83|       |
   84|      1|- (instancetype)initWitAppOptions:(FIROptions *)appOptions appName:(NSString *)appName {
   85|      1|  FIRInstallationsIDController *IDController =
   86|      1|      [[FIRInstallationsIDController alloc] initWithGoogleAppID:appOptions.googleAppID
   87|      1|                                                        appName:appName
   88|      1|                                                         APIKey:appOptions.APIKey
   89|      1|                                                      projectID:appOptions.projectID
   90|      1|                                                    GCMSenderID:appOptions.GCMSenderID
   91|      1|                                                    accessGroup:appOptions.appGroupID];
   92|      1|  return [self initWithAppOptions:appOptions
   93|      1|                          appName:appName
   94|      1|        installationsIDController:IDController
   95|      1|                prefetchAuthToken:YES];
   96|      1|}
   97|       |
   98|       |/// The initializer is supposed to be used by tests to inject `installationsStore`.
   99|       |- (instancetype)initWithAppOptions:(FIROptions *)appOptions
  100|       |                           appName:(NSString *)appName
  101|       |         installationsIDController:(FIRInstallationsIDController *)installationsIDController
  102|      1|                 prefetchAuthToken:(BOOL)prefetchAuthToken {
  103|      1|  self = [super init];
  104|      1|  if (self) {
  105|      1|    [[self class] validateAppOptions:appOptions appName:appName];
  106|      1|    [[self class] assertCompatibleIIDVersion];
  107|      1|
  108|      1|    _appOptions = [appOptions copy];
  109|      1|    _appName = [appName copy];
  110|      1|    _installationsIDController = installationsIDController;
  111|      1|
  112|      1|    // Pre-fetch auth token.
  113|      1|    if (prefetchAuthToken) {
  114|      1|      [self authTokenWithCompletion:^(FIRInstallationsAuthTokenResult *_Nullable tokenResult,
  115|      1|                                      NSError *_Nullable error){
  116|      1|      }];
  117|      1|    }
  118|      1|  }
  119|      1|  return self;
  120|      1|}
  121|       |
  122|      1|+ (void)validateAppOptions:(FIROptions *)appOptions appName:(NSString *)appName {
  123|      1|  NSMutableArray *missingFields = [NSMutableArray array];
  124|      1|  if (appName.length < 1) {
  125|      0|    [missingFields addObject:@"`FirebaseApp.name`"];
  126|      0|  }
  127|      1|  if (appOptions.APIKey.length < 1) {
  128|      0|    [missingFields addObject:@"`FirebaseOptions.APIKey`"];
  129|      0|  }
  130|      1|  if (appOptions.googleAppID.length < 1) {
  131|      0|    [missingFields addObject:@"`FirebaseOptions.googleAppID`"];
  132|      0|  }
  133|      1|
  134|      1|  // TODO(#4692): Check for `appOptions.projectID.length < 1` only.
  135|      1|  // We can use `GCMSenderID` instead of `projectID` temporary.
  136|      1|  if (appOptions.projectID.length < 1 && appOptions.GCMSenderID.length < 1) {
  137|      0|    [missingFields addObject:@"`FirebaseOptions.projectID`"];
  138|      0|  }
  139|      1|
  140|      1|  if (missingFields.count > 0) {
  141|      0|    [NSException
  142|      0|         raise:kFirebaseInstallationsErrorDomain
  143|      0|        format:
  144|      0|            @"%@[%@] Could not configure Firebase Installations due to invalid FirebaseApp "
  145|      0|            @"options. The following parameters are nil or empty: %@. If you use "
  146|      0|            @"GoogleServices-Info.plist please download the most recent version from the Firebase "
  147|      0|            @"Console. If you configure Firebase in code, please make sure you specify all "
  148|      0|            @"required parameters.",
  149|      0|            kFIRLoggerInstallations, kFIRInstallationsMessageCodeInvalidFirebaseAppOptions,
  150|      0|            [missingFields componentsJoinedByString:@", "]];
  151|      0|  }
  152|      1|}
  153|       |
  154|       |#pragma mark - Public
  155|       |
  156|      1|+ (FIRInstallations *)installations {
  157|      1|  FIRApp *defaultApp = [FIRApp defaultApp];
  158|      1|  if (!defaultApp) {
  159|      0|    [NSException raise:kFirebaseInstallationsErrorDomain
  160|      0|                format:@"The default FirebaseApp instance must be configured before the default"
  161|      0|                       @"FirebaseApp instance can be initialized. One way to ensure that is to "
  162|      0|                       @"call `[FIRApp configure];` (`FirebaseApp.configure()` in Swift) in the App"
  163|      0|                       @" Delegate's `application:didFinishLaunchingWithOptions:` "
  164|      0|                       @"(`application(_:didFinishLaunchingWithOptions:)` in Swift)."];
  165|      0|  }
  166|      1|
  167|      1|  return [self installationsWithApp:defaultApp];
  168|      1|}
  169|       |
  170|      1|+ (FIRInstallations *)installationsWithApp:(FIRApp *)app {
  171|      1|  id<FIRInstallationsInstanceProvider> installations =
  172|      1|      FIR_COMPONENT(FIRInstallationsInstanceProvider, app.container);
  173|      1|  return (FIRInstallations *)installations;
  174|      1|}
  175|       |
  176|      1|- (void)installationIDWithCompletion:(FIRInstallationsIDHandler)completion {
  177|      1|  [self.installationsIDController getInstallationItem]
  178|      1|      .then(^id(FIRInstallationsItem *installation) {
  179|      1|        completion(installation.firebaseInstallationID, nil);
  180|      1|        return nil;
  181|      1|      })
  182|      1|      .catch(^(NSError *error) {
  183|      0|        completion(nil, [FIRInstallationsErrorUtil publicDomainErrorWithError:error]);
  184|      0|      });
  185|      1|}
  186|       |
  187|      1|- (void)authTokenWithCompletion:(FIRInstallationsTokenHandler)completion {
  188|      1|  [self authTokenForcingRefresh:NO completion:completion];
  189|      1|}
  190|       |
  191|       |- (void)authTokenForcingRefresh:(BOOL)forceRefresh
  192|      1|                     completion:(FIRInstallationsTokenHandler)completion {
  193|      1|  [self.installationsIDController getAuthTokenForcingRefresh:forceRefresh]
  194|      1|      .then(^FIRInstallationsAuthTokenResult *(FIRInstallationsItem *installation) {
  195|      1|        FIRInstallationsAuthTokenResult *result = [[FIRInstallationsAuthTokenResult alloc]
  196|      1|             initWithToken:installation.authToken.token
  197|      1|            expirationDate:installation.authToken.expirationDate];
  198|      1|        return result;
  199|      1|      })
  200|      1|      .then(^id(FIRInstallationsAuthTokenResult *token) {
  201|      1|        completion(token, nil);
  202|      1|        return nil;
  203|      1|      })
  204|      1|      .catch(^void(NSError *error) {
  205|      0|        completion(nil, [FIRInstallationsErrorUtil publicDomainErrorWithError:error]);
  206|      0|      });
  207|      1|}
  208|       |
  209|      0|- (void)deleteWithCompletion:(void (^)(NSError *__nullable error))completion {
  210|      0|  [self.installationsIDController deleteInstallation]
  211|      0|      .then(^id(id result) {
  212|      0|        completion(nil);
  213|      0|        return nil;
  214|      0|      })
  215|      0|      .catch(^void(NSError *error) {
  216|      0|        completion([FIRInstallationsErrorUtil publicDomainErrorWithError:error]);
  217|      0|      });
  218|      0|}
  219|       |
  220|       |#pragma mark - IID version compatibility
  221|       |
  222|      1|+ (void)assertCompatibleIIDVersion {
  223|      1|  // We use this flag to disable IID compatibility exception for unit tests.
  224|       |#ifdef FIR_INSTALLATIONS_ALLOWS_INCOMPATIBLE_IID_VERSION
  225|       |  return;
  226|       |#else
  227|      1|  if (![self isIIDVersionCompatible]) {
  228|      0|    [NSException raise:kFirebaseInstallationsErrorDomain
  229|      0|                format:@"FirebaseInstallations will not work correctly with current version of "
  230|      0|                       @"Firebase Instance ID. Please update your Firebase Instance ID version."];
  231|      0|  }
  232|      1|#endif
  233|      1|}
  234|       |
  235|      1|+ (BOOL)isIIDVersionCompatible {
  236|      1|  Class IIDClass = NSClassFromString(@"FIRInstanceID");
  237|      1|  if (IIDClass == nil) {
  238|      1|    // It is OK if there is no IID at all.
  239|      1|    return YES;
  240|      1|  }
  241|      0|  // We expect a compatible version having the method `+[FIRInstanceID usesFIS]` defined.
  242|      0|  BOOL isCompatibleVersion = [IIDClass respondsToSelector:NSSelectorFromString(@"usesFIS")];
  243|      0|  return isCompatibleVersion;
  244|      0|}
  245|       |
  246|       |@end
  247|       |
  248|       |NS_ASSUME_NONNULL_END

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/FIRInstallationsAuthTokenResult.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsAuthTokenResultInternal.h"
   18|       |
   19|       |@implementation FIRInstallationsAuthTokenResult
   20|       |
   21|      1|- (instancetype)initWithToken:(NSString *)token expirationDate:(NSDate *)expirationDate {
   22|      1|  self = [super init];
   23|      1|  if (self) {
   24|      1|    _authToken = [token copy];
   25|      1|    _expirationDate = expirationDate;
   26|      1|  }
   27|      1|  return self;
   28|      1|}
   29|       |
   30|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/FIRInstallationsItem.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsItem.h"
   18|       |
   19|       |#import "FIRInstallationsStoredAuthToken.h"
   20|       |#import "FIRInstallationsStoredItem.h"
   21|       |
   22|       |@implementation FIRInstallationsItem
   23|       |
   24|      1|- (instancetype)initWithAppID:(NSString *)appID firebaseAppName:(NSString *)firebaseAppName {
   25|      1|  self = [super init];
   26|      1|  if (self) {
   27|      1|    _appID = [appID copy];
   28|      1|    _firebaseAppName = [firebaseAppName copy];
   29|      1|  }
   30|      1|  return self;
   31|      1|}
   32|       |
   33|      0|- (nonnull id)copyWithZone:(nullable NSZone *)zone {
   34|      0|  FIRInstallationsItem *clone = [[FIRInstallationsItem alloc] initWithAppID:self.appID
   35|      0|                                                            firebaseAppName:self.firebaseAppName];
   36|      0|  clone.firebaseInstallationID = [self.firebaseInstallationID copy];
   37|      0|  clone.refreshToken = [self.refreshToken copy];
   38|      0|  clone.authToken = [self.authToken copy];
   39|      0|  clone.registrationStatus = self.registrationStatus;
   40|      0|
   41|      0|  return clone;
   42|      0|}
   43|       |
   44|      1|- (void)updateWithStoredItem:(FIRInstallationsStoredItem *)item {
   45|      1|  self.firebaseInstallationID = item.firebaseInstallationID;
   46|      1|  self.refreshToken = item.refreshToken;
   47|      1|  self.authToken = item.authToken;
   48|      1|  self.registrationStatus = item.registrationStatus;
   49|      1|  self.IIDDefaultToken = item.IIDDefaultToken;
   50|      1|}
   51|       |
   52|      0|- (FIRInstallationsStoredItem *)storedItem {
   53|      0|  FIRInstallationsStoredItem *storedItem = [[FIRInstallationsStoredItem alloc] init];
   54|      0|  storedItem.firebaseInstallationID = self.firebaseInstallationID;
   55|      0|  storedItem.refreshToken = self.refreshToken;
   56|      0|  storedItem.authToken = self.authToken;
   57|      0|  storedItem.registrationStatus = self.registrationStatus;
   58|      0|  storedItem.IIDDefaultToken = self.IIDDefaultToken;
   59|      0|  return storedItem;
   60|      0|}
   61|       |
   62|      0|- (nonnull NSString *)identifier {
   63|      0|  return [[self class] identifierWithAppID:self.appID appName:self.firebaseAppName];
   64|      0|}
   65|       |
   66|      2|+ (NSString *)identifierWithAppID:(NSString *)appID appName:(NSString *)appName {
   67|      2|  return [appID stringByAppendingString:appName];
   68|      2|}
   69|       |
   70|      0|+ (NSString *)generateFID {
   71|      0|  NSUUID *UUID = [NSUUID UUID];
   72|      0|  uuid_t UUIDBytes;
   73|      0|  [UUID getUUIDBytes:UUIDBytes];
   74|      0|
   75|      0|  NSUInteger UUIDLength = sizeof(uuid_t);
   76|      0|  NSData *UUIDData = [NSData dataWithBytes:UUIDBytes length:UUIDLength];
   77|      0|
   78|      0|  uint8_t UUIDLast4Bits = UUIDBytes[UUIDLength - 1] & 0b00001111;
   79|      0|
   80|      0|  // FID first 4 bits must be `0111`. The last 4 UUID bits will be cut later to form a proper FID.
   81|      0|  // To keep 16 random bytes we copy these last 4 UUID to the FID 1st byte after `0111` prefix.
   82|      0|  uint8_t FIDPrefix = 0b01110000 | UUIDLast4Bits;
   83|      0|  NSMutableData *FIDData = [NSMutableData dataWithBytes:&FIDPrefix length:1];
   84|      0|
   85|      0|  [FIDData appendData:UUIDData];
   86|      0|  NSString *FIDString = [self base64URLEncodedStringWithData:FIDData];
   87|      0|
   88|      0|  // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5 bytes.
   89|      0|  // Our generated ID has 16 bytes UUID + 1 byte prefix which after encoding with base64 will become
   90|      0|  // 23 characters plus 1 character for "=" padding.
   91|      0|
   92|      0|  // Remove the 23rd character that was added because of the extra 4 bits at the
   93|      0|  // end of our 17 byte data and the '=' padding.
   94|      0|  return [FIDString substringWithRange:NSMakeRange(0, 22)];
   95|      0|}
   96|       |
   97|      0|+ (NSString *)base64URLEncodedStringWithData:(NSData *)data {
   98|      0|  NSString *string = [data base64EncodedStringWithOptions:0];
   99|      0|  string = [string stringByReplacingOccurrencesOfString:@"/" withString:@"_"];
  100|      0|  string = [string stringByReplacingOccurrencesOfString:@"+" withString:@"-"];
  101|      0|  return string;
  102|      0|}
  103|       |
  104|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/IIDMigration/FIRInstallationsIIDStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsIIDStore.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import <CommonCrypto/CommonDigest.h>
   26|       |#import "FIRInstallationsErrorUtil.h"
   27|       |
   28|       |static NSString *const kFIRInstallationsIIDKeyPairPublicTagPrefix =
   29|       |    @"com.google.iid.keypair.public-";
   30|       |static NSString *const kFIRInstallationsIIDKeyPairPrivateTagPrefix =
   31|       |    @"com.google.iid.keypair.private-";
   32|       |static NSString *const kFIRInstallationsIIDCreationTimePlistKey = @"|S|cre";
   33|       |
   34|       |@implementation FIRInstallationsIIDStore
   35|       |
   36|      0|- (FBLPromise<NSString *> *)existingIID {
   37|      0|  return [FBLPromise onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   38|      0|                          do:^id _Nullable {
   39|      0|                            if (![self hasPlistIIDFlag]) {
   40|      0|                              return nil;
   41|      0|                            }
   42|      0|
   43|      0|                            NSData *IIDPublicKeyData = [self IIDPublicKeyData];
   44|      0|                            return [self IIDWithPublicKeyData:IIDPublicKeyData];
   45|      0|                          }]
   46|      0|      .validate(^BOOL(NSString *_Nullable IID) {
   47|      0|        return IID.length > 0;
   48|      0|      });
   49|      0|}
   50|       |
   51|      0|- (FBLPromise<NSNull *> *)deleteExistingIID {
   52|      0|  return [FBLPromise onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   53|      0|                          do:^id _Nullable {
   54|      0|                            NSError *error;
   55|      0|                            if (![self deleteIIDFlagFromPlist:&error]) {
   56|      0|                              return error;
   57|      0|                            }
   58|      0|
   59|      0|                            if (![self deleteIID:&error]) {
   60|      0|                              return error;
   61|      0|                            }
   62|      0|
   63|      0|                            return [NSNull null];
   64|      0|                          }];
   65|      0|}
   66|       |
   67|       |#pragma mark - IID decoding
   68|       |
   69|      0|- (NSString *)IIDWithPublicKeyData:(NSData *)publicKeyData {
   70|      0|  NSData *publicKeySHA1 = [self sha1WithData:publicKeyData];
   71|      0|
   72|      0|  const uint8_t *bytes = publicKeySHA1.bytes;
   73|      0|  NSMutableData *identityData = [NSMutableData dataWithData:publicKeySHA1];
   74|      0|
   75|      0|  uint8_t b0 = bytes[0];
   76|      0|  // Take the first byte and make the initial four 7 by initially making the initial 4 bits 0
   77|      0|  // and then adding 0x70 to it.
   78|      0|  b0 = 0x70 + (0xF & b0);
   79|      0|  // failsafe should give you back b0 itself
   80|      0|  b0 = (b0 & 0xFF);
   81|      0|  [identityData replaceBytesInRange:NSMakeRange(0, 1) withBytes:&b0];
   82|      0|  NSData *data = [identityData subdataWithRange:NSMakeRange(0, 8 * sizeof(Byte))];
   83|      0|  return [self base64URLEncodedStringWithData:data];
   84|      0|}
   85|       |
   86|      0|- (NSData *)sha1WithData:(NSData *)data {
   87|      0|  unsigned char output[CC_SHA1_DIGEST_LENGTH];
   88|      0|  unsigned int length = (unsigned int)[data length];
   89|      0|
   90|      0|  CC_SHA1(data.bytes, length, output);
   91|      0|  return [NSData dataWithBytes:output length:CC_SHA1_DIGEST_LENGTH];
   92|      0|}
   93|       |
   94|      0|- (NSString *)base64URLEncodedStringWithData:(NSData *)data {
   95|      0|  NSString *string = [data base64EncodedStringWithOptions:0];
   96|      0|  string = [string stringByReplacingOccurrencesOfString:@"/" withString:@"_"];
   97|      0|  string = [string stringByReplacingOccurrencesOfString:@"+" withString:@"-"];
   98|      0|  string = [string stringByReplacingOccurrencesOfString:@"=" withString:@""];
   99|      0|  return string;
  100|      0|}
  101|       |
  102|       |#pragma mark - Keychain
  103|       |
  104|      0|- (NSData *)IIDPublicKeyData {
  105|      0|  NSString *tag = [self keychainKeyTagWithPrefix:kFIRInstallationsIIDKeyPairPublicTagPrefix];
  106|      0|  NSDictionary *query = [self keyPairQueryWithTag:tag returnData:YES];
  107|      0|
  108|      0|  CFTypeRef keyRef = NULL;
  109|      0|  OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, (CFTypeRef *)&keyRef);
  110|      0|
  111|      0|  if (status != noErr) {
  112|      0|    if (keyRef) {
  113|      0|      CFRelease(keyRef);
  114|      0|    }
  115|      0|    return nil;
  116|      0|  }
  117|      0|
  118|      0|  return (__bridge NSData *)keyRef;
  119|      0|}
  120|       |
  121|      0|- (BOOL)deleteIID:(NSError **)outError {
  122|      0|  if (![self deleteKeychainKeyWithTagPrefix:kFIRInstallationsIIDKeyPairPublicTagPrefix
  123|      0|                                      error:outError]) {
  124|      0|    return NO;
  125|      0|  }
  126|      0|
  127|      0|  if (![self deleteKeychainKeyWithTagPrefix:kFIRInstallationsIIDKeyPairPrivateTagPrefix
  128|      0|                                      error:outError]) {
  129|      0|    return NO;
  130|      0|  }
  131|      0|
  132|      0|  return YES;
  133|      0|}
  134|       |
  135|      0|- (BOOL)deleteKeychainKeyWithTagPrefix:(NSString *)tagPrefix error:(NSError **)outError {
  136|      0|  NSString *keyTag = [self keychainKeyTagWithPrefix:kFIRInstallationsIIDKeyPairPublicTagPrefix];
  137|      0|  NSDictionary *keyQuery = [self keyPairQueryWithTag:keyTag returnData:NO];
  138|      0|
  139|      0|  OSStatus status = SecItemDelete((__bridge CFDictionaryRef)keyQuery);
  140|      0|
  141|      0|  // When item is not found, it should NOT be considered as an error. The operation should
  142|      0|  // continue.
  143|      0|  if (status != noErr && status != errSecItemNotFound) {
  144|      0|    FIRInstallationsItemSetErrorToPointer(
  145|      0|        [FIRInstallationsErrorUtil keychainErrorWithFunction:@"SecItemDelete" status:status],
  146|      0|        outError);
  147|      0|    return NO;
  148|      0|  }
  149|      0|
  150|      0|  return YES;
  151|      0|}
  152|       |
  153|      0|- (NSDictionary *)keyPairQueryWithTag:(NSString *)tag returnData:(BOOL)shouldReturnData {
  154|      0|  NSMutableDictionary *query = [NSMutableDictionary dictionary];
  155|      0|  NSData *tagData = [tag dataUsingEncoding:NSUTF8StringEncoding];
  156|      0|
  157|      0|  query[(__bridge id)kSecClass] = (__bridge id)kSecClassKey;
  158|      0|  query[(__bridge id)kSecAttrApplicationTag] = tagData;
  159|      0|  query[(__bridge id)kSecAttrKeyType] = (__bridge id)kSecAttrKeyTypeRSA;
  160|      0|  if (shouldReturnData) {
  161|      0|    query[(__bridge id)kSecReturnData] = @(YES);
  162|      0|  }
  163|      0|
  164|       |#if TARGET_OS_OSX
  165|       |  if (self.keychainRef) {
  166|       |    query[(__bridge NSString *)kSecMatchSearchList] = @[ (__bridge id)(self.keychainRef) ];
  167|       |  }
  168|       |#endif  // TARGET_OSX
  169|       |
  170|      0|  return query;
  171|      0|}
  172|       |
  173|      0|- (NSString *)keychainKeyTagWithPrefix:(NSString *)prefix {
  174|      0|  NSString *mainAppBundleID = [[NSBundle mainBundle] bundleIdentifier];
  175|      0|  if (mainAppBundleID.length == 0) {
  176|      0|    return nil;
  177|      0|  }
  178|      0|  return [NSString stringWithFormat:@"%@%@", prefix, mainAppBundleID];
  179|      0|}
  180|       |
  181|      0|- (NSString *)mainbundleIdentifier {
  182|      0|  NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
  183|      0|  if (!bundleIdentifier.length) {
  184|      0|    return nil;
  185|      0|  }
  186|      0|  return bundleIdentifier;
  187|      0|}
  188|       |
  189|       |#pragma mark - Plist
  190|       |
  191|      0|- (BOOL)deleteIIDFlagFromPlist:(NSError **)outError {
  192|      0|  NSString *path = [self plistPath];
  193|      0|  if (![[NSFileManager defaultManager] fileExistsAtPath:path]) {
  194|      0|    return YES;
  195|      0|  }
  196|      0|
  197|      0|  NSMutableDictionary *plistContent = [[NSMutableDictionary alloc] initWithContentsOfFile:path];
  198|      0|  plistContent[kFIRInstallationsIIDCreationTimePlistKey] = nil;
  199|      0|
  200|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  201|      0|    return [plistContent writeToURL:[NSURL fileURLWithPath:path] error:outError];
  202|      0|  }
  203|      0|
  204|      0|  return [plistContent writeToFile:path atomically:YES];
  205|      0|}
  206|       |
  207|      0|- (BOOL)hasPlistIIDFlag {
  208|      0|  NSString *path = [self plistPath];
  209|      0|  if (![[NSFileManager defaultManager] fileExistsAtPath:path]) {
  210|      0|    return NO;
  211|      0|  }
  212|      0|
  213|      0|  NSDictionary *plistContent = [[NSDictionary alloc] initWithContentsOfFile:path];
  214|      0|  return plistContent[kFIRInstallationsIIDCreationTimePlistKey] != nil;
  215|      0|}
  216|       |
  217|      0|- (NSString *)plistPath {
  218|      0|  NSString *plistNameWithExtension = @"com.google.iid-keypair.plist";
  219|      0|  NSString *_subDirectoryName = @"Google/FirebaseInstanceID";
  220|      0|
  221|      0|  NSArray *directoryPaths =
  222|      0|      NSSearchPathForDirectoriesInDomains([self supportedDirectory], NSUserDomainMask, YES);
  223|      0|  NSArray *components = @[ directoryPaths.lastObject, _subDirectoryName, plistNameWithExtension ];
  224|      0|
  225|      0|  return [NSString pathWithComponents:components];
  226|      0|}
  227|       |
  228|      0|- (NSSearchPathDirectory)supportedDirectory {
  229|       |#if TARGET_OS_TV
  230|       |  return NSCachesDirectory;
  231|       |#else
  232|       |  return NSApplicationSupportDirectory;
  233|      0|#endif
  234|      0|}
  235|       |
  236|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/IIDMigration/FIRInstallationsIIDTokenStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsIIDTokenStore.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import "FIRInstallationsErrorUtil.h"
   26|       |#import "FIRInstallationsKeychainUtils.h"
   27|       |
   28|       |static NSString *const kFIRInstallationsIIDTokenKeychainId = @"com.google.iid-tokens";
   29|       |
   30|       |@interface FIRInstallationsIIDTokenInfo : NSObject <NSSecureCoding>
   31|       |@property(nonatomic, nullable, copy) NSString *token;
   32|       |@end
   33|       |
   34|       |@implementation FIRInstallationsIIDTokenInfo
   35|       |
   36|      0|+ (BOOL)supportsSecureCoding {
   37|      0|  return YES;
   38|      0|}
   39|       |
   40|      0|- (void)encodeWithCoder:(nonnull NSCoder *)coder {
   41|      0|}
   42|       |
   43|      0|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)coder {
   44|      0|  self = [super init];
   45|      0|  if (self) {
   46|      0|    _token = [coder decodeObjectOfClass:[NSString class] forKey:@"token"];
   47|      0|  }
   48|      0|  return self;
   49|      0|}
   50|       |
   51|       |@end
   52|       |
   53|       |@interface FIRInstallationsIIDTokenStore ()
   54|       |@property(nonatomic, readonly) NSString *GCMSenderID;
   55|       |@end
   56|       |
   57|       |@implementation FIRInstallationsIIDTokenStore
   58|       |
   59|      1|- (instancetype)initWithGCMSenderID:(NSString *)GCMSenderID {
   60|      1|  self = [super init];
   61|      1|  if (self) {
   62|      1|    _GCMSenderID = GCMSenderID;
   63|      1|  }
   64|      1|  return self;
   65|      1|}
   66|       |
   67|      0|- (FBLPromise<NSString *> *)existingIIDDefaultToken {
   68|      0|  return [[FBLPromise onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   69|      0|                           do:^id _Nullable {
   70|      0|                             return [self IIDDefaultTokenData];
   71|      0|                           }] onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
   72|      0|                                 then:^id _Nullable(NSData *_Nullable keychainData) {
   73|      0|                                   return [self IIDCheckinWithData:keychainData];
   74|      0|                                 }];
   75|      0|}
   76|       |
   77|      0|- (FBLPromise<NSString *> *)IIDCheckinWithData:(NSData *)data {
   78|      0|  FBLPromise<NSString *> *resultPromise = [FBLPromise pendingPromise];
   79|      0|
   80|      0|  NSError *archiverError;
   81|      0|  NSKeyedUnarchiver *unarchiver;
   82|      0|  if (@available(iOS 11.0, tvOS 11.0, macOS 10.13, *)) {
   83|      0|    unarchiver = [[NSKeyedUnarchiver alloc] initForReadingFromData:data error:&archiverError];
   84|      0|  } else {
   85|      0|    @try {
   86|      0|#pragma clang diagnostic push
   87|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   88|      0|      unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
   89|      0|#pragma clang diagnostic pop
   90|      0|    } @catch (NSException *exception) {
   91|      0|      archiverError = [FIRInstallationsErrorUtil keyedArchiverErrorWithException:exception];
   92|      0|    }
   93|      0|  }
   94|      0|
   95|      0|  if (!unarchiver) {
   96|      0|    NSError *error = archiverError ?: [FIRInstallationsErrorUtil corruptedIIDTokenData];
   97|      0|    [resultPromise reject:error];
   98|      0|    return resultPromise;
   99|      0|  }
  100|      0|
  101|      0|  [unarchiver setClass:[FIRInstallationsIIDTokenInfo class] forClassName:@"FIRInstanceIDTokenInfo"];
  102|      0|  FIRInstallationsIIDTokenInfo *IIDTokenInfo =
  103|      0|      [unarchiver decodeObjectOfClass:[FIRInstallationsIIDTokenInfo class]
  104|      0|                               forKey:NSKeyedArchiveRootObjectKey];
  105|      0|
  106|      0|  if (IIDTokenInfo.token.length < 1) {
  107|      0|    [resultPromise reject:[FIRInstallationsErrorUtil corruptedIIDTokenData]];
  108|      0|    return resultPromise;
  109|      0|  }
  110|      0|
  111|      0|  [resultPromise fulfill:IIDTokenInfo.token];
  112|      0|
  113|      0|  return resultPromise;
  114|      0|}
  115|       |
  116|      0|- (FBLPromise<NSData *> *)IIDDefaultTokenData {
  117|      0|  FBLPromise<NSData *> *resultPromise = [FBLPromise pendingPromise];
  118|      0|
  119|      0|  NSMutableDictionary *keychainQuery = [self IIDDefaultTokenDataKeychainQuery];
  120|      0|  NSError *error;
  121|      0|  NSData *data = [FIRInstallationsKeychainUtils getItemWithQuery:keychainQuery error:&error];
  122|      0|
  123|      0|  if (data) {
  124|      0|    [resultPromise fulfill:data];
  125|      0|    return resultPromise;
  126|      0|  } else {
  127|      0|    NSError *outError = error ?: [FIRInstallationsErrorUtil corruptedIIDTokenData];
  128|      0|    [resultPromise reject:outError];
  129|      0|    return resultPromise;
  130|      0|  }
  131|      0|}
  132|       |
  133|      0|- (NSMutableDictionary *)IIDDefaultTokenDataKeychainQuery {
  134|      0|  NSDictionary *query = @{(__bridge id)kSecClass : (__bridge id)kSecClassGenericPassword};
  135|      0|
  136|      0|  NSMutableDictionary *finalQuery = [NSMutableDictionary dictionaryWithDictionary:query];
  137|      0|  finalQuery[(__bridge NSString *)kSecAttrGeneric] = kFIRInstallationsIIDTokenKeychainId;
  138|      0|
  139|      0|  NSString *account = [self IIDAppIdentifier];
  140|      0|  if ([account length]) {
  141|      0|    finalQuery[(__bridge NSString *)kSecAttrAccount] = account;
  142|      0|  }
  143|      0|
  144|      0|  finalQuery[(__bridge NSString *)kSecAttrService] =
  145|      0|      [self serviceKeyForAuthorizedEntity:self.GCMSenderID scope:@"*"];
  146|      0|  return finalQuery;
  147|      0|}
  148|       |
  149|      0|- (NSString *)IIDAppIdentifier {
  150|      0|  return [[NSBundle mainBundle] bundleIdentifier] ?: @"";
  151|      0|}
  152|       |
  153|      0|- (NSString *)serviceKeyForAuthorizedEntity:(NSString *)authorizedEntity scope:(NSString *)scope {
  154|      0|  return [NSString stringWithFormat:@"%@:%@", authorizedEntity, scope];
  155|      0|}
  156|       |
  157|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsAPI/FIRInstallationsAPIService.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsAPIService.h"
   18|       |
   19|       |#import <FirebaseInstallations/FIRInstallationsVersion.h>
   20|       |
   21|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   22|       |#import <FBLPromises/FBLPromises.h>
   23|       |#else
   24|       |#import "FBLPromises.h"
   25|       |#endif
   26|       |
   27|       |#import <FirebaseCore/FIRAppInternal.h>
   28|       |#import <FirebaseCore/FIRHeartbeatInfo.h>
   29|       |#import "FIRInstallationsErrorUtil.h"
   30|       |#import "FIRInstallationsItem+RegisterInstallationAPI.h"
   31|       |#import "FIRInstallationsLogger.h"
   32|       |
   33|       |NSString *const kFIRInstallationsAPIBaseURL = @"https://firebaseinstallations.googleapis.com";
   34|       |NSString *const kFIRInstallationsAPIKey = @"X-Goog-Api-Key";
   35|       |NSString *const kFIRInstallationsBundleId = @"X-Ios-Bundle-Identifier";
   36|       |NSString *const kFIRInstallationsIIDMigrationAuthHeader = @"x-goog-fis-ios-iid-migration-auth";
   37|       |NSString *const kFIRInstallationsHeartbeatKey = @"X-firebase-client-log-type";
   38|       |NSString *const kFIRInstallationsHeartbeatTag = @"fire-installations";
   39|       |NSString *const kFIRInstallationsUserAgentKey = @"X-firebase-client";
   40|       |
   41|       |NS_ASSUME_NONNULL_BEGIN
   42|       |
   43|       |@interface FIRInstallationsURLSessionResponse : NSObject
   44|       |@property(nonatomic) NSHTTPURLResponse *HTTPResponse;
   45|       |@property(nonatomic) NSData *data;
   46|       |
   47|       |- (instancetype)initWithResponse:(NSHTTPURLResponse *)response data:(nullable NSData *)data;
   48|       |@end
   49|       |
   50|       |@implementation FIRInstallationsURLSessionResponse
   51|       |
   52|      0|- (instancetype)initWithResponse:(NSHTTPURLResponse *)response data:(nullable NSData *)data {
   53|      0|  self = [super init];
   54|      0|  if (self) {
   55|      0|    _HTTPResponse = response;
   56|      0|    _data = data ?: [NSData data];
   57|      0|  }
   58|      0|  return self;
   59|      0|}
   60|       |
   61|       |@end
   62|       |
   63|       |@interface FIRInstallationsAPIService ()
   64|       |@property(nonatomic, readonly) NSURLSession *URLSession;
   65|       |@property(nonatomic, readonly) NSString *APIKey;
   66|       |@property(nonatomic, readonly) NSString *projectID;
   67|       |@end
   68|       |
   69|       |NS_ASSUME_NONNULL_END
   70|       |
   71|       |@implementation FIRInstallationsAPIService
   72|       |
   73|      1|- (instancetype)initWithAPIKey:(NSString *)APIKey projectID:(NSString *)projectID {
   74|      1|  NSURLSession *URLSession = [NSURLSession
   75|      1|      sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
   76|      1|  return [self initWithURLSession:URLSession APIKey:APIKey projectID:projectID];
   77|      1|}
   78|       |
   79|       |/// The initializer for tests.
   80|       |- (instancetype)initWithURLSession:(NSURLSession *)URLSession
   81|       |                            APIKey:(NSString *)APIKey
   82|      1|                         projectID:(NSString *)projectID {
   83|      1|  self = [super init];
   84|      1|  if (self) {
   85|      1|    _URLSession = URLSession;
   86|      1|    _APIKey = [APIKey copy];
   87|      1|    _projectID = [projectID copy];
   88|      1|  }
   89|      1|  return self;
   90|      1|}
   91|       |
   92|       |#pragma mark - Public
   93|       |
   94|      0|- (FBLPromise<FIRInstallationsItem *> *)registerInstallation:(FIRInstallationsItem *)installation {
   95|      0|  return [self registerRequestWithInstallation:installation]
   96|      0|      .then(^id _Nullable(NSURLRequest *_Nullable request) {
   97|      0|        return [self sendURLRequest:request];
   98|      0|      })
   99|      0|      .then(^id _Nullable(FIRInstallationsURLSessionResponse *response) {
  100|      0|        return [self registeredInstallationWithInstallation:installation serverResponse:response];
  101|      0|      });
  102|      0|}
  103|       |
  104|       |- (FBLPromise<FIRInstallationsItem *> *)refreshAuthTokenForInstallation:
  105|      0|    (FIRInstallationsItem *)installation {
  106|      0|  return [self authTokenRequestWithInstallation:installation]
  107|      0|      .then(^id _Nullable(NSURLRequest *_Nullable request) {
  108|      0|        return [self sendURLRequest:request];
  109|      0|      })
  110|      0|      .then(^FBLPromise<FIRInstallationsStoredAuthToken *> *(
  111|      0|          FIRInstallationsURLSessionResponse *response) {
  112|      0|        return [self authTokenWithServerResponse:response];
  113|      0|      })
  114|      0|      .then(^FIRInstallationsItem *(FIRInstallationsStoredAuthToken *authToken) {
  115|      0|        FIRInstallationsItem *updatedInstallation = [installation copy];
  116|      0|        updatedInstallation.authToken = authToken;
  117|      0|        return updatedInstallation;
  118|      0|      });
  119|      0|}
  120|       |
  121|      0|- (FBLPromise<FIRInstallationsItem *> *)deleteInstallation:(FIRInstallationsItem *)installation {
  122|      0|  return [self deleteInstallationRequestWithInstallation:installation]
  123|      0|      .then(^id _Nullable(NSURLRequest *_Nullable request) {
  124|      0|        return [self sendURLRequest:request];
  125|      0|      })
  126|      0|      .then(^id _Nullable(FIRInstallationsURLSessionResponse *_Nullable value) {
  127|      0|        // Return the original installation on success.
  128|      0|        return installation;
  129|      0|      });
  130|      0|}
  131|       |
  132|       |#pragma mark - Register Installation
  133|       |
  134|       |- (FBLPromise<NSURLRequest *> *)registerRequestWithInstallation:
  135|      0|    (FIRInstallationsItem *)installation {
  136|      0|  NSString *URLString = [NSString stringWithFormat:@"%@/v1/projects/%@/installations/",
  137|      0|                                                   kFIRInstallationsAPIBaseURL, self.projectID];
  138|      0|  NSURL *URL = [NSURL URLWithString:URLString];
  139|      0|
  140|      0|  NSDictionary *bodyDict = @{
  141|      0|    @"fid" : installation.firebaseInstallationID,
  142|      0|    @"authVersion" : @"FIS_v2",
  143|      0|    @"appId" : installation.appID,
  144|      0|    @"sdkVersion" : [self SDKVersion]
  145|      0|  };
  146|      0|
  147|      0|  NSDictionary *headers;
  148|      0|  if (installation.IIDDefaultToken) {
  149|      0|    headers = @{kFIRInstallationsIIDMigrationAuthHeader : installation.IIDDefaultToken};
  150|      0|  }
  151|      0|
  152|      0|  return [self requestWithURL:URL
  153|      0|                   HTTPMethod:@"POST"
  154|      0|                     bodyDict:bodyDict
  155|      0|                 refreshToken:nil
  156|      0|            additionalHeaders:headers];
  157|      0|}
  158|       |
  159|       |- (FBLPromise<FIRInstallationsItem *> *)
  160|       |    registeredInstallationWithInstallation:(FIRInstallationsItem *)installation
  161|      0|                            serverResponse:(FIRInstallationsURLSessionResponse *)response {
  162|      0|  return [FBLPromise do:^id {
  163|      0|    FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeParsingAPIResponse,
  164|      0|                @"Parsing server response for %@.", response.HTTPResponse.URL);
  165|      0|    NSError *error;
  166|      0|    FIRInstallationsItem *registeredInstallation =
  167|      0|        [installation registeredInstallationWithJSONData:response.data
  168|      0|                                                    date:[NSDate date]
  169|      0|                                                   error:&error];
  170|      0|    if (registeredInstallation == nil) {
  171|      0|      FIRLogDebug(kFIRLoggerInstallations,
  172|      0|                  kFIRInstallationsMessageCodeAPIResponseParsingInstallationFailed,
  173|      0|                  @"Failed to parse FIRInstallationsItem: %@.", error);
  174|      0|      return error;
  175|      0|    }
  176|      0|
  177|      0|    FIRLogDebug(kFIRLoggerInstallations,
  178|      0|                kFIRInstallationsMessageCodeAPIResponseParsingInstallationSucceed,
  179|      0|                @"FIRInstallationsItem parsed successfully.");
  180|      0|    return registeredInstallation;
  181|      0|  }];
  182|      0|}
  183|       |
  184|       |#pragma mark - Auth token
  185|       |
  186|       |- (FBLPromise<NSURLRequest *> *)authTokenRequestWithInstallation:
  187|      0|    (FIRInstallationsItem *)installation {
  188|      0|  NSString *URLString =
  189|      0|      [NSString stringWithFormat:@"%@/v1/projects/%@/installations/%@/authTokens:generate",
  190|      0|                                 kFIRInstallationsAPIBaseURL, self.projectID,
  191|      0|                                 installation.firebaseInstallationID];
  192|      0|  NSURL *URL = [NSURL URLWithString:URLString];
  193|      0|
  194|      0|  NSDictionary *bodyDict = @{@"installation" : @{@"sdkVersion" : [self SDKVersion]}};
  195|      0|  return [self requestWithURL:URL
  196|      0|                   HTTPMethod:@"POST"
  197|      0|                     bodyDict:bodyDict
  198|      0|                 refreshToken:installation.refreshToken];
  199|      0|}
  200|       |
  201|       |- (FBLPromise<FIRInstallationsStoredAuthToken *> *)authTokenWithServerResponse:
  202|      0|    (FIRInstallationsURLSessionResponse *)response {
  203|      0|  return [FBLPromise do:^id {
  204|      0|    FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeParsingAPIResponse,
  205|      0|                @"Parsing server response for %@.", response.HTTPResponse.URL);
  206|      0|    NSError *error;
  207|      0|    FIRInstallationsStoredAuthToken *token =
  208|      0|        [FIRInstallationsItem authTokenWithGenerateTokenAPIJSONData:response.data
  209|      0|                                                               date:[NSDate date]
  210|      0|                                                              error:&error];
  211|      0|    if (token == nil) {
  212|      0|      FIRLogDebug(kFIRLoggerInstallations,
  213|      0|                  kFIRInstallationsMessageCodeAPIResponseParsingAuthTokenFailed,
  214|      0|                  @"Failed to parse FIRInstallationsStoredAuthToken: %@.", error);
  215|      0|      return error;
  216|      0|    }
  217|      0|
  218|      0|    FIRLogDebug(kFIRLoggerInstallations,
  219|      0|                kFIRInstallationsMessageCodeAPIResponseParsingAuthTokenSucceed,
  220|      0|                @"FIRInstallationsStoredAuthToken parsed successfully.");
  221|      0|    return token;
  222|      0|  }];
  223|      0|}
  224|       |
  225|       |#pragma mark - Delete Installation
  226|       |
  227|       |- (FBLPromise<NSURLRequest *> *)deleteInstallationRequestWithInstallation:
  228|      0|    (FIRInstallationsItem *)installation {
  229|      0|  NSString *URLString = [NSString stringWithFormat:@"%@/v1/projects/%@/installations/%@/",
  230|      0|                                                   kFIRInstallationsAPIBaseURL, self.projectID,
  231|      0|                                                   installation.firebaseInstallationID];
  232|      0|  NSURL *URL = [NSURL URLWithString:URLString];
  233|      0|
  234|      0|  return [self requestWithURL:URL
  235|      0|                   HTTPMethod:@"DELETE"
  236|      0|                     bodyDict:@{}
  237|      0|                 refreshToken:installation.refreshToken];
  238|      0|}
  239|       |
  240|       |#pragma mark - URL Request
  241|       |- (FBLPromise<NSURLRequest *> *)requestWithURL:(NSURL *)requestURL
  242|       |                                    HTTPMethod:(NSString *)HTTPMethod
  243|       |                                      bodyDict:(NSDictionary *)bodyDict
  244|      0|                                  refreshToken:(nullable NSString *)refreshToken {
  245|      0|  return [self requestWithURL:requestURL
  246|      0|                   HTTPMethod:HTTPMethod
  247|      0|                     bodyDict:bodyDict
  248|      0|                 refreshToken:refreshToken
  249|      0|            additionalHeaders:nil];
  250|      0|}
  251|       |
  252|       |- (FBLPromise<NSURLRequest *> *)requestWithURL:(NSURL *)requestURL
  253|       |                                    HTTPMethod:(NSString *)HTTPMethod
  254|       |                                      bodyDict:(NSDictionary *)bodyDict
  255|       |                                  refreshToken:(nullable NSString *)refreshToken
  256|       |                             additionalHeaders:(nullable NSDictionary<NSString *, NSString *> *)
  257|      0|                                                   additionalHeaders {
  258|      0|  return [FBLPromise
  259|      0|      onQueue:dispatch_get_global_queue(QOS_CLASS_UTILITY, 0)
  260|      0|           do:^id _Nullable {
  261|      0|             __block NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:requestURL];
  262|      0|             request.HTTPMethod = HTTPMethod;
  263|      0|             NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
  264|      0|             [request addValue:self.APIKey forHTTPHeaderField:kFIRInstallationsAPIKey];
  265|      0|             [request addValue:bundleIdentifier forHTTPHeaderField:kFIRInstallationsBundleId];
  266|      0|             [self setJSONHTTPBody:bodyDict forRequest:request];
  267|      0|             if (refreshToken) {
  268|      0|               NSString *authHeader = [NSString stringWithFormat:@"FIS_v2 %@", refreshToken];
  269|      0|               [request setValue:authHeader forHTTPHeaderField:@"Authorization"];
  270|      0|             }
  271|      0|             // User agent Header.
  272|      0|             [request setValue:[FIRApp firebaseUserAgent]
  273|      0|                 forHTTPHeaderField:kFIRInstallationsUserAgentKey];
  274|      0|             // Heartbeat Header.
  275|      0|             [request setValue:@([FIRHeartbeatInfo
  276|      0|                                     heartbeatCodeForTag:kFIRInstallationsHeartbeatTag])
  277|      0|                                   .stringValue
  278|      0|                 forHTTPHeaderField:kFIRInstallationsHeartbeatKey];
  279|      0|             [additionalHeaders
  280|      0|                 enumerateKeysAndObjectsUsingBlock:^(NSString *_Nonnull key, NSString *_Nonnull obj,
  281|      0|                                                     BOOL *_Nonnull stop) {
  282|      0|                   [request setValue:obj forHTTPHeaderField:key];
  283|      0|                 }];
  284|      0|
  285|      0|             return [request copy];
  286|      0|           }];
  287|      0|}
  288|       |
  289|      0|- (FBLPromise<FIRInstallationsURLSessionResponse *> *)URLRequestPromise:(NSURLRequest *)request {
  290|      0|  return [[FBLPromise async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) {
  291|      0|    FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeSendAPIRequest,
  292|      0|                @"Sending request: %@, body:%@, headers: %@.", request,
  293|      0|                [[NSString alloc] initWithData:request.HTTPBody encoding:NSUTF8StringEncoding],
  294|      0|                request.allHTTPHeaderFields);
  295|      0|    [[self.URLSession
  296|      0|        dataTaskWithRequest:request
  297|      0|          completionHandler:^(NSData *_Nullable data, NSURLResponse *_Nullable response,
  298|      0|                              NSError *_Nullable error) {
  299|      0|            if (error) {
  300|      0|              FIRLogDebug(kFIRLoggerInstallations,
  301|      0|                          kFIRInstallationsMessageCodeAPIRequestNetworkError,
  302|      0|                          @"Request failed: %@, error: %@.", request, error);
  303|      0|              reject(error);
  304|      0|            } else {
  305|      0|              FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeAPIRequestResponse,
  306|      0|                          @"Request response received: %@, error: %@, body: %@.", request, error,
  307|      0|                          [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);
  308|      0|              fulfill([[FIRInstallationsURLSessionResponse alloc]
  309|      0|                  initWithResponse:(NSHTTPURLResponse *)response
  310|      0|                              data:data]);
  311|      0|            }
  312|      0|          }] resume];
  313|      0|  }] then:^id _Nullable(FIRInstallationsURLSessionResponse *response) {
  314|      0|    return [self validateHTTPResponseStatusCode:response];
  315|      0|  }];
  316|      0|}
  317|       |
  318|       |- (FBLPromise<FIRInstallationsURLSessionResponse *> *)validateHTTPResponseStatusCode:
  319|      0|    (FIRInstallationsURLSessionResponse *)response {
  320|      0|  NSInteger statusCode = response.HTTPResponse.statusCode;
  321|      0|  return [FBLPromise do:^id _Nullable {
  322|      0|    if (statusCode < 200 || statusCode >= 300) {
  323|      0|      FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeUnexpectedAPIRequestResponse,
  324|      0|                  @"Unexpected API response: %@, body: %@.", response.HTTPResponse,
  325|      0|                  [[NSString alloc] initWithData:response.data encoding:NSUTF8StringEncoding]);
  326|      0|      return [FIRInstallationsErrorUtil APIErrorWithHTTPResponse:response.HTTPResponse
  327|      0|                                                            data:response.data];
  328|      0|    }
  329|      0|    return response;
  330|      0|  }];
  331|      0|}
  332|       |
  333|      0|- (FBLPromise<FIRInstallationsURLSessionResponse *> *)sendURLRequest:(NSURLRequest *)request {
  334|      0|  return [FBLPromise attempts:1
  335|      0|      delay:1
  336|      0|      condition:^BOOL(NSInteger remainingAttempts, NSError *_Nonnull error) {
  337|      0|        return [FIRInstallationsErrorUtil isAPIError:error withHTTPCode:500];
  338|      0|      }
  339|      0|      retry:^id _Nullable {
  340|      0|        return [self URLRequestPromise:request];
  341|      0|      }];
  342|      0|}
  343|       |
  344|      0|- (NSString *)SDKVersion {
  345|      0|  return [NSString stringWithFormat:@"i:%s", FIRInstallationsVersionStr];
  346|      0|}
  347|       |
  348|       |#pragma mark - JSON
  349|       |
  350|       |- (void)setJSONHTTPBody:(NSDictionary<NSString *, id> *)body
  351|      0|             forRequest:(NSMutableURLRequest *)request {
  352|      0|  [request setValue:@"application/json" forHTTPHeaderField:@"Content-Type"];
  353|      0|
  354|      0|  NSError *error;
  355|      0|  NSData *JSONData = [NSJSONSerialization dataWithJSONObject:body options:0 error:&error];
  356|      0|  if (JSONData == nil) {
  357|      0|    // TODO: Log or return an error.
  358|      0|  }
  359|      0|  request.HTTPBody = JSONData;
  360|      0|}
  361|       |
  362|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsAPI/FIRInstallationsItem+RegisterInstallationAPI.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsItem+RegisterInstallationAPI.h"
   18|       |
   19|       |#import "FIRInstallationsErrorUtil.h"
   20|       |#import "FIRInstallationsStoredAuthToken.h"
   21|       |
   22|       |@implementation FIRInstallationsItem (RegisterInstallationAPI)
   23|       |
   24|       |- (nullable FIRInstallationsItem *)
   25|       |    registeredInstallationWithJSONData:(NSData *)data
   26|       |                                  date:(NSDate *)date
   27|      0|                                 error:(NSError *__autoreleasing _Nullable *_Nullable)outError {
   28|      0|  NSDictionary *responseJSON = [FIRInstallationsItem dictionaryFromJSONData:data error:outError];
   29|      0|  if (!responseJSON) {
   30|      0|    return nil;
   31|      0|  }
   32|      0|
   33|      0|  NSString *refreshToken = [FIRInstallationsItem validStringOrNilForKey:@"refreshToken"
   34|      0|                                                               fromDict:responseJSON];
   35|      0|  if (refreshToken == nil) {
   36|      0|    FIRInstallationsItemSetErrorToPointer(
   37|      0|        [FIRInstallationsErrorUtil FIDRegistrationErrorWithResponseMissingField:@"refreshToken"],
   38|      0|        outError);
   39|      0|    return nil;
   40|      0|  }
   41|      0|
   42|      0|  NSDictionary *authTokenDict = responseJSON[@"authToken"];
   43|      0|  if (![authTokenDict isKindOfClass:[NSDictionary class]]) {
   44|      0|    FIRInstallationsItemSetErrorToPointer(
   45|      0|        [FIRInstallationsErrorUtil FIDRegistrationErrorWithResponseMissingField:@"authToken"],
   46|      0|        outError);
   47|      0|    return nil;
   48|      0|  }
   49|      0|
   50|      0|  FIRInstallationsStoredAuthToken *authToken =
   51|      0|      [FIRInstallationsItem authTokenWithJSONDict:authTokenDict date:date error:outError];
   52|      0|  if (authToken == nil) {
   53|      0|    return nil;
   54|      0|  }
   55|      0|
   56|      0|  FIRInstallationsItem *installation =
   57|      0|      [[FIRInstallationsItem alloc] initWithAppID:self.appID firebaseAppName:self.firebaseAppName];
   58|      0|  NSString *installationID = [FIRInstallationsItem validStringOrNilForKey:@"fid"
   59|      0|                                                                 fromDict:responseJSON];
   60|      0|  installation.firebaseInstallationID = installationID ?: self.firebaseInstallationID;
   61|      0|  installation.refreshToken = refreshToken;
   62|      0|  installation.authToken = authToken;
   63|      0|  installation.registrationStatus = FIRInstallationStatusRegistered;
   64|      0|
   65|      0|  return installation;
   66|      0|}
   67|       |
   68|       |#pragma mark - Auth token
   69|       |
   70|       |+ (nullable FIRInstallationsStoredAuthToken *)authTokenWithGenerateTokenAPIJSONData:(NSData *)data
   71|       |                                                                               date:(NSDate *)date
   72|       |                                                                              error:(NSError **)
   73|      0|                                                                                        outError {
   74|      0|  NSDictionary *dict = [self dictionaryFromJSONData:data error:outError];
   75|      0|  if (!dict) {
   76|      0|    return nil;
   77|      0|  }
   78|      0|
   79|      0|  return [self authTokenWithJSONDict:dict date:date error:outError];
   80|      0|}
   81|       |
   82|       |+ (nullable FIRInstallationsStoredAuthToken *)authTokenWithJSONDict:
   83|       |                                                  (NSDictionary<NSString *, id> *)dict
   84|       |                                                               date:(NSDate *)date
   85|      0|                                                              error:(NSError **)outError {
   86|      0|  NSString *token = [self validStringOrNilForKey:@"token" fromDict:dict];
   87|      0|  if (token == nil) {
   88|      0|    FIRInstallationsItemSetErrorToPointer(
   89|      0|        [FIRInstallationsErrorUtil FIDRegistrationErrorWithResponseMissingField:@"authToken.token"],
   90|      0|        outError);
   91|      0|    return nil;
   92|      0|  }
   93|      0|
   94|      0|  NSString *expiresInString = [self validStringOrNilForKey:@"expiresIn" fromDict:dict];
   95|      0|  if (expiresInString == nil) {
   96|      0|    FIRInstallationsItemSetErrorToPointer(
   97|      0|        [FIRInstallationsErrorUtil
   98|      0|            FIDRegistrationErrorWithResponseMissingField:@"authToken.expiresIn"],
   99|      0|        outError);
  100|      0|    return nil;
  101|      0|  }
  102|      0|
  103|      0|  // The response should contain the string in format like "604800s".
  104|      0|  // The server should never response with anything else except seconds.
  105|      0|  // Just drop the last character and parse a number from string.
  106|      0|  NSString *expiresInSeconds = [expiresInString substringToIndex:expiresInString.length - 1];
  107|      0|  NSTimeInterval expiresIn = [expiresInSeconds doubleValue];
  108|      0|  NSDate *expirationDate = [date dateByAddingTimeInterval:expiresIn];
  109|      0|
  110|      0|  FIRInstallationsStoredAuthToken *authToken = [[FIRInstallationsStoredAuthToken alloc] init];
  111|      0|  authToken.status = FIRInstallationsAuthTokenStatusTokenReceived;
  112|      0|  authToken.token = token;
  113|      0|  authToken.expirationDate = expirationDate;
  114|      0|
  115|      0|  return authToken;
  116|      0|}
  117|       |
  118|       |#pragma mark - JSON
  119|       |
  120|       |+ (nullable NSDictionary<NSString *, id> *)dictionaryFromJSONData:(NSData *)data
  121|      0|                                                            error:(NSError **)outError {
  122|      0|  NSError *error;
  123|      0|  NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error];
  124|      0|
  125|      0|  if (![responseJSON isKindOfClass:[NSDictionary class]]) {
  126|      0|    FIRInstallationsItemSetErrorToPointer([FIRInstallationsErrorUtil JSONSerializationError:error],
  127|      0|                                          outError);
  128|      0|    return nil;
  129|      0|  }
  130|      0|
  131|      0|  return responseJSON;
  132|      0|}
  133|       |
  134|      0|+ (NSString *)validStringOrNilForKey:(NSString *)key fromDict:(NSDictionary *)dict {
  135|      0|  NSString *string = dict[key];
  136|      0|  if ([string isKindOfClass:[NSString class]] && string.length > 0) {
  137|      0|    return string;
  138|      0|  }
  139|      0|  return nil;
  140|      0|}
  141|       |
  142|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsIDController.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsIDController.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |#import <FirebaseCore/FIRAppInternal.h>
   26|       |
   27|       |#import "FIRInstallationsAPIService.h"
   28|       |#import "FIRInstallationsErrorUtil.h"
   29|       |#import "FIRInstallationsIIDStore.h"
   30|       |#import "FIRInstallationsIIDTokenStore.h"
   31|       |#import "FIRInstallationsItem.h"
   32|       |#import "FIRInstallationsLogger.h"
   33|       |#import "FIRInstallationsSingleOperationPromiseCache.h"
   34|       |#import "FIRInstallationsStore.h"
   35|       |#import "FIRSecureStorage.h"
   36|       |
   37|       |#import "FIRInstallationsHTTPError.h"
   38|       |#import "FIRInstallationsStoredAuthToken.h"
   39|       |
   40|       |const NSNotificationName FIRInstallationIDDidChangeNotification =
   41|       |    @"FIRInstallationIDDidChangeNotification";
   42|       |NSString *const kFIRInstallationIDDidChangeNotificationAppNameKey =
   43|       |    @"FIRInstallationIDDidChangeNotification";
   44|       |
   45|       |NSTimeInterval const kFIRInstallationsTokenExpirationThreshold = 60 * 60;  // 1 hour.
   46|       |
   47|       |@interface FIRInstallationsIDController ()
   48|       |@property(nonatomic, readonly) NSString *appID;
   49|       |@property(nonatomic, readonly) NSString *appName;
   50|       |
   51|       |@property(nonatomic, readonly) FIRInstallationsStore *installationsStore;
   52|       |@property(nonatomic, readonly) FIRInstallationsIIDStore *IIDStore;
   53|       |@property(nonatomic, readonly) FIRInstallationsIIDTokenStore *IIDTokenStore;
   54|       |
   55|       |@property(nonatomic, readonly) FIRInstallationsAPIService *APIService;
   56|       |
   57|       |@property(nonatomic, readonly) FIRInstallationsSingleOperationPromiseCache<FIRInstallationsItem *>
   58|       |    *getInstallationPromiseCache;
   59|       |@property(nonatomic, readonly)
   60|       |    FIRInstallationsSingleOperationPromiseCache<FIRInstallationsItem *> *authTokenPromiseCache;
   61|       |@property(nonatomic, readonly) FIRInstallationsSingleOperationPromiseCache<FIRInstallationsItem *>
   62|       |    *authTokenForcingRefreshPromiseCache;
   63|       |@property(nonatomic, readonly)
   64|       |    FIRInstallationsSingleOperationPromiseCache<NSNull *> *deleteInstallationPromiseCache;
   65|       |@end
   66|       |
   67|       |@implementation FIRInstallationsIDController
   68|       |
   69|       |- (instancetype)initWithGoogleAppID:(NSString *)appID
   70|       |                            appName:(NSString *)appName
   71|       |                             APIKey:(NSString *)APIKey
   72|       |                          projectID:(NSString *)projectID
   73|       |                        GCMSenderID:(NSString *)GCMSenderID
   74|      1|                        accessGroup:(NSString *)accessGroup {
   75|      1|  FIRSecureStorage *secureStorage = [[FIRSecureStorage alloc] init];
   76|      1|  FIRInstallationsStore *installationsStore =
   77|      1|      [[FIRInstallationsStore alloc] initWithSecureStorage:secureStorage accessGroup:accessGroup];
   78|      1|
   79|      1|  // Use `GCMSenderID` as project identifier when `projectID` is not available.
   80|      1|  NSString *APIServiceProjectID = (projectID.length > 0) ? projectID : GCMSenderID;
   81|      1|  FIRInstallationsAPIService *apiService =
   82|      1|      [[FIRInstallationsAPIService alloc] initWithAPIKey:APIKey projectID:APIServiceProjectID];
   83|      1|
   84|      1|  FIRInstallationsIIDStore *IIDStore = [[FIRInstallationsIIDStore alloc] init];
   85|      1|  FIRInstallationsIIDTokenStore *IIDCheckingStore =
   86|      1|      [[FIRInstallationsIIDTokenStore alloc] initWithGCMSenderID:GCMSenderID];
   87|      1|
   88|      1|  return [self initWithGoogleAppID:appID
   89|      1|                           appName:appName
   90|      1|                installationsStore:installationsStore
   91|      1|                        APIService:apiService
   92|      1|                          IIDStore:IIDStore
   93|      1|                     IIDTokenStore:IIDCheckingStore];
   94|      1|}
   95|       |
   96|       |/// The initializer is supposed to be used by tests to inject `installationsStore`.
   97|       |- (instancetype)initWithGoogleAppID:(NSString *)appID
   98|       |                            appName:(NSString *)appName
   99|       |                 installationsStore:(FIRInstallationsStore *)installationsStore
  100|       |                         APIService:(FIRInstallationsAPIService *)APIService
  101|       |                           IIDStore:(FIRInstallationsIIDStore *)IIDStore
  102|      1|                      IIDTokenStore:(FIRInstallationsIIDTokenStore *)IIDTokenStore {
  103|      1|  self = [super init];
  104|      1|  if (self) {
  105|      1|    _appID = appID;
  106|      1|    _appName = appName;
  107|      1|    _installationsStore = installationsStore;
  108|      1|    _APIService = APIService;
  109|      1|    _IIDStore = IIDStore;
  110|      1|    _IIDTokenStore = IIDTokenStore;
  111|      1|
  112|      1|    __weak FIRInstallationsIDController *weakSelf = self;
  113|      1|
  114|      1|    _getInstallationPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  115|      1|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  116|      1|          FIRInstallationsIDController *strongSelf = weakSelf;
  117|      1|          return [strongSelf createGetInstallationItemPromise];
  118|      1|        }];
  119|      1|
  120|      1|    _authTokenPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  121|      1|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  122|      1|          FIRInstallationsIDController *strongSelf = weakSelf;
  123|      1|          return [strongSelf installationWithValidAuthTokenForcingRefresh:NO];
  124|      1|        }];
  125|      1|
  126|      1|    _authTokenForcingRefreshPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  127|      1|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  128|      0|          FIRInstallationsIDController *strongSelf = weakSelf;
  129|      0|          return [strongSelf installationWithValidAuthTokenForcingRefresh:YES];
  130|      0|        }];
  131|      1|
  132|      1|    _deleteInstallationPromiseCache = [[FIRInstallationsSingleOperationPromiseCache alloc]
  133|      1|        initWithNewOperationHandler:^FBLPromise *_Nonnull {
  134|      0|          FIRInstallationsIDController *strongSelf = weakSelf;
  135|      0|          return [strongSelf createDeleteInstallationPromise];
  136|      0|        }];
  137|      1|  }
  138|      1|  return self;
  139|      1|}
  140|       |
  141|       |#pragma mark - Get Installation.
  142|       |
  143|      2|- (FBLPromise<FIRInstallationsItem *> *)getInstallationItem {
  144|      2|  return [self.getInstallationPromiseCache getExistingPendingOrCreateNewPromise];
  145|      2|}
  146|       |
  147|      1|- (FBLPromise<FIRInstallationsItem *> *)createGetInstallationItemPromise {
  148|      1|  FIRLogDebug(kFIRLoggerInstallations,
  149|      1|              kFIRInstallationsMessageCodeNewGetInstallationOperationCreated, @"%s, appName: %@",
  150|      1|              __PRETTY_FUNCTION__, self.appName);
  151|      1|
  152|      1|  FBLPromise<FIRInstallationsItem *> *installationItemPromise =
  153|      1|      [self getStoredInstallation].recover(^id(NSError *error) {
  154|      0|        return [self createAndSaveFID];
  155|      0|      });
  156|      1|
  157|      1|  // Initiate registration process on success if needed, but return the installation without waiting
  158|      1|  // for it.
  159|      1|  installationItemPromise.then(^id(FIRInstallationsItem *installation) {
  160|      1|    [self getAuthTokenForcingRefresh:NO];
  161|      1|    return nil;
  162|      1|  });
  163|      1|
  164|      1|  return installationItemPromise;
  165|      1|}
  166|       |
  167|      1|- (FBLPromise<FIRInstallationsItem *> *)getStoredInstallation {
  168|      1|  return [self.installationsStore installationForAppID:self.appID appName:self.appName].validate(
  169|      1|      ^BOOL(FIRInstallationsItem *installation) {
  170|      1|        BOOL isValid = NO;
  171|      1|        switch (installation.registrationStatus) {
  172|      1|          case FIRInstallationStatusUnregistered:
  173|      1|          case FIRInstallationStatusRegistered:
  174|      1|            isValid = YES;
  175|      1|            break;
  176|      1|
  177|      1|          case FIRInstallationStatusUnknown:
  178|      0|            isValid = NO;
  179|      0|            break;
  180|      1|        }
  181|      1|
  182|      1|        return isValid;
  183|      1|      });
  184|      1|}
  185|       |
  186|      0|- (FBLPromise<FIRInstallationsItem *> *)createAndSaveFID {
  187|      0|  return [self migrateOrGenerateInstallation]
  188|      0|      .then(^FBLPromise<FIRInstallationsItem *> *(FIRInstallationsItem *installation) {
  189|      0|        return [self saveInstallation:installation];
  190|      0|      })
  191|      0|      .then(^FIRInstallationsItem *(FIRInstallationsItem *installation) {
  192|      0|        [self postFIDDidChangeNotification];
  193|      0|        return installation;
  194|      0|      });
  195|      0|}
  196|       |
  197|      0|- (FBLPromise<FIRInstallationsItem *> *)saveInstallation:(FIRInstallationsItem *)installation {
  198|      0|  return [self.installationsStore saveInstallation:installation].then(
  199|      0|      ^FIRInstallationsItem *(NSNull *result) {
  200|      0|        return installation;
  201|      0|      });
  202|      0|}
  203|       |
  204|       |/**
  205|       | * Tries to migrate IID data stored by FirebaseInstanceID SDK or generates a new Installation ID if
  206|       | * not found.
  207|       | */
  208|      0|- (FBLPromise<FIRInstallationsItem *> *)migrateOrGenerateInstallation {
  209|      0|  if (![self isDefaultApp]) {
  210|      0|    // Existing IID should be used only for default FirebaseApp.
  211|      0|    FIRInstallationsItem *installation =
  212|      0|        [self createInstallationWithFID:[FIRInstallationsItem generateFID] IIDDefaultToken:nil];
  213|      0|    return [FBLPromise resolvedWith:installation];
  214|      0|  }
  215|      0|
  216|      0|  return [[[FBLPromise
  217|      0|      all:@[ [self.IIDStore existingIID], [self.IIDTokenStore existingIIDDefaultToken] ]]
  218|      0|      then:^id _Nullable(NSArray *_Nullable results) {
  219|      0|        NSString *existingIID = results[0];
  220|      0|        NSString *IIDDefaultToken = results[1];
  221|      0|
  222|      0|        return [self createInstallationWithFID:existingIID IIDDefaultToken:IIDDefaultToken];
  223|      0|      }] recover:^id _Nullable(NSError *_Nonnull error) {
  224|      0|    return [self createInstallationWithFID:[FIRInstallationsItem generateFID] IIDDefaultToken:nil];
  225|      0|  }];
  226|      0|}
  227|       |
  228|       |- (FIRInstallationsItem *)createInstallationWithFID:(NSString *)FID
  229|      0|                                    IIDDefaultToken:(nullable NSString *)IIDDefaultToken {
  230|      0|  FIRInstallationsItem *installation = [[FIRInstallationsItem alloc] initWithAppID:self.appID
  231|      0|                                                                   firebaseAppName:self.appName];
  232|      0|  installation.firebaseInstallationID = FID;
  233|      0|  installation.IIDDefaultToken = IIDDefaultToken;
  234|      0|  installation.registrationStatus = FIRInstallationStatusUnregistered;
  235|      0|  return installation;
  236|      0|}
  237|       |
  238|       |#pragma mark - FID registration
  239|       |
  240|       |- (FBLPromise<FIRInstallationsItem *> *)registerInstallationIfNeeded:
  241|      1|    (FIRInstallationsItem *)installation {
  242|      1|  switch (installation.registrationStatus) {
  243|      1|    case FIRInstallationStatusRegistered:
  244|      1|      // Already registered. Do nothing.
  245|      1|      return [FBLPromise resolvedWith:installation];
  246|      1|
  247|      1|    case FIRInstallationStatusUnknown:
  248|      0|    case FIRInstallationStatusUnregistered:
  249|      0|      // Registration required. Proceed.
  250|      0|      break;
  251|      0|  }
  252|      0|
  253|      0|  return [self.APIService registerInstallation:installation]
  254|      0|      .catch(^(NSError *_Nonnull error) {
  255|      0|        if ([self doesRegistrationErrorRequireConfigChange:error]) {
  256|      0|          FIRLogError(kFIRLoggerInstallations,
  257|      0|                      kFIRInstallationsMessageCodeInvalidFirebaseConfiguration,
  258|      0|                      @"Firebase Installation registration failed for app with name: %@, error: "
  259|      0|                      @"%@\nPlease make sure you use valid GoogleService-Info.plist",
  260|      0|                      self.appName, error);
  261|      0|        }
  262|      0|      })
  263|      0|      .then(^id(FIRInstallationsItem *registeredInstallation) {
  264|      0|        return [self saveInstallation:registeredInstallation];
  265|      0|      })
  266|      0|      .then(^FIRInstallationsItem *(FIRInstallationsItem *registeredInstallation) {
  267|      0|        // Server may respond with a different FID if the sent one cannot be accepted.
  268|      0|        if (![registeredInstallation.firebaseInstallationID
  269|      0|                isEqualToString:installation.firebaseInstallationID]) {
  270|      0|          [self postFIDDidChangeNotification];
  271|      0|        }
  272|      0|        return registeredInstallation;
  273|      0|      });
  274|      0|}
  275|       |
  276|      0|- (BOOL)doesRegistrationErrorRequireConfigChange:(NSError *)error {
  277|      0|  FIRInstallationsHTTPError *HTTPError = (FIRInstallationsHTTPError *)error;
  278|      0|  if (![HTTPError isKindOfClass:[FIRInstallationsHTTPError class]]) {
  279|      0|    return NO;
  280|      0|  }
  281|      0|
  282|      0|  switch (HTTPError.HTTPResponse.statusCode) {
  283|      0|    // These are the errors that require Firebase configuration change.
  284|      0|    case FIRInstallationsRegistrationHTTPCodeInvalidArgument:
  285|      0|    case FIRInstallationsRegistrationHTTPCodeInvalidAPIKey:
  286|      0|    case FIRInstallationsRegistrationHTTPCodeAPIKeyToProjectIDMismatch:
  287|      0|    case FIRInstallationsRegistrationHTTPCodeProjectNotFound:
  288|      0|      return YES;
  289|      0|
  290|      0|    default:
  291|      0|      return NO;
  292|      0|  }
  293|      0|}
  294|       |
  295|       |#pragma mark - Auth Token
  296|       |
  297|      2|- (FBLPromise<FIRInstallationsItem *> *)getAuthTokenForcingRefresh:(BOOL)forceRefresh {
  298|      2|  if (forceRefresh || [self.authTokenForcingRefreshPromiseCache getExistingPendingPromise] != nil) {
  299|      0|    return [self.authTokenForcingRefreshPromiseCache getExistingPendingOrCreateNewPromise];
  300|      2|  } else {
  301|      2|    return [self.authTokenPromiseCache getExistingPendingOrCreateNewPromise];
  302|      2|  }
  303|      2|}
  304|       |
  305|       |- (FBLPromise<FIRInstallationsItem *> *)installationWithValidAuthTokenForcingRefresh:
  306|      1|    (BOOL)forceRefresh {
  307|      1|  FIRLogDebug(kFIRLoggerInstallations, kFIRInstallationsMessageCodeNewGetAuthTokenOperationCreated,
  308|      1|              @"-[FIRInstallationsIDController installationWithValidAuthTokenForcingRefresh:%@], "
  309|      1|              @"appName: %@",
  310|      1|              @(forceRefresh), self.appName);
  311|      1|
  312|      1|  return [self getInstallationItem]
  313|      1|      .then(^FBLPromise<FIRInstallationsItem *> *(FIRInstallationsItem *installation) {
  314|      1|        return [self registerInstallationIfNeeded:installation];
  315|      1|      })
  316|      1|      .then(^id(FIRInstallationsItem *registeredInstallation) {
  317|      1|        BOOL isTokenExpiredOrExpiresSoon =
  318|      1|            [registeredInstallation.authToken.expirationDate timeIntervalSinceDate:[NSDate date]] <
  319|      1|            kFIRInstallationsTokenExpirationThreshold;
  320|      1|        if (forceRefresh || isTokenExpiredOrExpiresSoon) {
  321|      0|          return [self refreshAuthTokenForInstallation:registeredInstallation];
  322|      1|        } else {
  323|      1|          return registeredInstallation;
  324|      1|        }
  325|      1|      })
  326|      1|      .recover(^id(NSError *error) {
  327|      0|        return [self regenerateFIDOnRefreshTokenErrorIfNeeded:error];
  328|      0|      });
  329|      1|}
  330|       |
  331|       |- (FBLPromise<FIRInstallationsItem *> *)refreshAuthTokenForInstallation:
  332|      0|    (FIRInstallationsItem *)installation {
  333|      0|  return [[self.APIService refreshAuthTokenForInstallation:installation]
  334|      0|      then:^id _Nullable(FIRInstallationsItem *_Nullable refreshedInstallation) {
  335|      0|        return [self saveInstallation:refreshedInstallation];
  336|      0|      }];
  337|      0|}
  338|       |
  339|      0|- (id)regenerateFIDOnRefreshTokenErrorIfNeeded:(NSError *)error {
  340|      0|  if (![error isKindOfClass:[FIRInstallationsHTTPError class]]) {
  341|      0|    // No recovery possible. Return the same error.
  342|      0|    return error;
  343|      0|  }
  344|      0|
  345|      0|  FIRInstallationsHTTPError *HTTPError = (FIRInstallationsHTTPError *)error;
  346|      0|  switch (HTTPError.HTTPResponse.statusCode) {
  347|      0|    case FIRInstallationsAuthTokenHTTPCodeInvalidAuthentication:
  348|      0|    case FIRInstallationsAuthTokenHTTPCodeFIDNotFound:
  349|      0|      // The stored installation was damaged or blocked by the server.
  350|      0|      // Delete the stored installation then generate and register a new one.
  351|      0|      return [self getInstallationItem]
  352|      0|          .then(^FBLPromise<NSNull *> *(FIRInstallationsItem *installation) {
  353|      0|            return [self deleteInstallationLocally:installation];
  354|      0|          })
  355|      0|          .then(^FBLPromise<FIRInstallationsItem *> *(id result) {
  356|      0|            return [self installationWithValidAuthTokenForcingRefresh:NO];
  357|      0|          });
  358|      0|
  359|      0|    default:
  360|      0|      // No recovery possible. Return the same error.
  361|      0|      return error;
  362|      0|  }
  363|      0|}
  364|       |
  365|       |#pragma mark - Delete FID
  366|       |
  367|      0|- (FBLPromise<NSNull *> *)deleteInstallation {
  368|      0|  return [self.deleteInstallationPromiseCache getExistingPendingOrCreateNewPromise];
  369|      0|}
  370|       |
  371|      0|- (FBLPromise<NSNull *> *)createDeleteInstallationPromise {
  372|      0|  FIRLogDebug(kFIRLoggerInstallations,
  373|      0|              kFIRInstallationsMessageCodeNewDeleteInstallationOperationCreated, @"%s, appName: %@",
  374|      0|              __PRETTY_FUNCTION__, self.appName);
  375|      0|
  376|      0|  // Check for ongoing requests first, if there is no a request, then check local storage for
  377|      0|  // existing installation.
  378|      0|  FBLPromise<FIRInstallationsItem *> *currentInstallationPromise =
  379|      0|      [self mostRecentInstallationOperation] ?: [self getStoredInstallation];
  380|      0|
  381|      0|  return currentInstallationPromise
  382|      0|      .then(^id(FIRInstallationsItem *installation) {
  383|      0|        return [self sendDeleteInstallationRequestIfNeeded:installation];
  384|      0|      })
  385|      0|      .then(^id(FIRInstallationsItem *installation) {
  386|      0|        // Remove the installation from the local storage.
  387|      0|        return [self deleteInstallationLocally:installation];
  388|      0|      });
  389|      0|}
  390|       |
  391|      0|- (FBLPromise<NSNull *> *)deleteInstallationLocally:(FIRInstallationsItem *)installation {
  392|      0|  return [self.installationsStore removeInstallationForAppID:installation.appID
  393|      0|                                                     appName:installation.firebaseAppName]
  394|      0|      .then(^FBLPromise<NSNull *> *(NSNull *result) {
  395|      0|        return [self deleteExistingIIDIfNeeded];
  396|      0|      })
  397|      0|      .then(^NSNull *(NSNull *result) {
  398|      0|        [self postFIDDidChangeNotification];
  399|      0|        return result;
  400|      0|      });
  401|      0|}
  402|       |
  403|       |- (FBLPromise<FIRInstallationsItem *> *)sendDeleteInstallationRequestIfNeeded:
  404|      0|    (FIRInstallationsItem *)installation {
  405|      0|  switch (installation.registrationStatus) {
  406|      0|    case FIRInstallationStatusUnknown:
  407|      0|    case FIRInstallationStatusUnregistered:
  408|      0|      // The installation is not registered, so it is safe to be deleted as is, so return early.
  409|      0|      return [FBLPromise resolvedWith:installation];
  410|      0|      break;
  411|      0|
  412|      0|    case FIRInstallationStatusRegistered:
  413|      0|      // Proceed to de-register the installation on the server.
  414|      0|      break;
  415|      0|  }
  416|      0|
  417|      0|  return [self.APIService deleteInstallation:installation].recover(^id(NSError *APIError) {
  418|      0|    if ([FIRInstallationsErrorUtil isAPIError:APIError withHTTPCode:404]) {
  419|      0|      // The installation was not found on the server.
  420|      0|      // Return success.
  421|      0|      return installation;
  422|      0|    } else {
  423|      0|      // Re-throw the error otherwise.
  424|      0|      return APIError;
  425|      0|    }
  426|      0|  });
  427|      0|}
  428|       |
  429|      0|- (FBLPromise<NSNull *> *)deleteExistingIIDIfNeeded {
  430|      0|  if ([self isDefaultApp]) {
  431|      0|    return [self.IIDStore deleteExistingIID];
  432|      0|  } else {
  433|      0|    return [FBLPromise resolvedWith:[NSNull null]];
  434|      0|  }
  435|      0|}
  436|       |
  437|      0|- (nullable FBLPromise<FIRInstallationsItem *> *)mostRecentInstallationOperation {
  438|      0|  return [self.authTokenForcingRefreshPromiseCache getExistingPendingPromise]
  439|      0|             ?: [self.authTokenPromiseCache getExistingPendingPromise]
  440|      0|                    ?: [self.getInstallationPromiseCache getExistingPendingPromise];
  441|      0|}
  442|       |
  443|       |#pragma mark - Notifications
  444|       |
  445|      0|- (void)postFIDDidChangeNotification {
  446|      0|  [[NSNotificationCenter defaultCenter]
  447|      0|      postNotificationName:FIRInstallationIDDidChangeNotification
  448|      0|                    object:nil
  449|      0|                  userInfo:@{kFIRInstallationIDDidChangeNotificationAppNameKey : self.appName}];
  450|      0|}
  451|       |
  452|       |#pragma mark - Default App
  453|       |
  454|      0|- (BOOL)isDefaultApp {
  455|      0|  return [self.appName isEqualToString:kFIRDefaultAppName];
  456|      0|}
  457|       |
  458|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsIDController/FIRInstallationsSingleOperationPromiseCache.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsSingleOperationPromiseCache.h"
   18|       |
   19|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   20|       |#import <FBLPromises/FBLPromises.h>
   21|       |#else
   22|       |#import "FBLPromises.h"
   23|       |#endif
   24|       |
   25|       |@interface FIRInstallationsSingleOperationPromiseCache <ResultType>()
   26|       |@property(nonatomic, readonly) FBLPromise *_Nonnull (^newOperationHandler)(void);
   27|       |@property(nonatomic, nullable) FBLPromise *pendingPromise;
   28|       |@end
   29|       |
   30|       |@implementation FIRInstallationsSingleOperationPromiseCache
   31|       |
   32|       |- (instancetype)initWithNewOperationHandler:
   33|      4|    (FBLPromise<id> *_Nonnull (^)(void))newOperationHandler {
   34|      4|  if (newOperationHandler == nil) {
   35|      0|    [NSException raise:NSInvalidArgumentException
   36|      0|                format:@"`newOperationHandler` must not be `nil`."];
   37|      0|  }
   38|      4|
   39|      4|  self = [super init];
   40|      4|  if (self) {
   41|      4|    _newOperationHandler = [newOperationHandler copy];
   42|      4|  }
   43|      4|  return self;
   44|      4|}
   45|       |
   46|      4|- (FBLPromise *)getExistingPendingOrCreateNewPromise {
   47|      4|  @synchronized(self) {
   48|      4|    if (!self.pendingPromise) {
   49|      2|      self.pendingPromise = self.newOperationHandler();
   50|      2|
   51|      2|      self.pendingPromise
   52|      2|          .then(^id(id result) {
   53|      2|            @synchronized(self) {
   54|      2|              self.pendingPromise = nil;
   55|      2|              return nil;
   56|      2|            }
   57|      2|          })
   58|      2|          .catch(^void(NSError *error) {
   59|      0|            @synchronized(self) {
   60|      0|              self.pendingPromise = nil;
   61|      0|            }
   62|      0|          });
   63|      2|    }
   64|      4|
   65|      4|    return self.pendingPromise;
   66|      4|  }
   67|      4|}
   68|       |
   69|      2|- (nullable FBLPromise *)getExistingPendingPromise {
   70|      2|  @synchronized(self) {
   71|      2|    return self.pendingPromise;
   72|      2|  }
   73|      2|}
   74|       |
   75|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStore.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsStore.h"
   18|       |
   19|       |#import <GoogleUtilities/GULUserDefaults.h>
   20|       |
   21|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   22|       |#import <FBLPromises/FBLPromises.h>
   23|       |#else
   24|       |#import "FBLPromises.h"
   25|       |#endif
   26|       |
   27|       |#import "FIRInstallationsErrorUtil.h"
   28|       |#import "FIRInstallationsItem.h"
   29|       |#import "FIRInstallationsStoredItem.h"
   30|       |#import "FIRSecureStorage.h"
   31|       |
   32|       |NSString *const kFIRInstallationsStoreUserDefaultsID = @"com.firebase.FIRInstallations";
   33|       |
   34|       |@interface FIRInstallationsStore ()
   35|       |@property(nonatomic, readonly) FIRSecureStorage *secureStorage;
   36|       |@property(nonatomic, readonly, nullable) NSString *accessGroup;
   37|       |@property(nonatomic, readonly) dispatch_queue_t queue;
   38|       |@property(nonatomic, readonly) GULUserDefaults *userDefaults;
   39|       |@end
   40|       |
   41|       |@implementation FIRInstallationsStore
   42|       |
   43|       |- (instancetype)initWithSecureStorage:(FIRSecureStorage *)storage
   44|      1|                          accessGroup:(NSString *)accessGroup {
   45|      1|  self = [super init];
   46|      1|  if (self) {
   47|      1|    _secureStorage = storage;
   48|      1|    _accessGroup = [accessGroup copy];
   49|      1|    _queue = dispatch_queue_create("com.firebase.FIRInstallationsStore", DISPATCH_QUEUE_SERIAL);
   50|      1|
   51|      1|    NSString *userDefaultsSuiteName = _accessGroup ?: kFIRInstallationsStoreUserDefaultsID;
   52|      1|    _userDefaults = [[GULUserDefaults alloc] initWithSuiteName:userDefaultsSuiteName];
   53|      1|  }
   54|      1|  return self;
   55|      1|}
   56|       |
   57|       |- (FBLPromise<FIRInstallationsItem *> *)installationForAppID:(NSString *)appID
   58|      1|                                                     appName:(NSString *)appName {
   59|      1|  NSString *itemID = [FIRInstallationsItem identifierWithAppID:appID appName:appName];
   60|      1|  return [self installationExistsForAppID:appID appName:appName]
   61|      1|      .then(^id(id result) {
   62|      1|        return [self.secureStorage getObjectForKey:itemID
   63|      1|                                       objectClass:[FIRInstallationsStoredItem class]
   64|      1|                                       accessGroup:self.accessGroup];
   65|      1|      })
   66|      1|      .then(^id(FIRInstallationsStoredItem *_Nullable storedItem) {
   67|      1|        if (storedItem == nil) {
   68|      0|          return [FIRInstallationsErrorUtil installationItemNotFoundForAppID:appID appName:appName];
   69|      0|        }
   70|      1|
   71|      1|        FIRInstallationsItem *item = [[FIRInstallationsItem alloc] initWithAppID:appID
   72|      1|                                                                 firebaseAppName:appName];
   73|      1|        [item updateWithStoredItem:storedItem];
   74|      1|        return item;
   75|      1|      });
   76|      1|}
   77|       |
   78|      0|- (FBLPromise<NSNull *> *)saveInstallation:(FIRInstallationsItem *)installationItem {
   79|      0|  FIRInstallationsStoredItem *storedItem = [installationItem storedItem];
   80|      0|  NSString *identifier = [installationItem identifier];
   81|      0|
   82|      0|  return
   83|      0|      [self.secureStorage setObject:storedItem forKey:identifier accessGroup:self.accessGroup].then(
   84|      0|          ^id(id result) {
   85|      0|            return [self setInstallationExists:YES forItemWithIdentifier:identifier];
   86|      0|          });
   87|      0|}
   88|       |
   89|      0|- (FBLPromise<NSNull *> *)removeInstallationForAppID:(NSString *)appID appName:(NSString *)appName {
   90|      0|  NSString *identifier = [FIRInstallationsItem identifierWithAppID:appID appName:appName];
   91|      0|  return [self.secureStorage removeObjectForKey:identifier accessGroup:self.accessGroup].then(
   92|      0|      ^id(id result) {
   93|      0|        return [self setInstallationExists:NO forItemWithIdentifier:identifier];
   94|      0|      });
   95|      0|}
   96|       |
   97|       |#pragma mark - User defaults
   98|       |
   99|      1|- (FBLPromise<NSNull *> *)installationExistsForAppID:(NSString *)appID appName:(NSString *)appName {
  100|      1|  NSString *identifier = [FIRInstallationsItem identifierWithAppID:appID appName:appName];
  101|      1|  return [FBLPromise onQueue:self.queue
  102|      1|                          do:^id _Nullable {
  103|      1|                            return [[self userDefaults] objectForKey:identifier] != nil
  104|      1|                                       ? [NSNull null]
  105|      1|                                       : [FIRInstallationsErrorUtil
  106|      0|                                             installationItemNotFoundForAppID:appID
  107|      0|                                                                      appName:appName];
  108|      1|                          }];
  109|      1|}
  110|       |
  111|       |- (FBLPromise<NSNull *> *)setInstallationExists:(BOOL)exists
  112|      0|                          forItemWithIdentifier:(NSString *)identifier {
  113|      0|  return [FBLPromise onQueue:self.queue
  114|      0|                          do:^id _Nullable {
  115|      0|                            if (exists) {
  116|      0|                              [[self userDefaults] setBool:YES forKey:identifier];
  117|      0|                            } else {
  118|      0|                              [[self userDefaults] removeObjectForKey:identifier];
  119|      0|                            }
  120|      0|
  121|      0|                            return [NSNull null];
  122|      0|                          }];
  123|      0|}
  124|       |
  125|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredAuthToken.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsStoredAuthToken.h"
   18|       |
   19|       |#import "FIRInstallationsLogger.h"
   20|       |
   21|       |NSString *const kFIRInstallationsStoredAuthTokenStatusKey = @"status";
   22|       |NSString *const kFIRInstallationsStoredAuthTokenTokenKey = @"token";
   23|       |NSString *const kFIRInstallationsStoredAuthTokenExpirationDateKey = @"expirationDate";
   24|       |NSString *const kFIRInstallationsStoredAuthTokenStorageVersionKey = @"storageVersion";
   25|       |
   26|       |NSInteger const kFIRInstallationsStoredAuthTokenStorageVersion = 1;
   27|       |
   28|       |@implementation FIRInstallationsStoredAuthToken
   29|       |
   30|      0|- (NSInteger)storageVersion {
   31|      0|  return kFIRInstallationsStoredAuthTokenStorageVersion;
   32|      0|}
   33|       |
   34|      0|- (nonnull id)copyWithZone:(nullable NSZone *)zone {
   35|      0|  FIRInstallationsStoredAuthToken *clone = [[FIRInstallationsStoredAuthToken alloc] init];
   36|      0|  clone.status = self.status;
   37|      0|  clone.token = [self.token copy];
   38|      0|  clone.expirationDate = self.expirationDate;
   39|      0|  return clone;
   40|      0|}
   41|       |
   42|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
   43|      0|  [aCoder encodeInteger:self.status forKey:kFIRInstallationsStoredAuthTokenStatusKey];
   44|      0|  [aCoder encodeObject:self.token forKey:kFIRInstallationsStoredAuthTokenTokenKey];
   45|      0|  [aCoder encodeObject:self.expirationDate
   46|      0|                forKey:kFIRInstallationsStoredAuthTokenExpirationDateKey];
   47|      0|  [aCoder encodeInteger:self.storageVersion
   48|      0|                 forKey:kFIRInstallationsStoredAuthTokenStorageVersionKey];
   49|      0|}
   50|       |
   51|      1|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
   52|      1|  NSInteger storageVersion =
   53|      1|      [aDecoder decodeIntegerForKey:kFIRInstallationsStoredAuthTokenStorageVersionKey];
   54|      1|  if (storageVersion > kFIRInstallationsStoredAuthTokenStorageVersion) {
   55|      0|    FIRLogWarning(kFIRLoggerInstallations,
   56|      0|                  kFIRInstallationsMessageCodeAuthTokenCoderVersionMismatch,
   57|      0|                  @"FIRInstallationsStoredAuthToken was encoded by a newer coder version %ld. "
   58|      0|                  @"Current coder version is %ld. Some auth token data may be lost.",
   59|      0|                  (long)storageVersion, (long)kFIRInstallationsStoredAuthTokenStorageVersion);
   60|      0|  }
   61|      1|
   62|      1|  FIRInstallationsStoredAuthToken *object = [[FIRInstallationsStoredAuthToken alloc] init];
   63|      1|  object.status = [aDecoder decodeIntegerForKey:kFIRInstallationsStoredAuthTokenStatusKey];
   64|      1|  object.token = [aDecoder decodeObjectOfClass:[NSString class]
   65|      1|                                        forKey:kFIRInstallationsStoredAuthTokenTokenKey];
   66|      1|  object.expirationDate =
   67|      1|      [aDecoder decodeObjectOfClass:[NSDate class]
   68|      1|                             forKey:kFIRInstallationsStoredAuthTokenExpirationDateKey];
   69|      1|
   70|      1|  return object;
   71|      1|}
   72|       |
   73|      1|+ (BOOL)supportsSecureCoding {
   74|      1|  return YES;
   75|      1|}
   76|       |
   77|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/InstallationsStore/FIRInstallationsStoredItem.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsStoredItem.h"
   18|       |
   19|       |#import "FIRInstallationsLogger.h"
   20|       |#import "FIRInstallationsStoredAuthToken.h"
   21|       |
   22|       |NSString *const kFIRInstallationsStoredItemFirebaseInstallationIDKey = @"firebaseInstallationID";
   23|       |NSString *const kFIRInstallationsStoredItemRefreshTokenKey = @"refreshToken";
   24|       |NSString *const kFIRInstallationsStoredItemAuthTokenKey = @"authToken";
   25|       |NSString *const kFIRInstallationsStoredItemRegistrationStatusKey = @"registrationStatus";
   26|       |NSString *const kFIRInstallationsStoredItemIIDDefaultTokenKey = @"IIDDefaultToken";
   27|       |NSString *const kFIRInstallationsStoredItemStorageVersionKey = @"storageVersion";
   28|       |
   29|       |NSInteger const kFIRInstallationsStoredItemStorageVersion = 1;
   30|       |
   31|       |@implementation FIRInstallationsStoredItem
   32|       |
   33|      1|- (NSInteger)storageVersion {
   34|      1|  return kFIRInstallationsStoredItemStorageVersion;
   35|      1|}
   36|       |
   37|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
   38|      0|  [aCoder encodeObject:self.firebaseInstallationID
   39|      0|                forKey:kFIRInstallationsStoredItemFirebaseInstallationIDKey];
   40|      0|  [aCoder encodeObject:self.refreshToken forKey:kFIRInstallationsStoredItemRefreshTokenKey];
   41|      0|  [aCoder encodeObject:self.authToken forKey:kFIRInstallationsStoredItemAuthTokenKey];
   42|      0|  [aCoder encodeInteger:self.registrationStatus
   43|      0|                 forKey:kFIRInstallationsStoredItemRegistrationStatusKey];
   44|      0|  [aCoder encodeObject:self.IIDDefaultToken forKey:kFIRInstallationsStoredItemIIDDefaultTokenKey];
   45|      0|  [aCoder encodeInteger:self.storageVersion forKey:kFIRInstallationsStoredItemStorageVersionKey];
   46|      0|}
   47|       |
   48|      1|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
   49|      1|  NSInteger storageVersion =
   50|      1|      [aDecoder decodeIntegerForKey:kFIRInstallationsStoredItemStorageVersionKey];
   51|      1|  if (storageVersion > self.storageVersion) {
   52|      0|    FIRLogWarning(kFIRLoggerInstallations,
   53|      0|                  kFIRInstallationsMessageCodeInstallationCoderVersionMismatch,
   54|      0|                  @"FIRInstallationsStoredItem was encoded by a newer coder version %ld. Current "
   55|      0|                  @"coder version is %ld. Some installation data may be lost.",
   56|      0|                  (long)storageVersion, (long)kFIRInstallationsStoredItemStorageVersion);
   57|      0|  }
   58|      1|
   59|      1|  FIRInstallationsStoredItem *item = [[FIRInstallationsStoredItem alloc] init];
   60|      1|  item.firebaseInstallationID =
   61|      1|      [aDecoder decodeObjectOfClass:[NSString class]
   62|      1|                             forKey:kFIRInstallationsStoredItemFirebaseInstallationIDKey];
   63|      1|  item.refreshToken = [aDecoder decodeObjectOfClass:[NSString class]
   64|      1|                                             forKey:kFIRInstallationsStoredItemRefreshTokenKey];
   65|      1|  item.authToken = [aDecoder decodeObjectOfClass:[FIRInstallationsStoredAuthToken class]
   66|      1|                                          forKey:kFIRInstallationsStoredItemAuthTokenKey];
   67|      1|  item.registrationStatus =
   68|      1|      [aDecoder decodeIntegerForKey:kFIRInstallationsStoredItemRegistrationStatusKey];
   69|      1|  item.IIDDefaultToken =
   70|      1|      [aDecoder decodeObjectOfClass:[NSString class]
   71|      1|                             forKey:kFIRInstallationsStoredItemIIDDefaultTokenKey];
   72|      1|
   73|      1|  return item;
   74|      1|}
   75|       |
   76|      1|+ (BOOL)supportsSecureCoding {
   77|      1|  return YES;
   78|      1|}
   79|       |
   80|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/SecureStorage/FIRInstallationsKeychainUtils.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRInstallationsKeychainUtils.h"
   18|       |
   19|       |#import "FIRInstallationsErrorUtil.h"
   20|       |
   21|       |@implementation FIRInstallationsKeychainUtils
   22|       |
   23|       |+ (nullable NSData *)getItemWithQuery:(NSDictionary *)query
   24|      1|                                error:(NSError *_Nullable *_Nullable)outError {
   25|      1|  NSMutableDictionary *mutableQuery = [query mutableCopy];
   26|      1|
   27|      1|  mutableQuery[(__bridge id)kSecReturnData] = @YES;
   28|      1|  mutableQuery[(__bridge id)kSecMatchLimit] = (__bridge id)kSecMatchLimitOne;
   29|      1|
   30|      1|  CFDataRef result = NULL;
   31|      1|  OSStatus status =
   32|      1|      SecItemCopyMatching((__bridge CFDictionaryRef)mutableQuery, (CFTypeRef *)&result);
   33|      1|
   34|      1|  if (status == errSecSuccess && result != NULL) {
   35|      1|    if (outError) {
   36|      1|      *outError = nil;
   37|      1|    }
   38|      1|
   39|      1|    return (__bridge_transfer NSData *)result;
   40|      1|  }
   41|      0|
   42|      0|  if (status == errSecItemNotFound) {
   43|      0|    if (outError) {
   44|      0|      *outError = nil;
   45|      0|    }
   46|      0|  } else {
   47|      0|    if (outError) {
   48|      0|      *outError = [FIRInstallationsErrorUtil keychainErrorWithFunction:@"SecItemCopyMatching"
   49|      0|                                                                status:status];
   50|      0|    }
   51|      0|  }
   52|      0|  return nil;
   53|      0|}
   54|       |
   55|       |+ (BOOL)setItem:(NSData *)item
   56|       |      withQuery:(NSDictionary *)query
   57|      0|          error:(NSError *_Nullable *_Nullable)outError {
   58|      0|  NSData *existingItem = [self getItemWithQuery:query error:outError];
   59|      0|  if (outError && *outError) {
   60|      0|    return NO;
   61|      0|  }
   62|      0|
   63|      0|  NSMutableDictionary *mutableQuery = [query mutableCopy];
   64|      0|  mutableQuery[(__bridge id)kSecAttrAccessible] =
   65|      0|      (__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
   66|      0|
   67|      0|  OSStatus status;
   68|      0|  if (!existingItem) {
   69|      0|    mutableQuery[(__bridge id)kSecValueData] = item;
   70|      0|    status = SecItemAdd((__bridge CFDictionaryRef)mutableQuery, NULL);
   71|      0|  } else {
   72|      0|    NSDictionary *attributes = @{(__bridge id)kSecValueData : item};
   73|      0|    status = SecItemUpdate((__bridge CFDictionaryRef)query, (__bridge CFDictionaryRef)attributes);
   74|      0|  }
   75|      0|
   76|      0|  if (status == noErr) {
   77|      0|    if (outError) {
   78|      0|      *outError = nil;
   79|      0|    }
   80|      0|    return YES;
   81|      0|  }
   82|      0|
   83|      0|  NSString *function = existingItem ? @"SecItemUpdate" : @"SecItemAdd";
   84|      0|  if (outError) {
   85|      0|    *outError = [FIRInstallationsErrorUtil keychainErrorWithFunction:function status:status];
   86|      0|  }
   87|      0|  return NO;
   88|      0|}
   89|       |
   90|      0|+ (BOOL)removeItemWithQuery:(NSDictionary *)query error:(NSError *_Nullable *_Nullable)outError {
   91|      0|  OSStatus status = SecItemDelete((__bridge CFDictionaryRef)query);
   92|      0|
   93|      0|  if (status == noErr || status == errSecItemNotFound) {
   94|      0|    if (outError) {
   95|      0|      *outError = nil;
   96|      0|    }
   97|      0|    return YES;
   98|      0|  }
   99|      0|
  100|      0|  if (outError) {
  101|      0|    *outError = [FIRInstallationsErrorUtil keychainErrorWithFunction:@"SecItemDelete"
  102|      0|                                                              status:status];
  103|      0|  }
  104|      0|  return NO;
  105|      0|}
  106|       |
  107|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/FirebaseInstallations/FirebaseInstallations/Source/Library/SecureStorage/FIRSecureStorage.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSecureStorage.h"
   18|       |#import <Security/Security.h>
   19|       |
   20|       |#if __has_include(<FBLPromises/FBLPromises.h>)
   21|       |#import <FBLPromises/FBLPromises.h>
   22|       |#else
   23|       |#import "FBLPromises.h"
   24|       |#endif
   25|       |
   26|       |#import "FIRInstallationsErrorUtil.h"
   27|       |#import "FIRInstallationsKeychainUtils.h"
   28|       |
   29|       |@interface FIRSecureStorage ()
   30|       |@property(nonatomic, readonly) dispatch_queue_t keychainQueue;
   31|       |@property(nonatomic, readonly) dispatch_queue_t inMemoryCacheQueue;
   32|       |@property(nonatomic, readonly) NSString *service;
   33|       |@property(nonatomic, readonly) NSCache<NSString *, id<NSSecureCoding>> *inMemoryCache;
   34|       |@end
   35|       |
   36|       |@implementation FIRSecureStorage
   37|       |
   38|      1|- (instancetype)init {
   39|      1|  NSCache *cache = [[NSCache alloc] init];
   40|      1|  // Cache up to 5 installations.
   41|      1|  cache.countLimit = 5;
   42|      1|  return [self initWithService:@"com.firebase.FIRInstallations.installations" cache:cache];
   43|      1|}
   44|       |
   45|      1|- (instancetype)initWithService:(NSString *)service cache:(NSCache *)cache {
   46|      1|  self = [super init];
   47|      1|  if (self) {
   48|      1|    _keychainQueue = dispatch_queue_create(
   49|      1|        "com.firebase.FIRInstallations.FIRSecureStorage.Keychain", DISPATCH_QUEUE_SERIAL);
   50|      1|    _inMemoryCacheQueue = dispatch_queue_create(
   51|      1|        "com.firebase.FIRInstallations.FIRSecureStorage.InMemoryCache", DISPATCH_QUEUE_SERIAL);
   52|      1|    _service = [service copy];
   53|      1|    _inMemoryCache = cache;
   54|      1|  }
   55|      1|  return self;
   56|      1|}
   57|       |
   58|       |#pragma mark - Public
   59|       |
   60|       |- (FBLPromise<id<NSSecureCoding>> *)getObjectForKey:(NSString *)key
   61|       |                                        objectClass:(Class)objectClass
   62|      1|                                        accessGroup:(nullable NSString *)accessGroup {
   63|      1|  return [FBLPromise onQueue:self.inMemoryCacheQueue
   64|      1|                          do:^id _Nullable {
   65|      1|                            // Return cached object or fail otherwise.
   66|      1|                            id object = [self.inMemoryCache objectForKey:key];
   67|      1|                            return object
   68|      1|                                       ?: [[NSError alloc]
   69|      1|                                              initWithDomain:FBLPromiseErrorDomain
   70|      1|                                                        code:FBLPromiseErrorCodeValidationFailure
   71|      1|                                                    userInfo:nil];
   72|      1|                          }]
   73|      1|      .recover(^id _Nullable(NSError *error) {
   74|      1|        // Look for the object in the keychain.
   75|      1|        return [self getObjectFromKeychainForKey:key
   76|      1|                                     objectClass:objectClass
   77|      1|                                     accessGroup:accessGroup];
   78|      1|      });
   79|      1|}
   80|       |
   81|       |- (FBLPromise<NSNull *> *)setObject:(id<NSSecureCoding>)object
   82|       |                             forKey:(NSString *)key
   83|      0|                        accessGroup:(nullable NSString *)accessGroup {
   84|      0|  return [FBLPromise onQueue:self.inMemoryCacheQueue
   85|      0|                          do:^id _Nullable {
   86|      0|                            // Save to the in-memory cache first.
   87|      0|                            [self.inMemoryCache setObject:object forKey:[key copy]];
   88|      0|                            return [NSNull null];
   89|      0|                          }]
   90|      0|      .thenOn(self.keychainQueue, ^id(id result) {
   91|      0|        // Then store the object to the keychain.
   92|      0|        NSDictionary *query = [self keychainQueryWithKey:key accessGroup:accessGroup];
   93|      0|        NSError *error;
   94|      0|        NSData *encodedObject = [self archiveDataForObject:object error:&error];
   95|      0|        if (!encodedObject) {
   96|      0|          return error;
   97|      0|        }
   98|      0|
   99|      0|        if (![FIRInstallationsKeychainUtils setItem:encodedObject withQuery:query error:&error]) {
  100|      0|          return error;
  101|      0|        }
  102|      0|
  103|      0|        return [NSNull null];
  104|      0|      });
  105|      0|}
  106|       |
  107|       |- (FBLPromise<NSNull *> *)removeObjectForKey:(NSString *)key
  108|      0|                                 accessGroup:(nullable NSString *)accessGroup {
  109|      0|  return [FBLPromise onQueue:self.inMemoryCacheQueue
  110|      0|                          do:^id _Nullable {
  111|      0|                            [self.inMemoryCache removeObjectForKey:key];
  112|      0|                            return nil;
  113|      0|                          }]
  114|      0|      .thenOn(self.keychainQueue, ^id(id result) {
  115|      0|        NSDictionary *query = [self keychainQueryWithKey:key accessGroup:accessGroup];
  116|      0|
  117|      0|        NSError *error;
  118|      0|        if (![FIRInstallationsKeychainUtils removeItemWithQuery:query error:&error]) {
  119|      0|          return error;
  120|      0|        }
  121|      0|
  122|      0|        return [NSNull null];
  123|      0|      });
  124|      0|}
  125|       |
  126|       |#pragma mark - Private
  127|       |
  128|       |- (FBLPromise<id<NSSecureCoding>> *)getObjectFromKeychainForKey:(NSString *)key
  129|       |                                                    objectClass:(Class)objectClass
  130|      1|                                                    accessGroup:(nullable NSString *)accessGroup {
  131|      1|  // Look for the object in the keychain.
  132|      1|  return [FBLPromise onQueue:self.keychainQueue
  133|      1|                          do:^id {
  134|      1|                            NSDictionary *query = [self keychainQueryWithKey:key
  135|      1|                                                                 accessGroup:accessGroup];
  136|      1|                            NSError *error;
  137|      1|                            NSData *encodedObject =
  138|      1|                                [FIRInstallationsKeychainUtils getItemWithQuery:query error:&error];
  139|      1|
  140|      1|                            if (error) {
  141|      0|                              return error;
  142|      0|                            }
  143|      1|                            if (!encodedObject) {
  144|      0|                              return nil;
  145|      0|                            }
  146|      1|                            id object = [self unarchivedObjectOfClass:objectClass
  147|      1|                                                             fromData:encodedObject
  148|      1|                                                                error:&error];
  149|      1|                            if (error) {
  150|      0|                              return error;
  151|      0|                            }
  152|      1|
  153|      1|                            return object;
  154|      1|                          }]
  155|      1|      .thenOn(self.inMemoryCacheQueue,
  156|      1|              ^id<NSSecureCoding> _Nullable(id<NSSecureCoding> _Nullable object) {
  157|      1|                // Save object to the in-memory cache if exists and return the object.
  158|      1|                if (object) {
  159|      1|                  [self.inMemoryCache setObject:object forKey:[key copy]];
  160|      1|                }
  161|      1|                return object;
  162|      1|              });
  163|      1|}
  164|       |
  165|      0|- (void)resetInMemoryCache {
  166|      0|  [self.inMemoryCache removeAllObjects];
  167|      0|}
  168|       |
  169|       |#pragma mark - Keychain
  170|       |
  171|       |- (NSMutableDictionary<NSString *, id> *)keychainQueryWithKey:(NSString *)key
  172|      1|                                                  accessGroup:(nullable NSString *)accessGroup {
  173|      1|  NSMutableDictionary<NSString *, id> *query = [NSMutableDictionary dictionary];
  174|      1|
  175|      1|  query[(__bridge NSString *)kSecClass] = (__bridge NSString *)kSecClassGenericPassword;
  176|      1|  query[(__bridge NSString *)kSecAttrService] = self.service;
  177|      1|  query[(__bridge NSString *)kSecAttrAccount] = key;
  178|      1|
  179|      1|  if (accessGroup) {
  180|      0|    query[(__bridge NSString *)kSecAttrAccessGroup] = accessGroup;
  181|      0|  }
  182|      1|
  183|       |#if TARGET_OS_OSX
  184|       |  if (self.keychainRef) {
  185|       |    query[(__bridge NSString *)kSecUseKeychain] = (__bridge id)(self.keychainRef);
  186|       |    query[(__bridge NSString *)kSecMatchSearchList] = @[ (__bridge id)(self.keychainRef) ];
  187|       |  }
  188|       |#endif  // TARGET_OSX
  189|       |
  190|      1|  return query;
  191|      1|}
  192|       |
  193|      0|- (nullable NSData *)archiveDataForObject:(id<NSSecureCoding>)object error:(NSError **)outError {
  194|      0|  NSData *archiveData;
  195|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  196|      0|    NSError *error;
  197|      0|    archiveData = [NSKeyedArchiver archivedDataWithRootObject:object
  198|      0|                                        requiringSecureCoding:YES
  199|      0|                                                        error:&error];
  200|      0|    if (error && outError) {
  201|      0|      *outError = [FIRInstallationsErrorUtil keyedArchiverErrorWithError:error];
  202|      0|    }
  203|      0|  } else {
  204|      0|    @try {
  205|      0|      NSMutableData *data = [NSMutableData data];
  206|      0|#pragma clang diagnostic push
  207|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  208|      0|      NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];
  209|      0|#pragma clang diagnostic pop
  210|      0|      archiver.requiresSecureCoding = YES;
  211|      0|
  212|      0|      [archiver encodeObject:object forKey:NSKeyedArchiveRootObjectKey];
  213|      0|      [archiver finishEncoding];
  214|      0|
  215|      0|      archiveData = [data copy];
  216|      0|    } @catch (NSException *exception) {
  217|      0|      if (outError) {
  218|      0|        *outError = [FIRInstallationsErrorUtil keyedArchiverErrorWithException:exception];
  219|      0|      }
  220|      0|    }
  221|      0|  }
  222|      0|
  223|      0|  return archiveData;
  224|      0|}
  225|       |
  226|       |- (nullable id)unarchivedObjectOfClass:(Class)class
  227|       |                              fromData:(NSData *)data
  228|      1|                                 error:(NSError **)outError {
  229|      1|  id object;
  230|      1|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, *)) {
  231|      1|    NSError *error;
  232|      1|    object = [NSKeyedUnarchiver unarchivedObjectOfClass:class fromData:data error:&error];
  233|      1|    if (error && outError) {
  234|      0|      *outError = [FIRInstallationsErrorUtil keyedArchiverErrorWithError:error];
  235|      0|    }
  236|      1|  } else {
  237|      0|    @try {
  238|      0|#pragma clang diagnostic push
  239|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  240|      0|      NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
  241|      0|#pragma clang diagnostic pop
  242|      0|      unarchiver.requiresSecureCoding = YES;
  243|      0|
  244|      0|      object = [unarchiver decodeObjectOfClass:class forKey:NSKeyedArchiveRootObjectKey];
  245|      0|    } @catch (NSException *exception) {
  246|      0|      if (outError) {
  247|      0|        *outError = [FIRInstallationsErrorUtil keyedArchiverErrorWithException:exception];
  248|      0|      }
  249|      0|    }
  250|      0|  }
  251|      1|
  252|      1|  return object;
  253|      1|}
  254|       |
  255|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORAssert.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORAssert.h"
   18|       |
   19|      0|GDTCORAssertionBlock GDTCORAssertionBlockToRunInstead(void) {
   20|      0|  // This class is only compiled in by unit tests, and this should fail quickly in optimized builds.
   21|      0|  Class GDTCORAssertClass = NSClassFromString(@"GDTCORAssertHelper");
   22|      0|  if (__builtin_expect(!!GDTCORAssertClass, 0)) {
   23|      0|    SEL assertionBlockSEL = NSSelectorFromString(@"assertionBlock");
   24|      0|    if (assertionBlockSEL) {
   25|      0|      IMP assertionBlockIMP = [GDTCORAssertClass methodForSelector:assertionBlockSEL];
   26|      0|      if (assertionBlockIMP) {
   27|      0|        GDTCORAssertionBlock assertionBlock = ((GDTCORAssertionBlock(*)(id, SEL))assertionBlockIMP)(
   28|      0|            GDTCORAssertClass, assertionBlockSEL);
   29|      0|        if (assertionBlock) {
   30|      0|          return assertionBlock;
   31|      0|        }
   32|      0|      }
   33|      0|    }
   34|      0|  }
   35|      0|  return NULL;
   36|      0|}

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORClock.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORClock.h"
   18|       |
   19|       |#import <sys/sysctl.h>
   20|       |
   21|       |// Using a monotonic clock is necessary because CFAbsoluteTimeGetCurrent(), NSDate, and related all
   22|       |// are subject to drift. That it to say, multiple consecutive calls do not always result in a
   23|       |// time that is in the future. Clocks may be adjusted by the user, NTP, or any number of external
   24|       |// factors. This class attempts to determine the wall-clock time at the time of the event by
   25|       |// capturing the kernel start and time since boot to determine a wallclock time in UTC.
   26|       |//
   27|       |// Timezone offsets at the time of a snapshot are also captured in order to provide local-time
   28|       |// details. Other classes in this library depend on comparing times at some time in the future to
   29|       |// a time captured in the past, and this class needs to provide a mechanism to do that.
   30|       |//
   31|       |// TL;DR: This class attempts to accomplish two things: 1. Provide accurate event times. 2. Provide
   32|       |// a monotonic clock mechanism to accurately check if some clock snapshot was before or after
   33|       |// by using a shared reference point (kernel boot time).
   34|       |//
   35|       |// Note: Much of the mach time stuff doesn't work properly in the simulator. So this class can be
   36|       |// difficult to unit test.
   37|       |
   38|       |/** Returns the kernel boottime property from sysctl.
   39|       | *
   40|       | * Inspired by https://stackoverflow.com/a/40497811
   41|       | *
   42|       | * @return The KERN_BOOTTIME property from sysctl, in nanoseconds.
   43|       | */
   44|     33|static int64_t KernelBootTimeInNanoseconds() {
   45|     33|  // Caching the result is not possible because clock drift would not be accounted for.
   46|     33|  struct timeval boottime;
   47|     33|  int mib[2] = {CTL_KERN, KERN_BOOTTIME};
   48|     33|  size_t size = sizeof(boottime);
   49|     33|  int rc = sysctl(mib, 2, &boottime, &size, NULL, 0);
   50|     33|  if (rc != 0) {
   51|      0|    return 0;
   52|      0|  }
   53|     33|  return (int64_t)boottime.tv_sec * NSEC_PER_MSEC + (int64_t)boottime.tv_usec;
   54|     33|}
   55|       |
   56|       |/** Returns value of gettimeofday, in nanoseconds.
   57|       | *
   58|       | * Inspired by https://stackoverflow.com/a/40497811
   59|       | *
   60|       | * @return The value of gettimeofday, in nanoseconds.
   61|       | */
   62|     11|static int64_t UptimeInNanoseconds() {
   63|     11|  int64_t before_now;
   64|     11|  int64_t after_now;
   65|     11|  struct timeval now;
   66|     11|
   67|     11|  before_now = KernelBootTimeInNanoseconds();
   68|     11|  // Addresses a race condition in which the system time has updated, but the boottime has not.
   69|     11|  do {
   70|     11|    gettimeofday(&now, NULL);
   71|     11|    after_now = KernelBootTimeInNanoseconds();
   72|     11|  } while (after_now != before_now);
   73|     11|  return (int64_t)now.tv_sec * NSEC_PER_MSEC + (int64_t)now.tv_usec - before_now;
   74|     11|}
   75|       |
   76|       |// TODO: Consider adding a 'trustedTime' property that can be populated by the response from a BE.
   77|       |@implementation GDTCORClock
   78|       |
   79|     11|- (instancetype)init {
   80|     11|  self = [super init];
   81|     11|  if (self) {
   82|     11|    _kernelBootTime = KernelBootTimeInNanoseconds();
   83|     11|    _uptime = UptimeInNanoseconds();
   84|     11|    _timeMillis =
   85|     11|        (int64_t)((CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970) * NSEC_PER_USEC);
   86|     11|    CFTimeZoneRef timeZoneRef = CFTimeZoneCopySystem();
   87|     11|    _timezoneOffsetSeconds = CFTimeZoneGetSecondsFromGMT(timeZoneRef, 0);
   88|     11|    CFRelease(timeZoneRef);
   89|     11|  }
   90|     11|  return self;
   91|     11|}
   92|       |
   93|     11|+ (GDTCORClock *)snapshot {
   94|     11|  return [[GDTCORClock alloc] init];
   95|     11|}
   96|       |
   97|      4|+ (instancetype)clockSnapshotInTheFuture:(uint64_t)millisInTheFuture {
   98|      4|  GDTCORClock *snapshot = [self snapshot];
   99|      4|  snapshot->_timeMillis += millisInTheFuture;
  100|      4|  return snapshot;
  101|      4|}
  102|       |
  103|      0|- (BOOL)isAfter:(GDTCORClock *)otherClock {
  104|      0|  // These clocks are trivially comparable when they share a kernel boot time.
  105|      0|  if (_kernelBootTime == otherClock->_kernelBootTime) {
  106|      0|    int64_t timeDiff = (_timeMillis + _timezoneOffsetSeconds) -
  107|      0|                       (otherClock->_timeMillis + otherClock->_timezoneOffsetSeconds);
  108|      0|    return timeDiff > 0;
  109|      0|  } else {
  110|      0|    int64_t kernelBootTimeDiff = otherClock->_kernelBootTime - _kernelBootTime;
  111|      0|    // This isn't a great solution, but essentially, if the other clock's boot time is 'later', NO
  112|      0|    // is returned. This can be altered by changing the system time and rebooting.
  113|      0|    return kernelBootTimeDiff < 0 ? YES : NO;
  114|      0|  }
  115|      0|}
  116|       |
  117|     11|- (NSUInteger)hash {
  118|     11|  return [@(_kernelBootTime) hash] ^ [@(_uptime) hash] ^ [@(_timeMillis) hash] ^
  119|     11|         [@(_timezoneOffsetSeconds) hash];
  120|     11|}
  121|       |
  122|      0|- (BOOL)isEqual:(id)object {
  123|      0|  return [self hash] == [object hash];
  124|      0|}
  125|       |
  126|       |#pragma mark - NSSecureCoding
  127|       |
  128|       |/** NSKeyedCoder key for timeMillis property. */
  129|       |static NSString *const kGDTCORClockTimeMillisKey = @"GDTCORClockTimeMillis";
  130|       |
  131|       |/** NSKeyedCoder key for timezoneOffsetMillis property. */
  132|       |static NSString *const kGDTCORClockTimezoneOffsetSeconds = @"GDTCORClockTimezoneOffsetSeconds";
  133|       |
  134|       |/** NSKeyedCoder key for _kernelBootTime ivar. */
  135|       |static NSString *const kGDTCORClockKernelBootTime = @"GDTCORClockKernelBootTime";
  136|       |
  137|       |/** NSKeyedCoder key for _uptime ivar. */
  138|       |static NSString *const kGDTCORClockUptime = @"GDTCORClockUptime";
  139|       |
  140|      0|+ (BOOL)supportsSecureCoding {
  141|      0|  return YES;
  142|      0|}
  143|       |
  144|      0|- (instancetype)initWithCoder:(NSCoder *)aDecoder {
  145|      0|  self = [super init];
  146|      0|  if (self) {
  147|      0|    // TODO: If the kernelBootTime is more recent, we need to change the kernel boot time and
  148|      0|    // uptimeMillis ivars
  149|      0|    _timeMillis = [aDecoder decodeInt64ForKey:kGDTCORClockTimeMillisKey];
  150|      0|    _timezoneOffsetSeconds = [aDecoder decodeInt64ForKey:kGDTCORClockTimezoneOffsetSeconds];
  151|      0|    _kernelBootTime = [aDecoder decodeInt64ForKey:kGDTCORClockKernelBootTime];
  152|      0|    _uptime = [aDecoder decodeInt64ForKey:kGDTCORClockUptime];
  153|      0|  }
  154|      0|  return self;
  155|      0|}
  156|       |
  157|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  158|      0|  [aCoder encodeInt64:_timeMillis forKey:kGDTCORClockTimeMillisKey];
  159|      0|  [aCoder encodeInt64:_timezoneOffsetSeconds forKey:kGDTCORClockTimezoneOffsetSeconds];
  160|      0|  [aCoder encodeInt64:_kernelBootTime forKey:kGDTCORClockKernelBootTime];
  161|      0|  [aCoder encodeInt64:_uptime forKey:kGDTCORClockUptime];
  162|      0|}
  163|       |
  164|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORConsoleLogger.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORConsoleLogger.h"
   18|       |
   19|       |/** The console logger prefix. */
   20|       |static NSString *kGDTCORConsoleLogger = @"[GoogleDataTransport]";
   21|       |
   22|      0|NSString *GDTCORMessageCodeEnumToString(GDTCORMessageCode code) {
   23|      0|  return [[NSString alloc] initWithFormat:@"I-GDTCOR%06ld", (long)code];
   24|      0|}
   25|       |
   26|      0|void GDTCORLog(GDTCORMessageCode code, NSString *format, ...) {
   27|      0|// Don't log anything in not debug builds.
   28|      0|#if !NDEBUG
   29|      0|  NSString *logFormat = [NSString stringWithFormat:@"%@[%@] %@", kGDTCORConsoleLogger,
   30|      0|                                                   GDTCORMessageCodeEnumToString(code), format];
   31|      0|  va_list args;
   32|      0|  va_start(args, format);
   33|      0|  NSLogv(logFormat, args);
   34|      0|  va_end(args);
   35|      0|#endif  // !NDEBUG
   36|      0|}
   37|       |
   38|       |void GDTCORLogAssert(
   39|      0|    BOOL wasFatal, NSString *_Nonnull file, NSInteger line, NSString *_Nullable format, ...) {
   40|      0|  GDTCORMessageCode code = wasFatal ? GDTCORMCEFatalAssertion : GDTCORMCEGeneralError;
   41|      0|// Don't log anything in not debug builds.
   42|      0|#if !NDEBUG
   43|      0|  NSString *logFormat =
   44|      0|      [NSString stringWithFormat:@"%@[%@] (%@:%ld) : %@", kGDTCORConsoleLogger,
   45|      0|                                 GDTCORMessageCodeEnumToString(code), file, (long)line, format];
   46|      0|  va_list args;
   47|      0|  va_start(args, format);
   48|      0|  NSLogv(logFormat, args);
   49|      0|  va_end(args);
   50|      0|#endif  // !NDEBUG
   51|      0|}

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORDataFuture.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Private/GDTCORDataFuture.h"
   18|       |
   19|       |@implementation GDTCORDataFuture
   20|       |
   21|      0|- (instancetype)initWithFileURL:(NSURL *)fileURL {
   22|      0|  self = [super init];
   23|      0|  if (self) {
   24|      0|    _fileURL = fileURL;
   25|      0|  }
   26|      0|  return self;
   27|      0|}
   28|       |
   29|      0|- (BOOL)isEqual:(id)object {
   30|      0|  return [self hash] == [object hash];
   31|      0|}
   32|       |
   33|      0|- (NSUInteger)hash {
   34|      0|  // In reality, only one of these should be populated.
   35|      0|  return [_fileURL hash];
   36|      0|}
   37|       |
   38|       |#pragma mark - NSSecureCoding
   39|       |
   40|       |/** Coding key for _fileURL ivar. */
   41|       |static NSString *kGDTCORDataFutureFileURLKey = @"GDTCORDataFutureFileURLKey";
   42|       |
   43|      0|+ (BOOL)supportsSecureCoding {
   44|      0|  return YES;
   45|      0|}
   46|       |
   47|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
   48|      0|  [aCoder encodeObject:_fileURL forKey:kGDTCORDataFutureFileURLKey];
   49|      0|}
   50|       |
   51|      0|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
   52|      0|  self = [self init];
   53|      0|  if (self) {
   54|      0|    _fileURL = [aDecoder decodeObjectOfClass:[NSURL class] forKey:kGDTCORDataFutureFileURLKey];
   55|      0|  }
   56|      0|  return self;
   57|      0|}
   58|       |
   59|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCOREvent.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCOREvent.h"
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORAssert.h>
   20|       |#import <GoogleDataTransport/GDTCORClock.h>
   21|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   22|       |#import <GoogleDataTransport/GDTCORPlatform.h>
   23|       |
   24|       |#import "GDTCORLibrary/Private/GDTCORDataFuture.h"
   25|       |#import "GDTCORLibrary/Private/GDTCOREvent_Private.h"
   26|       |
   27|       |@implementation GDTCOREvent
   28|       |
   29|      4|- (nullable instancetype)initWithMappingID:(NSString *)mappingID target:(NSInteger)target {
   30|      4|  GDTCORAssert(mappingID.length > 0, @"Please give a valid mapping ID");
   31|      4|  GDTCORAssert(target > 0, @"A target cannot be negative or 0");
   32|      4|  if (mappingID == nil || mappingID.length == 0 || target <= 0) {
   33|      0|    return nil;
   34|      0|  }
   35|      4|  self = [super init];
   36|      4|  if (self) {
   37|      4|    _mappingID = mappingID;
   38|      4|    _target = target;
   39|      4|    _qosTier = GDTCOREventQosDefault;
   40|      4|  }
   41|      4|  GDTCORLogDebug("Event %@ created. mappingID: %@ target:%ld", self, mappingID, (long)target);
   42|      4|  return self;
   43|      4|}
   44|       |
   45|      2|- (instancetype)copy {
   46|      2|  GDTCOREvent *copy = [[GDTCOREvent alloc] initWithMappingID:_mappingID target:_target];
   47|      2|  copy.dataObject = _dataObject;
   48|      2|  copy.qosTier = _qosTier;
   49|      2|  copy.clockSnapshot = _clockSnapshot;
   50|      2|  copy.customPrioritizationParams = _customPrioritizationParams;
   51|      2|  copy->_GDTFilePath = _GDTFilePath;
   52|      2|  GDTCORLogDebug("Copying event %@ to event %@", self, copy);
   53|      2|  return copy;
   54|      2|}
   55|       |
   56|     11|- (NSUInteger)hash {
   57|     11|  // This loses some precision, but it's probably fine.
   58|     11|  NSUInteger mappingIDHash = [_mappingID hash];
   59|     11|  NSUInteger timeHash = [_clockSnapshot hash];
   60|     11|  NSInteger dataObjectHash = [_dataObject hash];
   61|     11|  NSUInteger fileURL = [_GDTFilePath hash];
   62|     11|
   63|     11|  return mappingIDHash ^ _target ^ _qosTier ^ timeHash ^ dataObjectHash ^ fileURL;
   64|     11|}
   65|       |
   66|      0|- (BOOL)isEqual:(id)object {
   67|      0|  return [self hash] == [object hash];
   68|      0|}
   69|       |
   70|       |#pragma mark - Property overrides
   71|       |
   72|      4|- (void)setDataObject:(id<GDTCOREventDataObject>)dataObject {
   73|      4|  // If you're looking here because of a performance issue in -transportBytes slowing the assignment
   74|      4|  // of -dataObject, one way to address this is to add a queue to this class,
   75|      4|  // dispatch_(barrier_ if concurrent)async here, and implement the getter with a dispatch_sync.
   76|      4|  if (dataObject != _dataObject) {
   77|      4|    _dataObject = dataObject;
   78|      4|  }
   79|      4|}
   80|       |
   81|      4|- (NSURL *)fileURL {
   82|      4|  if (!_GDTFilePath) {
   83|      0|    _GDTFilePath = [NSString stringWithFormat:@"event-%lu", (unsigned long)self.hash];
   84|      0|  }
   85|      4|  return [GDTCORRootDirectory() URLByAppendingPathComponent:_GDTFilePath];
   86|      4|}
   87|       |
   88|       |#pragma mark - Private methods
   89|       |
   90|      2|- (BOOL)writeToGDTPath:(NSString *)filePath error:(NSError **)error {
   91|      2|  NSData *dataTransportBytes = [_dataObject transportBytes];
   92|      2|  if (dataTransportBytes == nil) {
   93|      0|    _GDTFilePath = nil;
   94|      0|    _dataObject = nil;
   95|      0|    return NO;
   96|      0|  }
   97|      2|  NSURL *fileURL = [GDTCORRootDirectory() URLByAppendingPathComponent:filePath];
   98|      2|  BOOL writingSuccess = [dataTransportBytes writeToURL:fileURL
   99|      2|                                               options:NSDataWritingAtomic
  100|      2|                                                 error:error];
  101|      2|  if (!writingSuccess) {
  102|      0|    GDTCORLogError(GDTCORMCEFileWriteError, @"An event file could not be written: %@", fileURL);
  103|      0|    return NO;
  104|      0|  }
  105|      2|  _GDTFilePath = filePath;
  106|      2|  _dataObject = nil;
  107|      2|  return YES;
  108|      2|}
  109|       |
  110|       |#pragma mark - NSSecureCoding and NSCoding Protocols
  111|       |
  112|       |/** NSCoding key for mappingID property. */
  113|       |static NSString *mappingIDKey = @"_mappingID";
  114|       |
  115|       |/** NSCoding key for target property. */
  116|       |static NSString *targetKey = @"_target";
  117|       |
  118|       |/** NSCoding key for qosTier property. */
  119|       |static NSString *qosTierKey = @"_qosTier";
  120|       |
  121|       |/** NSCoding key for clockSnapshot property. */
  122|       |static NSString *clockSnapshotKey = @"_clockSnapshot";
  123|       |
  124|       |/** NSCoding key for fileURL property. */
  125|       |static NSString *fileURLKey = @"_fileURL";
  126|       |
  127|       |/** NSCoding key for GDTFilePath property. */
  128|       |static NSString *kGDTFilePathKey = @"_GDTFilePath";
  129|       |
  130|       |/** NSCoding key for customPrioritizationParams property. */
  131|       |static NSString *customPrioritizationParams = @"_customPrioritizationParams";
  132|       |
  133|       |/** NSCoding key for backwards compatibility of GDTCORStoredEvent mappingID property.*/
  134|       |static NSString *kStoredEventMappingIDKey = @"GDTCORStoredEventMappingIDKey";
  135|       |
  136|       |/** NSCoding key for backwards compatibility of GDTCORStoredEvent target property.*/
  137|       |static NSString *kStoredEventTargetKey = @"GDTCORStoredEventTargetKey";
  138|       |
  139|       |/** NSCoding key for backwards compatibility of GDTCORStoredEvent qosTier property.*/
  140|       |static NSString *kStoredEventQosTierKey = @"GDTCORStoredEventQosTierKey";
  141|       |
  142|       |/** NSCoding key for backwards compatibility of GDTCORStoredEvent clockSnapshot property.*/
  143|       |static NSString *kStoredEventClockSnapshotKey = @"GDTCORStoredEventClockSnapshotKey";
  144|       |
  145|       |/** NSCoding key for backwards compatibility of GDTCORStoredEvent dataFuture property.*/
  146|       |static NSString *kStoredEventDataFutureKey = @"GDTCORStoredEventDataFutureKey";
  147|       |
  148|       |/** NSCoding key for backwards compatibility of GDTCORStoredEvent customPrioritizationParams
  149|       | * property.*/
  150|       |static NSString *kStoredEventCustomPrioritizationParamsKey =
  151|       |    @"GDTCORStoredEventcustomPrioritizationParamsKey";
  152|       |
  153|      0|+ (BOOL)supportsSecureCoding {
  154|      0|  return YES;
  155|      0|}
  156|       |
  157|      0|- (id)initWithCoder:(NSCoder *)aDecoder {
  158|      0|  GDTCORDataFuture *dataFuture = [aDecoder decodeObjectOfClass:[GDTCORDataFuture class]
  159|      0|                                                        forKey:kStoredEventDataFutureKey];
  160|      0|  if (dataFuture) {
  161|      0|    return [self initWithCoderForStoredEventBackwardCompatibility:aDecoder
  162|      0|                                                          fileURL:dataFuture.fileURL];
  163|      0|  }
  164|      0|  NSString *mappingID = [aDecoder decodeObjectOfClass:[NSString class] forKey:mappingIDKey];
  165|      0|  NSInteger target = [aDecoder decodeIntegerForKey:targetKey];
  166|      0|  self = [self initWithMappingID:mappingID target:target];
  167|      0|  if (self) {
  168|      0|    _qosTier = [aDecoder decodeIntegerForKey:qosTierKey];
  169|      0|    _clockSnapshot = [aDecoder decodeObjectOfClass:[GDTCORClock class] forKey:clockSnapshotKey];
  170|      0|    NSURL *fileURL = [aDecoder decodeObjectOfClass:[NSURL class] forKey:fileURLKey];
  171|      0|    if (fileURL) {
  172|      0|      _GDTFilePath = [fileURL lastPathComponent];
  173|      0|    } else {
  174|      0|      _GDTFilePath = [aDecoder decodeObjectOfClass:[NSString class] forKey:kGDTFilePathKey];
  175|      0|    }
  176|      0|    _customPrioritizationParams = [aDecoder decodeObjectOfClass:[NSDictionary class]
  177|      0|                                                         forKey:customPrioritizationParams];
  178|      0|  }
  179|      0|  return self;
  180|      0|}
  181|       |
  182|       |- (id)initWithCoderForStoredEventBackwardCompatibility:(NSCoder *)aDecoder
  183|      0|                                               fileURL:(NSURL *)fileURL {
  184|      0|  NSString *mappingID = [aDecoder decodeObjectOfClass:[NSString class]
  185|      0|                                               forKey:kStoredEventMappingIDKey];
  186|      0|  NSInteger target = [[aDecoder decodeObjectOfClass:[NSNumber class]
  187|      0|                                             forKey:kStoredEventTargetKey] integerValue];
  188|      0|  self = [self initWithMappingID:mappingID target:target];
  189|      0|  if (self) {
  190|      0|    _qosTier = [[aDecoder decodeObjectOfClass:[NSNumber class]
  191|      0|                                       forKey:kStoredEventQosTierKey] integerValue];
  192|      0|    _clockSnapshot = [aDecoder decodeObjectOfClass:[GDTCORClock class]
  193|      0|                                            forKey:kStoredEventClockSnapshotKey];
  194|      0|    if (fileURL) {
  195|      0|      _GDTFilePath = [fileURL lastPathComponent];
  196|      0|    } else {
  197|      0|      _GDTFilePath = [aDecoder decodeObjectOfClass:[NSString class] forKey:kGDTFilePathKey];
  198|      0|    }
  199|      0|    _customPrioritizationParams =
  200|      0|        [aDecoder decodeObjectOfClass:[NSDictionary class]
  201|      0|                               forKey:kStoredEventCustomPrioritizationParamsKey];
  202|      0|  }
  203|      0|  return self;
  204|      0|}
  205|       |
  206|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  207|      0|  [aCoder encodeObject:_mappingID forKey:mappingIDKey];
  208|      0|  [aCoder encodeInteger:_target forKey:targetKey];
  209|      0|  [aCoder encodeInteger:_qosTier forKey:qosTierKey];
  210|      0|  [aCoder encodeObject:_clockSnapshot forKey:clockSnapshotKey];
  211|      0|  [aCoder encodeObject:_GDTFilePath forKey:kGDTFilePathKey];
  212|      0|  [aCoder encodeObject:_customPrioritizationParams forKey:customPrioritizationParams];
  213|      0|}
  214|       |
  215|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORLifecycle.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORLifecycle.h"
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   20|       |#import <GoogleDataTransport/GDTCOREvent.h>
   21|       |
   22|       |#import "GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   23|       |#import "GDTCORLibrary/Private/GDTCORStorage_Private.h"
   24|       |#import "GDTCORLibrary/Private/GDTCORTransformer_Private.h"
   25|       |#import "GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   26|       |
   27|       |@implementation GDTCORLifecycle
   28|       |
   29|      1|+ (void)load {
   30|      1|  [self sharedInstance];
   31|      1|}
   32|       |
   33|       |/** Creates/returns the singleton instance of this class.
   34|       | *
   35|       | * @return The singleton instance of this class.
   36|       | */
   37|      1|+ (instancetype)sharedInstance {
   38|      1|  static GDTCORLifecycle *sharedInstance;
   39|      1|  static dispatch_once_t onceToken;
   40|      1|  dispatch_once(&onceToken, ^{
   41|      1|    sharedInstance = [[GDTCORLifecycle alloc] init];
   42|      1|  });
   43|      1|  return sharedInstance;
   44|      1|}
   45|       |
   46|      1|- (instancetype)init {
   47|      1|  self = [super init];
   48|      1|  if (self) {
   49|      1|    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
   50|      1|    [notificationCenter addObserver:self
   51|      1|                           selector:@selector(applicationDidEnterBackground:)
   52|      1|                               name:kGDTCORApplicationDidEnterBackgroundNotification
   53|      1|                             object:nil];
   54|      1|    [notificationCenter addObserver:self
   55|      1|                           selector:@selector(applicationWillEnterForeground:)
   56|      1|                               name:kGDTCORApplicationWillEnterForegroundNotification
   57|      1|                             object:nil];
   58|      1|
   59|      1|    NSString *name = kGDTCORApplicationWillTerminateNotification;
   60|      1|    [notificationCenter addObserver:self
   61|      1|                           selector:@selector(applicationWillTerminate:)
   62|      1|                               name:name
   63|      1|                             object:nil];
   64|      1|  }
   65|      1|  return self;
   66|      1|}
   67|       |
   68|      0|- (void)dealloc {
   69|      0|  [[NSNotificationCenter defaultCenter] removeObserver:self];
   70|      0|}
   71|       |
   72|      0|- (void)applicationDidEnterBackground:(NSNotification *)notification {
   73|      0|  GDTCORApplication *application = [GDTCORApplication sharedApplication];
   74|      0|  if ([[GDTCORTransformer sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   75|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORTransformer that the app is backgrounding.");
   76|      0|    [[GDTCORTransformer sharedInstance] appWillBackground:application];
   77|      0|  }
   78|      0|  if ([[GDTCORStorage sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   79|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORStorage that the app is backgrounding.");
   80|      0|    [[GDTCORStorage sharedInstance] appWillBackground:application];
   81|      0|  }
   82|      0|  if ([[GDTCORUploadCoordinator sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   83|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORUploadCoordinator that the app is backgrounding.");
   84|      0|    [[GDTCORUploadCoordinator sharedInstance] appWillBackground:application];
   85|      0|  }
   86|      0|  if ([[GDTCORRegistrar sharedInstance] respondsToSelector:@selector(appWillBackground:)]) {
   87|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORRegistrar that the app is backgrounding.");
   88|      0|    [[GDTCORRegistrar sharedInstance] appWillBackground:application];
   89|      0|  }
   90|      0|}
   91|       |
   92|      2|- (void)applicationWillEnterForeground:(NSNotification *)notification {
   93|      2|  GDTCORApplication *application = [GDTCORApplication sharedApplication];
   94|      2|  if ([[GDTCORTransformer sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
   95|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORTransformer that the app is foregrounding.");
   96|      0|    [[GDTCORTransformer sharedInstance] appWillForeground:application];
   97|      0|  }
   98|      2|  if ([[GDTCORStorage sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
   99|      2|    GDTCORLogDebug("%@", @"Signaling GDTCORStorage that the app is foregrounding.");
  100|      2|    [[GDTCORStorage sharedInstance] appWillForeground:application];
  101|      2|  }
  102|      2|  if ([[GDTCORUploadCoordinator sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
  103|      2|    GDTCORLogDebug("%@", @"Signaling GDTCORUploadCoordinator that the app is foregrounding.");
  104|      2|    [[GDTCORUploadCoordinator sharedInstance] appWillForeground:application];
  105|      2|  }
  106|      2|  if ([[GDTCORRegistrar sharedInstance] respondsToSelector:@selector(appWillForeground:)]) {
  107|      2|    GDTCORLogDebug("%@", @"Signaling GDTCORRegistrar that the app is foregrounding.");
  108|      2|    [[GDTCORRegistrar sharedInstance] appWillForeground:application];
  109|      2|  }
  110|      2|}
  111|       |
  112|      0|- (void)applicationWillTerminate:(NSNotification *)notification {
  113|      0|  GDTCORApplication *application = [GDTCORApplication sharedApplication];
  114|      0|  if ([[GDTCORTransformer sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  115|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORTransformer that the app is terminating.");
  116|      0|    [[GDTCORTransformer sharedInstance] appWillTerminate:application];
  117|      0|  }
  118|      0|  if ([[GDTCORStorage sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  119|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORStorage that the app is terminating.");
  120|      0|    [[GDTCORStorage sharedInstance] appWillTerminate:application];
  121|      0|  }
  122|      0|  if ([[GDTCORUploadCoordinator sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  123|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORUploadCoordinator that the app is terminating.");
  124|      0|    [[GDTCORUploadCoordinator sharedInstance] appWillTerminate:application];
  125|      0|  }
  126|      0|  if ([[GDTCORRegistrar sharedInstance] respondsToSelector:@selector(appWillTerminate:)]) {
  127|      0|    GDTCORLogDebug("%@", @"Signaling GDTCORRegistrar that the app is terminating.");
  128|      0|    [[GDTCORRegistrar sharedInstance] appWillTerminate:application];
  129|      0|  }
  130|      0|}
  131|       |
  132|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORPlatform.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <GoogleDataTransport/GDTCORPlatform.h>
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORAssert.h>
   20|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   21|       |#import <GoogleDataTransport/GDTCORReachability.h>
   22|       |
   23|       |#import "GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   24|       |
   25|       |#ifdef GDTCOR_VERSION
   26|       |#define STR(x) STR_EXPAND(x)
   27|       |#define STR_EXPAND(x) #x
   28|       |NSString *const kGDTCORVersion = @STR(GDTCOR_VERSION);
   29|       |#else
   30|       |NSString *const kGDTCORVersion = @"Unknown";
   31|       |#endif  // GDTCOR_VERSION
   32|       |
   33|       |const GDTCORBackgroundIdentifier GDTCORBackgroundIdentifierInvalid = 0;
   34|       |
   35|       |NSString *const kGDTCORApplicationDidEnterBackgroundNotification =
   36|       |    @"GDTCORApplicationDidEnterBackgroundNotification";
   37|       |
   38|       |NSString *const kGDTCORApplicationWillEnterForegroundNotification =
   39|       |    @"GDTCORApplicationWillEnterForegroundNotification";
   40|       |
   41|       |NSString *const kGDTCORApplicationWillTerminateNotification =
   42|       |    @"GDTCORApplicationWillTerminateNotification";
   43|       |
   44|     10|NSURL *GDTCORRootDirectory(void) {
   45|     10|  static NSURL *GDTPath;
   46|     10|  static dispatch_once_t onceToken;
   47|     10|  dispatch_once(&onceToken, ^{
   48|      1|    NSString *cachePath =
   49|      1|        NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];
   50|      1|    GDTPath =
   51|      1|        [NSURL fileURLWithPath:[NSString stringWithFormat:@"%@/google-sdks-events", cachePath]];
   52|      1|    GDTCORLogDebug("GDT's state will be saved to: %@", GDTPath);
   53|      1|  });
   54|     10|  return GDTPath;
   55|     10|}
   56|       |
   57|       |#if !TARGET_OS_WATCH
   58|      3|BOOL GDTCORReachabilityFlagsContainWWAN(SCNetworkReachabilityFlags flags) {
   59|      3|#if TARGET_OS_IOS
   60|      3|  return (flags & kSCNetworkReachabilityFlagsIsWWAN) == kSCNetworkReachabilityFlagsIsWWAN;
   61|       |#else
   62|       |  return NO;
   63|       |#endif  // TARGET_OS_IOS
   64|       |}
   65|       |#endif  // !TARGET_OS_WATCH
   66|       |
   67|      0|GDTCORNetworkType GDTCORNetworkTypeMessage() {
   68|      0|#if !TARGET_OS_WATCH
   69|      0|  SCNetworkReachabilityFlags reachabilityFlags = [GDTCORReachability currentFlags];
   70|      0|  if ((reachabilityFlags & kSCNetworkReachabilityFlagsReachable) ==
   71|      0|      kSCNetworkReachabilityFlagsReachable) {
   72|      0|    if (GDTCORReachabilityFlagsContainWWAN(reachabilityFlags)) {
   73|      0|      return GDTCORNetworkTypeMobile;
   74|      0|    } else {
   75|      0|      return GDTCORNetworkTypeWIFI;
   76|      0|    }
   77|      0|  }
   78|      0|#endif
   79|      0|  return GDTCORNetworkTypeUNKNOWN;
   80|      0|}
   81|       |
   82|      0|GDTCORNetworkMobileSubtype GDTCORNetworkMobileSubTypeMessage() {
   83|      0|#if TARGET_OS_IOS
   84|      0|  static NSDictionary<NSString *, NSNumber *> *CTRadioAccessTechnologyToNetworkSubTypeMessage;
   85|      0|  static CTTelephonyNetworkInfo *networkInfo;
   86|      0|  static dispatch_once_t onceToken;
   87|      0|  dispatch_once(&onceToken, ^{
   88|      0|    CTRadioAccessTechnologyToNetworkSubTypeMessage = @{
   89|      0|      CTRadioAccessTechnologyGPRS : @(GDTCORNetworkMobileSubtypeGPRS),
   90|      0|      CTRadioAccessTechnologyEdge : @(GDTCORNetworkMobileSubtypeEdge),
   91|      0|      CTRadioAccessTechnologyWCDMA : @(GDTCORNetworkMobileSubtypeWCDMA),
   92|      0|      CTRadioAccessTechnologyHSDPA : @(GDTCORNetworkMobileSubtypeHSDPA),
   93|      0|      CTRadioAccessTechnologyHSUPA : @(GDTCORNetworkMobileSubtypeHSUPA),
   94|      0|      CTRadioAccessTechnologyCDMA1x : @(GDTCORNetworkMobileSubtypeCDMA1x),
   95|      0|      CTRadioAccessTechnologyCDMAEVDORev0 : @(GDTCORNetworkMobileSubtypeCDMAEVDORev0),
   96|      0|      CTRadioAccessTechnologyCDMAEVDORevA : @(GDTCORNetworkMobileSubtypeCDMAEVDORevA),
   97|      0|      CTRadioAccessTechnologyCDMAEVDORevB : @(GDTCORNetworkMobileSubtypeCDMAEVDORevB),
   98|      0|      CTRadioAccessTechnologyeHRPD : @(GDTCORNetworkMobileSubtypeHRPD),
   99|      0|      CTRadioAccessTechnologyLTE : @(GDTCORNetworkMobileSubtypeLTE),
  100|      0|    };
  101|      0|    networkInfo = [[CTTelephonyNetworkInfo alloc] init];
  102|      0|  });
  103|      0|  NSString *networkCurrentRadioAccessTechnology;
  104|       |#if TARGET_OS_MACCATALYST
  105|       |  NSDictionary<NSString *, NSString *> *networkCurrentRadioAccessTechnologyDict =
  106|       |      networkInfo.serviceCurrentRadioAccessTechnology;
  107|       |  if (networkCurrentRadioAccessTechnologyDict.count) {
  108|       |    networkCurrentRadioAccessTechnology = networkCurrentRadioAccessTechnologyDict.allValues[0];
  109|       |  }
  110|       |#else  // TARGET_OS_MACCATALYST
  111|       |#if defined(__IPHONE_12_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 120000
  112|      0|  if (@available(iOS 12.0, *)) {
  113|      0|    NSDictionary<NSString *, NSString *> *networkCurrentRadioAccessTechnologyDict =
  114|      0|        networkInfo.serviceCurrentRadioAccessTechnology;
  115|      0|    if (networkCurrentRadioAccessTechnologyDict.count) {
  116|      0|      // In iOS 12, multiple radio technologies can be captured. We prefer not particular radio
  117|      0|      // tech to another, so we'll just return the first value in the dictionary.
  118|      0|      networkCurrentRadioAccessTechnology = networkCurrentRadioAccessTechnologyDict.allValues[0];
  119|      0|    }
  120|      0|  } else {
  121|       |#else   // defined(__IPHONE_12_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 120000
  122|       |  networkCurrentRadioAccessTechnology = networkInfo.currentRadioAccessTechnology;
  123|       |#endif  // // defined(__IPHONE_12_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 120000
  124|       |  }
  125|      0|#endif  // TARGET_OS_MACCATALYST
  126|      0|  if (networkCurrentRadioAccessTechnology) {
  127|      0|    NSNumber *networkMobileSubtype =
  128|      0|        CTRadioAccessTechnologyToNetworkSubTypeMessage[networkCurrentRadioAccessTechnology];
  129|      0|    return networkMobileSubtype.intValue;
  130|      0|  } else {
  131|      0|    return GDTCORNetworkMobileSubtypeUNKNOWN;
  132|      0|  }
  133|       |#else
  134|       |  return GDTCORNetworkMobileSubtypeUNKNOWN;
  135|       |#endif
  136|       |}
  137|       |
  138|       |NSData *_Nullable GDTCOREncodeArchive(id<NSSecureCoding> obj,
  139|       |                                      NSString *archivePath,
  140|      0|                                      NSError *_Nullable *error) {
  141|      0|  NSData *resultData;
  142|      0|#if (defined(__IPHONE_11_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 110000) || \
  143|      0|    (defined(__MAC_10_13) && MAC_OS_X_VERSION_MAX_ALLOWED >= 101300) ||      \
  144|      0|    (defined(__TVOS_11_0) && __TV_OS_VERSION_MAX_ALLOWED >= 110000) ||       \
  145|      0|    (defined(__WATCHOS_4_0) && __WATCH_OS_VERSION_MAX_ALLOWED >= 040000) ||  \
  146|      0|    (defined(TARGET_OS_MACCATALYST) && TARGET_OS_MACCATALYST)
  147|      0|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4, *)) {
  148|      0|    resultData = [NSKeyedArchiver archivedDataWithRootObject:obj
  149|      0|                                       requiringSecureCoding:YES
  150|      0|                                                       error:error];
  151|      0|    if (*error) {
  152|      0|      GDTCORLogDebug(@"Encoding an object failed: %@", *error);
  153|      0|      return nil;
  154|      0|    }
  155|      0|    if (archivePath) {
  156|      0|      BOOL result = [resultData writeToFile:archivePath options:NSDataWritingAtomic error:error];
  157|      0|      if (result == NO || *error) {
  158|      0|        GDTCORLogDebug(@"Attempt to write archive failed: URL:%@ error:%@", archivePath, *error);
  159|      0|      } else {
  160|      0|        GDTCORLogDebug(@"Writing archive succeeded: %@", archivePath);
  161|      0|      }
  162|      0|    }
  163|      0|  } else {
  164|      0|#endif
  165|      0|    BOOL result = NO;
  166|      0|    @try {
  167|      0|#pragma clang diagnostic push
  168|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  169|      0|      resultData = [NSKeyedArchiver archivedDataWithRootObject:obj];
  170|      0|#pragma clang diagnostic pop
  171|      0|      if (archivePath) {
  172|      0|        result = [resultData writeToFile:archivePath options:NSDataWritingAtomic error:error];
  173|      0|        if (result == NO || *error) {
  174|      0|          GDTCORLogDebug(@"Attempt to write archive failed: URL:%@ error:%@", archivePath, *error);
  175|      0|        } else {
  176|      0|          GDTCORLogDebug(@"Writing archive succeeded: %@", archivePath);
  177|      0|        }
  178|      0|      }
  179|      0|    } @catch (NSException *exception) {
  180|      0|      NSString *errorString =
  181|      0|          [NSString stringWithFormat:@"An exception was thrown during encoding: %@", exception];
  182|      0|      *error = [NSError errorWithDomain:NSCocoaErrorDomain
  183|      0|                                   code:-1
  184|      0|                               userInfo:@{NSLocalizedFailureReasonErrorKey : errorString}];
  185|      0|    }
  186|      0|    GDTCORLogDebug(@"Attempt to write archive. successful:%@ URL:%@ error:%@",
  187|      0|                   result ? @"YES" : @"NO", archivePath, *error);
  188|      0|  }
  189|      0|  return resultData;
  190|      0|}
  191|       |
  192|       |id<NSSecureCoding> _Nullable GDTCORDecodeArchive(Class archiveClass,
  193|       |                                                 NSString *_Nullable archivePath,
  194|       |                                                 NSData *_Nullable archiveData,
  195|      8|                                                 NSError *_Nullable *error) {
  196|      8|  id<NSSecureCoding> unarchivedObject = nil;
  197|      8|#if (defined(__IPHONE_11_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 110000) || \
  198|      8|    (defined(__MAC_10_13) && MAC_OS_X_VERSION_MAX_ALLOWED >= 101300) ||      \
  199|      8|    (defined(__TVOS_11_0) && __TV_OS_VERSION_MAX_ALLOWED >= 110000) ||       \
  200|      8|    (defined(__WATCHOS_4_0) && __WATCH_OS_VERSION_MAX_ALLOWED >= 040000) ||  \
  201|      8|    (defined(TARGET_OS_MACCATALYST) && TARGET_OS_MACCATALYST)
  202|      8|  if (@available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4, *)) {
  203|      8|    NSData *data = archiveData ? archiveData : [NSData dataWithContentsOfFile:archivePath];
  204|      8|    if (data) {
  205|      0|      unarchivedObject = [NSKeyedUnarchiver unarchivedObjectOfClass:archiveClass
  206|      0|                                                           fromData:data
  207|      0|                                                              error:error];
  208|      0|    }
  209|      8|  } else {
  210|      0|#endif
  211|      0|    @try {
  212|      0|      NSData *archivedData =
  213|      0|          archiveData ? archiveData : [NSData dataWithContentsOfFile:archivePath];
  214|      0|#pragma clang diagnostic push
  215|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  216|      0|      unarchivedObject = [NSKeyedUnarchiver unarchiveObjectWithData:archivedData];
  217|      0|#pragma clang diagnostic pop
  218|      0|    } @catch (NSException *exception) {
  219|      0|      NSString *errorString =
  220|      0|          [NSString stringWithFormat:@"An exception was thrown during encoding: %@", exception];
  221|      0|      *error = [NSError errorWithDomain:NSCocoaErrorDomain
  222|      0|                                   code:-1
  223|      0|                               userInfo:@{NSLocalizedFailureReasonErrorKey : errorString}];
  224|      0|    }
  225|      0|  }
  226|      8|  return unarchivedObject;
  227|      8|}
  228|       |
  229|       |@interface GDTCORApplication ()
  230|       |/**
  231|       | Private flag to match the existing `readonly` public flag. This will be accurate for all platforms,
  232|       | since we handle each platform's lifecycle notifications separately.
  233|       | */
  234|       |@property(atomic, readwrite) BOOL isRunningInBackground;
  235|       |
  236|       |@end
  237|       |
  238|       |@implementation GDTCORApplication
  239|       |
  240|      1|+ (void)load {
  241|      1|  GDTCORLogDebug(
  242|      1|      "%@", @"GDT is initializing. Please note that if you quit the app via the "
  243|      1|             "debugger and not through a lifecycle event, event data will remain on disk but "
  244|      1|             "storage won't have a reference to them since the singleton wasn't saved to disk.");
  245|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  246|      1|  // If this asserts, please file a bug at https://github.com/firebase/firebase-ios-sdk/issues.
  247|      1|  GDTCORFatalAssert(
  248|      1|      GDTCORBackgroundIdentifierInvalid == UIBackgroundTaskInvalid,
  249|      1|      @"GDTCORBackgroundIdentifierInvalid and UIBackgroundTaskInvalid should be the same.");
  250|      1|#endif
  251|      1|  [self sharedApplication];
  252|      1|}
  253|       |
  254|     17|+ (nullable GDTCORApplication *)sharedApplication {
  255|     17|  static GDTCORApplication *application;
  256|     17|  static dispatch_once_t onceToken;
  257|     17|  dispatch_once(&onceToken, ^{
  258|      1|    application = [[GDTCORApplication alloc] init];
  259|      1|  });
  260|     17|  return application;
  261|     17|}
  262|       |
  263|      1|- (instancetype)init {
  264|      1|  self = [super init];
  265|      1|  if (self) {
  266|      1|    // This class will be instantiated in the foreground.
  267|      1|    _isRunningInBackground = NO;
  268|      1|
  269|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  270|      1|    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
  271|      1|    [notificationCenter addObserver:self
  272|      1|                           selector:@selector(iOSApplicationDidEnterBackground:)
  273|      1|                               name:UIApplicationDidEnterBackgroundNotification
  274|      1|                             object:nil];
  275|      1|    [notificationCenter addObserver:self
  276|      1|                           selector:@selector(iOSApplicationWillEnterForeground:)
  277|      1|                               name:UIApplicationWillEnterForegroundNotification
  278|      1|                             object:nil];
  279|      1|
  280|      1|    NSString *name = UIApplicationWillTerminateNotification;
  281|      1|    [notificationCenter addObserver:self
  282|      1|                           selector:@selector(iOSApplicationWillTerminate:)
  283|      1|                               name:name
  284|      1|                             object:nil];
  285|      1|
  286|      1|#if defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000
  287|      1|    if (@available(iOS 13, tvOS 13.0, *)) {
  288|      1|      [notificationCenter addObserver:self
  289|      1|                             selector:@selector(iOSApplicationWillEnterForeground:)
  290|      1|                                 name:UISceneWillEnterForegroundNotification
  291|      1|                               object:nil];
  292|      1|      [notificationCenter addObserver:self
  293|      1|                             selector:@selector(iOSApplicationDidEnterBackground:)
  294|      1|                                 name:UISceneWillDeactivateNotification
  295|      1|                               object:nil];
  296|      1|    }
  297|      1|#endif  // defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= 130000
  298|      1|
  299|       |#elif TARGET_OS_OSX
  300|       |    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
  301|       |    [notificationCenter addObserver:self
  302|       |                           selector:@selector(macOSApplicationWillTerminate:)
  303|       |                               name:NSApplicationWillTerminateNotification
  304|       |                             object:nil];
  305|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  306|       |  }
  307|      1|  return self;
  308|      1|}
  309|       |
  310|       |- (GDTCORBackgroundIdentifier)beginBackgroundTaskWithName:(NSString *)name
  311|      5|                                        expirationHandler:(void (^)(void))handler {
  312|      5|  GDTCORBackgroundIdentifier bgID =
  313|      5|      [[self sharedApplicationForBackgroundTask] beginBackgroundTaskWithName:name
  314|      5|                                                           expirationHandler:handler];
  315|      5|#if !NDEBUG
  316|      5|  if (bgID != GDTCORBackgroundIdentifierInvalid) {
  317|      5|    GDTCORLogDebug("Creating background task with name:%@ bgID:%ld", name, (long)bgID);
  318|      5|  }
  319|      5|#endif  // !NDEBUG
  320|      5|  return bgID;
  321|      5|}
  322|       |
  323|      4|- (void)endBackgroundTask:(GDTCORBackgroundIdentifier)bgID {
  324|      4|  if (bgID != GDTCORBackgroundIdentifierInvalid) {
  325|      4|    GDTCORLogDebug("Ending background task with ID:%ld was successful", (long)bgID);
  326|      4|    [[self sharedApplicationForBackgroundTask] endBackgroundTask:bgID];
  327|      4|    return;
  328|      4|  }
  329|      4|}
  330|       |
  331|       |#pragma mark - App environment helpers
  332|       |
  333|      9|- (BOOL)isAppExtension {
  334|      9|#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_WATCH
  335|      9|  BOOL appExtension = [[[NSBundle mainBundle] bundlePath] hasSuffix:@".appex"];
  336|      9|  return appExtension;
  337|       |#elif TARGET_OS_OSX
  338|       |  return NO;
  339|       |#endif
  340|       |}
  341|       |
  342|       |/** Returns a UIApplication instance if on the appropriate platform.
  343|       | *
  344|       | * @return The shared UIApplication if on the appropriate platform.
  345|       | */
  346|       |#if TARGET_OS_IOS || TARGET_OS_TV
  347|      9|- (nullable UIApplication *)sharedApplicationForBackgroundTask {
  348|       |#else
  349|       |- (nullable id)sharedApplicationForBackgroundTask {
  350|       |#endif
  351|      9|  if ([self isAppExtension]) {
  352|      0|    return nil;
  353|      0|  }
  354|      9|  id sharedApplication = nil;
  355|      9|  Class uiApplicationClass = NSClassFromString(@"UIApplication");
  356|      9|  if (uiApplicationClass &&
  357|      9|      [uiApplicationClass respondsToSelector:(NSSelectorFromString(@"sharedApplication"))]) {
  358|      9|    sharedApplication = [uiApplicationClass sharedApplication];
  359|      9|  }
  360|      9|  return sharedApplication;
  361|      9|}
  362|       |
  363|       |#pragma mark - UIApplicationDelegate
  364|       |
  365|       |#if TARGET_OS_IOS || TARGET_OS_TV
  366|      0|- (void)iOSApplicationDidEnterBackground:(NSNotification *)notif {
  367|      0|  _isRunningInBackground = YES;
  368|      0|
  369|      0|  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  370|      0|  GDTCORLogDebug("%@", @"GDTCORPlatform is sending a notif that the app is backgrounding.");
  371|      0|  [notifCenter postNotificationName:kGDTCORApplicationDidEnterBackgroundNotification object:nil];
  372|      0|}
  373|       |
  374|      2|- (void)iOSApplicationWillEnterForeground:(NSNotification *)notif {
  375|      2|  _isRunningInBackground = NO;
  376|      2|
  377|      2|  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  378|      2|  GDTCORLogDebug("%@", @"GDTCORPlatform is sending a notif that the app is foregrounding.");
  379|      2|  [notifCenter postNotificationName:kGDTCORApplicationWillEnterForegroundNotification object:nil];
  380|      2|}
  381|       |
  382|      0|- (void)iOSApplicationWillTerminate:(NSNotification *)notif {
  383|      0|  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  384|      0|  GDTCORLogDebug("%@", @"GDTCORPlatform is sending a notif that the app is terminating.");
  385|      0|  [notifCenter postNotificationName:kGDTCORApplicationWillTerminateNotification object:nil];
  386|      0|}
  387|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
  388|       |
  389|       |#pragma mark - NSApplicationDelegate
  390|       |
  391|       |#if TARGET_OS_OSX
  392|       |- (void)macOSApplicationWillTerminate:(NSNotification *)notif {
  393|       |  NSNotificationCenter *notifCenter = [NSNotificationCenter defaultCenter];
  394|       |  GDTCORLogDebug("%@", @"GDTCORPlatform is sending a notif that the app is terminating.");
  395|       |  [notifCenter postNotificationName:kGDTCORApplicationWillTerminateNotification object:nil];
  396|       |}
  397|       |#endif  // TARGET_OS_OSX
  398|       |
  399|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORReachability.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORReachability.h"
   18|       |#import "GDTCORLibrary/Private/GDTCORReachability_Private.h"
   19|       |#if !TARGET_OS_WATCH
   20|       |
   21|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   22|       |
   23|       |#import <netinet/in.h>
   24|       |
   25|       |/** Sets the _callbackFlag ivar whenever the network changes.
   26|       | *
   27|       | * @param reachability The reachability object calling back.
   28|       | * @param flags The new flag values.
   29|       | * @param info Any data that might be passed in by the callback.
   30|       | */
   31|       |static void GDTCORReachabilityCallback(SCNetworkReachabilityRef reachability,
   32|       |                                       SCNetworkReachabilityFlags flags,
   33|       |                                       void *info);
   34|       |
   35|       |@implementation GDTCORReachability {
   36|       |  /** The reachability object. */
   37|       |  SCNetworkReachabilityRef _reachabilityRef;
   38|       |
   39|       |  /** The queue on which callbacks and all work will occur. */
   40|       |  dispatch_queue_t _reachabilityQueue;
   41|       |
   42|       |  /** Flags specified by reachability callbacks. */
   43|       |  SCNetworkConnectionFlags _callbackFlags;
   44|       |}
   45|       |
   46|      1|+ (void)load {
   47|      1|  [self sharedInstance];
   48|      1|}
   49|       |
   50|      7|+ (instancetype)sharedInstance {
   51|      7|  static GDTCORReachability *sharedInstance;
   52|      7|  static dispatch_once_t onceToken;
   53|      7|  dispatch_once(&onceToken, ^{
   54|      1|    sharedInstance = [[GDTCORReachability alloc] init];
   55|      1|  });
   56|      7|  return sharedInstance;
   57|      7|}
   58|       |
   59|      3|+ (SCNetworkReachabilityFlags)currentFlags {
   60|      3|  __block SCNetworkReachabilityFlags currentFlags;
   61|      3|  dispatch_sync([GDTCORReachability sharedInstance] -> _reachabilityQueue, ^{
   62|      3|    GDTCORReachability *reachability = [GDTCORReachability sharedInstance];
   63|      3|    currentFlags =
   64|      3|        reachability->_callbackFlags ? reachability->_callbackFlags : reachability->_flags;
   65|      3|    GDTCORLogDebug("Initial reachability flags determined: %d", currentFlags);
   66|      3|  });
   67|      3|  return currentFlags;
   68|      3|}
   69|       |
   70|      1|- (instancetype)init {
   71|      1|  self = [super init];
   72|      1|  if (self) {
   73|      1|    struct sockaddr_in zeroAddress;
   74|      1|    bzero(&zeroAddress, sizeof(zeroAddress));
   75|      1|    zeroAddress.sin_len = sizeof(zeroAddress);
   76|      1|    zeroAddress.sin_family = AF_INET;
   77|      1|
   78|      1|    _reachabilityQueue =
   79|      1|        dispatch_queue_create("com.google.GDTCORReachability", DISPATCH_QUEUE_SERIAL);
   80|      1|    _reachabilityRef = SCNetworkReachabilityCreateWithAddress(
   81|      1|        kCFAllocatorDefault, (const struct sockaddr *)&zeroAddress);
   82|      1|    Boolean success = SCNetworkReachabilitySetDispatchQueue(_reachabilityRef, _reachabilityQueue);
   83|      1|    if (!success) {
   84|      0|      GDTCORLogWarning(GDTCORMCWReachabilityFailed, @"%@", @"The reachability queue wasn't set.");
   85|      0|    }
   86|      1|    success = SCNetworkReachabilitySetCallback(_reachabilityRef, GDTCORReachabilityCallback, NULL);
   87|      1|    if (!success) {
   88|      0|      GDTCORLogWarning(GDTCORMCWReachabilityFailed, @"%@",
   89|      0|                       @"The reachability callback wasn't set.");
   90|      0|    }
   91|      1|
   92|      1|    // Get the initial set of flags.
   93|      1|    dispatch_async(_reachabilityQueue, ^{
   94|      1|      Boolean valid = SCNetworkReachabilityGetFlags(self->_reachabilityRef, &self->_flags);
   95|      1|      if (!valid) {
   96|      0|        GDTCORLogDebug("%@", @"Determining reachability failed.");
   97|      0|        self->_flags = 0;
   98|      0|      }
   99|      1|    });
  100|      1|  }
  101|      1|  return self;
  102|      1|}
  103|       |
  104|      0|- (void)setCallbackFlags:(SCNetworkReachabilityFlags)flags {
  105|      0|  if (_callbackFlags != flags) {
  106|      0|    self->_callbackFlags = flags;
  107|      0|  }
  108|      0|}
  109|       |
  110|       |@end
  111|       |
  112|       |static void GDTCORReachabilityCallback(SCNetworkReachabilityRef reachability,
  113|       |                                       SCNetworkReachabilityFlags flags,
  114|      0|                                       void *info) {
  115|      0|  GDTCORLogDebug("Reachability changed, new flags: %d", flags);
  116|      0|  [[GDTCORReachability sharedInstance] setCallbackFlags:flags];
  117|      0|}
  118|       |
  119|       |#endif

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORRegistrar.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORRegistrar.h"
   18|       |#import "GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   19|       |
   20|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   21|       |
   22|       |@implementation GDTCORRegistrar {
   23|       |  /** Backing ivar for targetToUploader property. */
   24|       |  NSMutableDictionary<NSNumber *, id<GDTCORUploader>> *_targetToUploader;
   25|       |
   26|       |  /** Backing ivar for targetToPrioritizer property. */
   27|       |  NSMutableDictionary<NSNumber *, id<GDTCORPrioritizer>> *_targetToPrioritizer;
   28|       |}
   29|       |
   30|     13|+ (instancetype)sharedInstance {
   31|     13|  static GDTCORRegistrar *sharedInstance;
   32|     13|  static dispatch_once_t onceToken;
   33|     13|  dispatch_once(&onceToken, ^{
   34|      1|    sharedInstance = [[GDTCORRegistrar alloc] init];
   35|      1|  });
   36|     13|  return sharedInstance;
   37|     13|}
   38|       |
   39|      1|- (instancetype)init {
   40|      1|  self = [super init];
   41|      1|  if (self) {
   42|      1|    _registrarQueue = dispatch_queue_create("com.google.GDTCORRegistrar", DISPATCH_QUEUE_SERIAL);
   43|      1|    _targetToPrioritizer = [[NSMutableDictionary alloc] init];
   44|      1|    _targetToUploader = [[NSMutableDictionary alloc] init];
   45|      1|  }
   46|      1|  return self;
   47|      1|}
   48|       |
   49|      3|- (void)registerUploader:(id<GDTCORUploader>)backend target:(GDTCORTarget)target {
   50|      3|  __weak GDTCORRegistrar *weakSelf = self;
   51|      3|  dispatch_async(_registrarQueue, ^{
   52|      3|    GDTCORRegistrar *strongSelf = weakSelf;
   53|      3|    if (strongSelf) {
   54|      3|      GDTCORLogDebug("Registered an uploader: %@ for target:%ld", backend, (long)target);
   55|      3|      strongSelf->_targetToUploader[@(target)] = backend;
   56|      3|    }
   57|      3|  });
   58|      3|}
   59|       |
   60|      3|- (void)registerPrioritizer:(id<GDTCORPrioritizer>)prioritizer target:(GDTCORTarget)target {
   61|      3|  __weak GDTCORRegistrar *weakSelf = self;
   62|      3|  dispatch_async(_registrarQueue, ^{
   63|      3|    GDTCORRegistrar *strongSelf = weakSelf;
   64|      3|    if (strongSelf) {
   65|      3|      GDTCORLogDebug("Registered a prioritizer: %@ for target:%ld", prioritizer, (long)target);
   66|      3|      strongSelf->_targetToPrioritizer[@(target)] = prioritizer;
   67|      3|    }
   68|      3|  });
   69|      3|}
   70|       |
   71|     11|- (NSMutableDictionary<NSNumber *, id<GDTCORUploader>> *)targetToUploader {
   72|     11|  __block NSMutableDictionary<NSNumber *, id<GDTCORUploader>> *targetToUploader;
   73|     11|  __weak GDTCORRegistrar *weakSelf = self;
   74|     11|  dispatch_sync(_registrarQueue, ^{
   75|     11|    GDTCORRegistrar *strongSelf = weakSelf;
   76|     11|    if (strongSelf) {
   77|     11|      targetToUploader = strongSelf->_targetToUploader;
   78|     11|    }
   79|     11|  });
   80|     11|  return targetToUploader;
   81|     11|}
   82|       |
   83|      9|- (NSMutableDictionary<NSNumber *, id<GDTCORPrioritizer>> *)targetToPrioritizer {
   84|      9|  __block NSMutableDictionary<NSNumber *, id<GDTCORPrioritizer>> *targetToPrioritizer;
   85|      9|  __weak GDTCORRegistrar *weakSelf = self;
   86|      9|  dispatch_sync(_registrarQueue, ^{
   87|      9|    GDTCORRegistrar *strongSelf = weakSelf;
   88|      9|    if (strongSelf) {
   89|      9|      targetToPrioritizer = strongSelf->_targetToPrioritizer;
   90|      9|    }
   91|      9|  });
   92|      9|  return targetToPrioritizer;
   93|      9|}
   94|       |
   95|       |#pragma mark - GDTCORLifecycleProtocol
   96|       |
   97|      0|- (void)appWillBackground:(nonnull GDTCORApplication *)app {
   98|      0|  dispatch_async(_registrarQueue, ^{
   99|      0|    for (id<GDTCORUploader> uploader in [self->_targetToUploader allValues]) {
  100|      0|      if ([uploader respondsToSelector:@selector(appWillBackground:)]) {
  101|      0|        [uploader appWillBackground:app];
  102|      0|      }
  103|      0|    }
  104|      0|    for (id<GDTCORPrioritizer> prioritizer in [self->_targetToPrioritizer allValues]) {
  105|      0|      if ([prioritizer respondsToSelector:@selector(appWillBackground:)]) {
  106|      0|        [prioritizer appWillBackground:app];
  107|      0|      }
  108|      0|    }
  109|      0|  });
  110|      0|}
  111|       |
  112|      2|- (void)appWillForeground:(nonnull GDTCORApplication *)app {
  113|      2|  dispatch_async(_registrarQueue, ^{
  114|      6|    for (id<GDTCORUploader> uploader in [self->_targetToUploader allValues]) {
  115|      6|      if ([uploader respondsToSelector:@selector(appWillForeground:)]) {
  116|      0|        [uploader appWillForeground:app];
  117|      0|      }
  118|      6|    }
  119|      6|    for (id<GDTCORPrioritizer> prioritizer in [self->_targetToPrioritizer allValues]) {
  120|      6|      if ([prioritizer respondsToSelector:@selector(appWillForeground:)]) {
  121|      6|        [prioritizer appWillForeground:app];
  122|      6|      }
  123|      6|    }
  124|      2|  });
  125|      2|}
  126|       |
  127|      0|- (void)appWillTerminate:(nonnull GDTCORApplication *)app {
  128|      0|  dispatch_sync(_registrarQueue, ^{
  129|      0|    for (id<GDTCORUploader> uploader in [self->_targetToUploader allValues]) {
  130|      0|      if ([uploader respondsToSelector:@selector(appWillTerminate:)]) {
  131|      0|        [uploader appWillTerminate:app];
  132|      0|      }
  133|      0|    }
  134|      0|    for (id<GDTCORPrioritizer> prioritizer in [self->_targetToPrioritizer allValues]) {
  135|      0|      if ([prioritizer respondsToSelector:@selector(appWillTerminate:)]) {
  136|      0|        [prioritizer appWillTerminate:app];
  137|      0|      }
  138|      0|    }
  139|      0|  });
  140|      0|}
  141|       |
  142|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORStorage.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Private/GDTCORStorage.h"
   18|       |#import "GDTCORLibrary/Private/GDTCORStorage_Private.h"
   19|       |
   20|       |#import <GoogleDataTransport/GDTCORAssert.h>
   21|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   22|       |#import <GoogleDataTransport/GDTCOREvent.h>
   23|       |#import <GoogleDataTransport/GDTCORLifecycle.h>
   24|       |#import <GoogleDataTransport/GDTCORPrioritizer.h>
   25|       |
   26|       |#import "GDTCORLibrary/Private/GDTCOREvent_Private.h"
   27|       |#import "GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   28|       |#import "GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   29|       |
   30|       |@implementation GDTCORStorage
   31|       |
   32|      2|+ (NSString *)archivePath {
   33|      2|  static NSString *archivePath;
   34|      2|  static dispatch_once_t onceToken;
   35|      2|  dispatch_once(&onceToken, ^{
   36|      1|    archivePath = [GDTCORRootDirectory() URLByAppendingPathComponent:@"GDTCORStorageArchive"].path;
   37|      1|  });
   38|      2|  return archivePath;
   39|      2|}
   40|       |
   41|     10|+ (instancetype)sharedInstance {
   42|     10|  static GDTCORStorage *sharedStorage;
   43|     10|  static dispatch_once_t onceToken;
   44|     10|  dispatch_once(&onceToken, ^{
   45|      1|    sharedStorage = [[GDTCORStorage alloc] init];
   46|      1|  });
   47|     10|  return sharedStorage;
   48|     10|}
   49|       |
   50|      1|- (instancetype)init {
   51|      1|  self = [super init];
   52|      1|  if (self) {
   53|      1|    _storageQueue = dispatch_queue_create("com.google.GDTCORStorage", DISPATCH_QUEUE_SERIAL);
   54|      1|    _targetToEventSet = [[NSMutableDictionary alloc] init];
   55|      1|    _storedEvents = [[NSMutableOrderedSet alloc] init];
   56|      1|    _uploadCoordinator = [GDTCORUploadCoordinator sharedInstance];
   57|      1|  }
   58|      1|  return self;
   59|      1|}
   60|       |
   61|       |- (void)storeEvent:(GDTCOREvent *)event
   62|      2|        onComplete:(void (^_Nullable)(BOOL wasWritten, NSError *error))completion {
   63|      2|  GDTCORLogDebug("Saving event: %@", event);
   64|      2|  if (event == nil) {
   65|      0|    GDTCORLogDebug("%@", @"The event was nil, so it was not saved.");
   66|      0|    return;
   67|      0|  }
   68|      2|  BOOL hadOriginalCompletion = completion != nil;
   69|      2|  if (!completion) {
   70|      2|    completion = ^(BOOL wasWritten, NSError *error) {
   71|      2|      GDTCORLogDebug(@"event %@ stored. success:%@ error:%@", event, wasWritten ? @"YES" : @"NO",
   72|      2|                     error);
   73|      2|    };
   74|      2|  }
   75|      2|
   76|      2|  [self createEventDirectoryIfNotExists];
   77|      2|
   78|      2|  __block GDTCORBackgroundIdentifier bgID = GDTCORBackgroundIdentifierInvalid;
   79|      2|  bgID = [[GDTCORApplication sharedApplication]
   80|      2|      beginBackgroundTaskWithName:@"GDTStorage"
   81|      2|                expirationHandler:^{
   82|      0|                  // End the background task if it's still valid.
   83|      0|                  [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
   84|      0|                  bgID = GDTCORBackgroundIdentifierInvalid;
   85|      0|                }];
   86|      2|
   87|      2|  dispatch_async(_storageQueue, ^{
   88|      2|    // Check that a backend implementation is available for this target.
   89|      2|    NSInteger target = event.target;
   90|      2|
   91|      2|    // Check that a prioritizer is available for this target.
   92|      2|    id<GDTCORPrioritizer> prioritizer =
   93|      2|        [GDTCORRegistrar sharedInstance].targetToPrioritizer[@(target)];
   94|      2|    GDTCORAssert(prioritizer, @"There's no prioritizer registered for the given target. Are you "
   95|      2|                              @"sure you've added the support library for the backend you need?");
   96|      2|
   97|      2|    // Write the transport bytes to disk, get a filename.
   98|      2|    GDTCORAssert([event.dataObject transportBytes],
   99|      2|                 @"The event should have been serialized to bytes");
  100|      2|    NSError *error = nil;
  101|      2|    NSURL *eventFile = [self saveEventBytesToDisk:event eventHash:event.hash error:&error];
  102|      2|    GDTCORLogDebug("Event saved to disk: %@", eventFile);
  103|      2|    completion(eventFile != nil, error);
  104|      2|
  105|      2|    // Add event to tracking collections.
  106|      2|    [self addEventToTrackingCollections:event];
  107|      2|
  108|      2|    // Have the prioritizer prioritize the event and save state if there was an onComplete block.
  109|      2|    [prioritizer prioritizeEvent:event];
  110|      2|    if (hadOriginalCompletion && [prioritizer respondsToSelector:@selector(saveState)]) {
  111|      0|      [prioritizer saveState];
  112|      0|      GDTCORLogDebug(@"Prioritizer %@ has saved state due to an event's onComplete block.",
  113|      0|                     prioritizer);
  114|      0|    }
  115|      2|
  116|      2|    // Check the QoS, if it's high priority, notify the target that it has a high priority event.
  117|      2|    if (event.qosTier == GDTCOREventQoSFast) {
  118|      0|      [self.uploadCoordinator forceUploadForTarget:target];
  119|      0|    }
  120|      2|
  121|      2|    // Write state to disk if there was an onComplete block or if we're in the background.
  122|      2|    if (hadOriginalCompletion || [[GDTCORApplication sharedApplication] isRunningInBackground]) {
  123|      0|      if (hadOriginalCompletion) {
  124|      0|        GDTCORLogDebug("%@", @"Saving storage state because a completion block was passed.");
  125|      0|      } else {
  126|      0|        GDTCORLogDebug("%@", @"Saving storage state because the app is running in the background");
  127|      0|      }
  128|      0|      NSError *error;
  129|      0|      GDTCOREncodeArchive(self, [GDTCORStorage archivePath], &error);
  130|      0|      if (error) {
  131|      0|        GDTCORLogDebug(@"Serializing GDTCORStorage to an archive failed: %@", error);
  132|      0|      }
  133|      0|    }
  134|      2|
  135|      2|    // Cancel or end the associated background task if it's still valid.
  136|      2|    [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
  137|      2|    bgID = GDTCORBackgroundIdentifierInvalid;
  138|      2|    GDTCORLogDebug("Event %@ is stored. There are %ld events stored on disk", event,
  139|      2|                   (unsigned long)self->_storedEvents.count);
  140|      2|  });
  141|      2|}
  142|       |
  143|      3|- (void)removeEvents:(NSSet<GDTCOREvent *> *)events {
  144|      3|  NSSet<GDTCOREvent *> *eventsToRemove = [events copy];
  145|      3|  dispatch_async(_storageQueue, ^{
  146|      3|    for (GDTCOREvent *event in eventsToRemove) {
  147|      0|      // Remove from disk, first and foremost.
  148|      0|      NSError *error;
  149|      0|      if (event.fileURL) {
  150|      0|        NSURL *fileURL = event.fileURL;
  151|      0|        [[NSFileManager defaultManager] removeItemAtURL:fileURL error:&error];
  152|      0|        GDTCORAssert(error == nil, @"There was an error removing an event file: %@", error);
  153|      0|        GDTCORLogDebug("Removed event from disk: %@", fileURL);
  154|      0|      }
  155|      0|
  156|      0|      // Remove from the tracking collections.
  157|      0|      [self.storedEvents removeObject:event];
  158|      0|      [self.targetToEventSet[@(event.target)] removeObject:event];
  159|      0|    }
  160|      3|  });
  161|      3|}
  162|       |
  163|       |#pragma mark - Private helper methods
  164|       |
  165|       |/** Creates the storage directory if it does not exist. */
  166|      2|- (void)createEventDirectoryIfNotExists {
  167|      2|  NSError *error;
  168|      2|  BOOL result = [[NSFileManager defaultManager] createDirectoryAtURL:GDTCORRootDirectory()
  169|      2|                                         withIntermediateDirectories:YES
  170|      2|                                                          attributes:0
  171|      2|                                                               error:&error];
  172|      2|  if (!result || error) {
  173|      0|    GDTCORLogError(GDTCORMCEDirectoryCreationError, @"Error creating the directory: %@", error);
  174|      0|  }
  175|      2|}
  176|       |
  177|       |/** Saves the event's dataObject to a file using NSData mechanisms.
  178|       | *
  179|       | * @note This method should only be called from a method within a block on _storageQueue to maintain
  180|       | * thread safety.
  181|       | *
  182|       | * @param event The event.
  183|       | * @param eventHash The hash value of the event.
  184|       | * @return The filename
  185|       | */
  186|       |- (NSURL *)saveEventBytesToDisk:(GDTCOREvent *)event
  187|       |                      eventHash:(NSUInteger)eventHash
  188|      2|                          error:(NSError **)error {
  189|      2|  NSString *eventFileName = [NSString stringWithFormat:@"event-%lu", (unsigned long)eventHash];
  190|      2|  NSError *writingError;
  191|      2|  [event writeToGDTPath:eventFileName error:&writingError];
  192|      2|  if (writingError) {
  193|      0|    GDTCORLogDebug(@"There was an error saving an event to disk: %@", writingError);
  194|      0|  }
  195|      2|  return event.fileURL;
  196|      2|}
  197|       |
  198|       |/** Adds the event to internal tracking collections.
  199|       | *
  200|       | * @note This method should only be called from a method within a block on _storageQueue to maintain
  201|       | * thread safety.
  202|       | *
  203|       | * @param event The event to track.
  204|       | */
  205|      2|- (void)addEventToTrackingCollections:(GDTCOREvent *)event {
  206|      2|  [_storedEvents addObject:event];
  207|      2|  NSNumber *target = @(event.target);
  208|      2|  NSMutableSet<GDTCOREvent *> *events = self.targetToEventSet[target];
  209|      2|  events = events ? events : [[NSMutableSet alloc] init];
  210|      2|  [events addObject:event];
  211|      2|  _targetToEventSet[target] = events;
  212|      2|}
  213|       |
  214|       |#pragma mark - GDTCORLifecycleProtocol
  215|       |
  216|      2|- (void)appWillForeground:(GDTCORApplication *)app {
  217|      2|  NSError *error;
  218|      2|  GDTCORDecodeArchive([GDTCORStorage class], [GDTCORStorage archivePath], nil, &error);
  219|      2|  if (error) {
  220|      0|    GDTCORLogDebug(@"Deserializing GDTCORStorage from an archive failed: %@", error);
  221|      0|  }
  222|      2|}
  223|       |
  224|      0|- (void)appWillBackground:(GDTCORApplication *)app {
  225|      0|  dispatch_async(_storageQueue, ^{
  226|      0|    // Immediately request a background task to run until the end of the current queue of work, and
  227|      0|    // cancel it once the work is done.
  228|      0|    __block GDTCORBackgroundIdentifier bgID =
  229|      0|        [app beginBackgroundTaskWithName:@"GDTStorage"
  230|      0|                       expirationHandler:^{
  231|      0|                         [app endBackgroundTask:bgID];
  232|      0|                         bgID = GDTCORBackgroundIdentifierInvalid;
  233|      0|                       }];
  234|      0|    NSError *error;
  235|      0|    GDTCOREncodeArchive(self, [GDTCORStorage archivePath], &error);
  236|      0|    if (error) {
  237|      0|      GDTCORLogDebug(@"Serializing GDTCORStorage to an archive failed: %@", error);
  238|      0|    } else {
  239|      0|      GDTCORLogDebug(@"Serialized GDTCORStorage to %@", [GDTCORStorage archivePath]);
  240|      0|    }
  241|      0|
  242|      0|    // End the background task if it's still valid.
  243|      0|    [app endBackgroundTask:bgID];
  244|      0|    bgID = GDTCORBackgroundIdentifierInvalid;
  245|      0|  });
  246|      0|}
  247|       |
  248|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
  249|      0|  dispatch_sync(_storageQueue, ^{
  250|      0|    NSError *error;
  251|      0|    GDTCOREncodeArchive(self, [GDTCORStorage archivePath], &error);
  252|      0|    if (error) {
  253|      0|      GDTCORLogDebug(@"Serializing GDTCORStorage to an archive failed: %@", error);
  254|      0|    } else {
  255|      0|      GDTCORLogDebug(@"Serialized GDTCORStorage to %@", [GDTCORStorage archivePath]);
  256|      0|    }
  257|      0|  });
  258|      0|}
  259|       |
  260|       |#pragma mark - NSSecureCoding
  261|       |
  262|       |/** The NSKeyedCoder key for the storedEvents property. */
  263|       |static NSString *const kGDTCORStorageStoredEventsKey = @"GDTCORStorageStoredEventsKey";
  264|       |
  265|       |/** The NSKeyedCoder key for the targetToEventSet property. */
  266|       |static NSString *const kGDTCORStorageTargetToEventSetKey = @"GDTCORStorageTargetToEventSetKey";
  267|       |
  268|       |/** The NSKeyedCoder key for the uploadCoordinator property. */
  269|       |static NSString *const kGDTCORStorageUploadCoordinatorKey = @"GDTCORStorageUploadCoordinatorKey";
  270|       |
  271|      0|+ (BOOL)supportsSecureCoding {
  272|      0|  return YES;
  273|      0|}
  274|       |
  275|      0|- (instancetype)initWithCoder:(NSCoder *)aDecoder {
  276|      0|  // Sets a global translation mapping to decode GDTCORStoredEvent objects encoded as instances of
  277|      0|  // GDTCOREvent instead.
  278|      0|  [NSKeyedUnarchiver setClass:[GDTCOREvent class] forClassName:@"GDTCORStoredEvent"];
  279|      0|
  280|      0|  // Create the singleton and populate its ivars.
  281|      0|  GDTCORStorage *sharedInstance = [self.class sharedInstance];
  282|      0|  dispatch_sync(sharedInstance.storageQueue, ^{
  283|      0|    NSSet *classes = [NSSet setWithObjects:[NSMutableOrderedSet class], [GDTCOREvent class], nil];
  284|      0|    sharedInstance->_storedEvents = [aDecoder decodeObjectOfClasses:classes
  285|      0|                                                             forKey:kGDTCORStorageStoredEventsKey];
  286|      0|    classes = [NSSet
  287|      0|        setWithObjects:[NSMutableDictionary class], [NSMutableSet class], [GDTCOREvent class], nil];
  288|      0|    sharedInstance->_targetToEventSet =
  289|      0|        [aDecoder decodeObjectOfClasses:classes forKey:kGDTCORStorageTargetToEventSetKey];
  290|      0|    sharedInstance->_uploadCoordinator =
  291|      0|        [aDecoder decodeObjectOfClass:[GDTCORUploadCoordinator class]
  292|      0|                               forKey:kGDTCORStorageUploadCoordinatorKey];
  293|      0|  });
  294|      0|  return sharedInstance;
  295|      0|}
  296|       |
  297|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  298|      0|  GDTCORStorage *sharedInstance = [self.class sharedInstance];
  299|      0|  NSMutableOrderedSet<GDTCOREvent *> *storedEvents = sharedInstance->_storedEvents;
  300|      0|  if (storedEvents) {
  301|      0|    [aCoder encodeObject:storedEvents forKey:kGDTCORStorageStoredEventsKey];
  302|      0|  }
  303|      0|  NSMutableDictionary<NSNumber *, NSMutableSet<GDTCOREvent *> *> *targetToEventSet =
  304|      0|      sharedInstance->_targetToEventSet;
  305|      0|  if (targetToEventSet) {
  306|      0|    [aCoder encodeObject:targetToEventSet forKey:kGDTCORStorageTargetToEventSetKey];
  307|      0|  }
  308|      0|  GDTCORUploadCoordinator *uploadCoordinator = sharedInstance->_uploadCoordinator;
  309|      0|  if (uploadCoordinator) {
  310|      0|    [aCoder encodeObject:uploadCoordinator forKey:kGDTCORStorageUploadCoordinatorKey];
  311|      0|  }
  312|      0|}
  313|       |
  314|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORTransformer.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Private/GDTCORTransformer.h"
   18|       |#import "GDTCORLibrary/Private/GDTCORTransformer_Private.h"
   19|       |
   20|       |#import <GoogleDataTransport/GDTCORAssert.h>
   21|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   22|       |#import <GoogleDataTransport/GDTCOREvent.h>
   23|       |#import <GoogleDataTransport/GDTCOREventTransformer.h>
   24|       |#import <GoogleDataTransport/GDTCORLifecycle.h>
   25|       |
   26|       |#import "GDTCORLibrary/Private/GDTCORStorage.h"
   27|       |
   28|       |@implementation GDTCORTransformer
   29|       |
   30|      3|+ (instancetype)sharedInstance {
   31|      3|  static GDTCORTransformer *eventTransformer;
   32|      3|  static dispatch_once_t onceToken;
   33|      3|  dispatch_once(&onceToken, ^{
   34|      1|    eventTransformer = [[self alloc] init];
   35|      1|  });
   36|      3|  return eventTransformer;
   37|      3|}
   38|       |
   39|      1|- (instancetype)init {
   40|      1|  self = [super init];
   41|      1|  if (self) {
   42|      1|    _eventWritingQueue =
   43|      1|        dispatch_queue_create("com.google.GDTCORTransformer", DISPATCH_QUEUE_SERIAL);
   44|      1|    _storageInstance = [GDTCORStorage sharedInstance];
   45|      1|  }
   46|      1|  return self;
   47|      1|}
   48|       |
   49|       |- (void)transformEvent:(GDTCOREvent *)event
   50|       |      withTransformers:(NSArray<id<GDTCOREventTransformer>> *)transformers
   51|      2|            onComplete:(void (^_Nullable)(BOOL wasWritten, NSError *error))completion {
   52|      2|  GDTCORAssert(event, @"You can't write a nil event");
   53|      2|  BOOL hadOriginalCompletion = completion != nil;
   54|      2|  if (!completion) {
   55|      2|    completion = ^(BOOL wasWritten, NSError *_Nullable error) {
   56|      0|    };
   57|      2|  }
   58|      2|
   59|      2|  __block GDTCORBackgroundIdentifier bgID = GDTCORBackgroundIdentifierInvalid;
   60|      2|  bgID = [[GDTCORApplication sharedApplication]
   61|      2|      beginBackgroundTaskWithName:@"GDTTransformer"
   62|      2|                expirationHandler:^{
   63|      0|                  [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
   64|      0|                  bgID = GDTCORBackgroundIdentifierInvalid;
   65|      0|                }];
   66|      2|  dispatch_async(_eventWritingQueue, ^{
   67|      2|    GDTCOREvent *transformedEvent = event;
   68|      2|    for (id<GDTCOREventTransformer> transformer in transformers) {
   69|      0|      if ([transformer respondsToSelector:@selector(transform:)]) {
   70|      0|        GDTCORLogDebug("Applying a transformer to event %@", event);
   71|      0|        transformedEvent = [transformer transform:transformedEvent];
   72|      0|        if (!transformedEvent) {
   73|      0|          completion(NO, nil);
   74|      0|          return;
   75|      0|        }
   76|      0|      } else {
   77|      0|        GDTCORLogError(GDTCORMCETransformerDoesntImplementTransform,
   78|      0|                       @"Transformer doesn't implement transform: %@", transformer);
   79|      0|        completion(NO, nil);
   80|      0|        return;
   81|      0|      }
   82|      0|    }
   83|      2|    [self.storageInstance storeEvent:transformedEvent
   84|      2|                          onComplete:hadOriginalCompletion ? completion : nil];
   85|      2|
   86|      2|    // The work is done, cancel the background task if it's valid.
   87|      2|    [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
   88|      2|    bgID = GDTCORBackgroundIdentifierInvalid;
   89|      2|  });
   90|      2|}
   91|       |
   92|       |#pragma mark - GDTCORLifecycleProtocol
   93|       |
   94|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
   95|      0|  // Flush the queue immediately.
   96|      0|  dispatch_sync(_eventWritingQueue, ^{
   97|      0|                });
   98|      0|}
   99|       |
  100|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORTransport.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORTransport.h"
   18|       |#import "GDTCORLibrary/Private/GDTCORTransport_Private.h"
   19|       |
   20|       |#import <GoogleDataTransport/GDTCORAssert.h>
   21|       |#import <GoogleDataTransport/GDTCORClock.h>
   22|       |#import <GoogleDataTransport/GDTCOREvent.h>
   23|       |
   24|       |#import "GDTCORLibrary/Private/GDTCORTransformer.h"
   25|       |
   26|       |@implementation GDTCORTransport
   27|       |
   28|       |- (nullable instancetype)initWithMappingID:(NSString *)mappingID
   29|       |                              transformers:
   30|       |                                  (nullable NSArray<id<GDTCOREventTransformer>> *)transformers
   31|      1|                                    target:(NSInteger)target {
   32|      1|  GDTCORAssert(mappingID.length > 0, @"A mapping ID cannot be nil or empty");
   33|      1|  GDTCORAssert(target > 0, @"A target cannot be negative or 0");
   34|      1|  if (mappingID == nil || mappingID.length == 0 || target <= 0) {
   35|      0|    return nil;
   36|      0|  }
   37|      1|  self = [super init];
   38|      1|  if (self) {
   39|      1|    _mappingID = mappingID;
   40|      1|    _transformers = transformers;
   41|      1|    _target = target;
   42|      1|    _transformerInstance = [GDTCORTransformer sharedInstance];
   43|      1|  }
   44|      1|  GDTCORLogDebug("Transport object created. mappingID:%@ transformers:%@ target:%ld", mappingID,
   45|      1|                 transformers, (long)target);
   46|      1|  return self;
   47|      1|}
   48|       |
   49|       |- (void)sendTelemetryEvent:(GDTCOREvent *)event
   50|      2|                onComplete:(void (^)(BOOL wasWritten, NSError *_Nullable error))completion {
   51|      2|  event.qosTier = GDTCOREventQoSTelemetry;
   52|      2|  [self sendEvent:event onComplete:completion];
   53|      2|}
   54|       |
   55|       |- (void)sendDataEvent:(GDTCOREvent *)event
   56|      0|           onComplete:(void (^)(BOOL wasWritten, NSError *_Nullable error))completion {
   57|      0|  GDTCORAssert(event.qosTier != GDTCOREventQoSTelemetry, @"Use -sendTelemetryEvent, please.");
   58|      0|  [self sendEvent:event onComplete:completion];
   59|      0|}
   60|       |
   61|      2|- (void)sendTelemetryEvent:(GDTCOREvent *)event {
   62|      2|  [self sendTelemetryEvent:event onComplete:nil];
   63|      2|}
   64|       |
   65|      0|- (void)sendDataEvent:(GDTCOREvent *)event {
   66|      0|  [self sendDataEvent:event onComplete:nil];
   67|      0|}
   68|       |
   69|      2|- (GDTCOREvent *)eventForTransport {
   70|      2|  return [[GDTCOREvent alloc] initWithMappingID:_mappingID target:_target];
   71|      2|}
   72|       |
   73|       |#pragma mark - Private helper methods
   74|       |
   75|       |/** Sends the given event through the transport pipeline.
   76|       | *
   77|       | * @param event The event to send.
   78|       | * @param completion A block that will be called when the event has been written or dropped.
   79|       | */
   80|       |- (void)sendEvent:(GDTCOREvent *)event
   81|      2|       onComplete:(void (^_Nullable)(BOOL wasWritten, NSError *error))completion {
   82|      2|  // TODO: Determine if sending an event before registration is allowed.
   83|      2|  GDTCORAssert(event, @"You can't send a nil event");
   84|      2|  GDTCOREvent *copiedEvent = [event copy];
   85|      2|  copiedEvent.clockSnapshot = [GDTCORClock snapshot];
   86|      2|  [self.transformerInstance transformEvent:copiedEvent
   87|      2|                          withTransformers:_transformers
   88|      2|                                onComplete:completion];
   89|      2|}
   90|       |
   91|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORUploadCoordinator.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORAssert.h>
   20|       |#import <GoogleDataTransport/GDTCORClock.h>
   21|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   22|       |#import <GoogleDataTransport/GDTCORReachability.h>
   23|       |
   24|       |#import "GDTCORLibrary/Private/GDTCORRegistrar_Private.h"
   25|       |#import "GDTCORLibrary/Private/GDTCORStorage.h"
   26|       |
   27|       |@implementation GDTCORUploadCoordinator
   28|       |
   29|      9|+ (instancetype)sharedInstance {
   30|      9|  static GDTCORUploadCoordinator *sharedUploader;
   31|      9|  static dispatch_once_t onceToken;
   32|      9|  dispatch_once(&onceToken, ^{
   33|      1|    sharedUploader = [[GDTCORUploadCoordinator alloc] init];
   34|      1|    [sharedUploader startTimer];
   35|      1|  });
   36|      9|  return sharedUploader;
   37|      9|}
   38|       |
   39|      1|- (instancetype)init {
   40|      1|  self = [super init];
   41|      1|  if (self) {
   42|      1|    _coordinationQueue =
   43|      1|        dispatch_queue_create("com.google.GDTCORUploadCoordinator", DISPATCH_QUEUE_SERIAL);
   44|      1|    _registrar = [GDTCORRegistrar sharedInstance];
   45|      1|    _timerInterval = 30 * NSEC_PER_SEC;
   46|      1|    _timerLeeway = 5 * NSEC_PER_SEC;
   47|      1|    _targetToInFlightPackages = [[NSMutableDictionary alloc] init];
   48|      1|  }
   49|      1|  return self;
   50|      1|}
   51|       |
   52|      0|- (void)forceUploadForTarget:(GDTCORTarget)target {
   53|      0|  dispatch_async(_coordinationQueue, ^{
   54|      0|    GDTCORLogDebug("Forcing an upload of target %ld", (long)target);
   55|      0|    GDTCORUploadConditions conditions = [self uploadConditions];
   56|      0|    conditions |= GDTCORUploadConditionHighPriority;
   57|      0|    [self uploadTargets:@[ @(target) ] conditions:conditions];
   58|      0|  });
   59|      0|}
   60|       |
   61|       |#pragma mark - Property overrides
   62|       |
   63|       |// GDTCORStorage and GDTCORUploadCoordinator +sharedInstance methods call each other, so this breaks
   64|       |// the loop.
   65|      3|- (GDTCORStorage *)storage {
   66|      3|  if (!_storage) {
   67|      1|    _storage = [GDTCORStorage sharedInstance];
   68|      1|  }
   69|      3|  return _storage;
   70|      3|}
   71|       |
   72|       |#pragma mark - Private helper methods
   73|       |
   74|       |/** Starts a timer that checks whether or not events can be uploaded at regular intervals. It will
   75|       | * check the next-upload clocks of all targets to determine if an upload attempt can be made.
   76|       | */
   77|      3|- (void)startTimer {
   78|      3|  dispatch_sync(_coordinationQueue, ^{
   79|      3|    self->_timer =
   80|      3|        dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, self->_coordinationQueue);
   81|      3|    dispatch_source_set_timer(self->_timer, DISPATCH_TIME_NOW, self->_timerInterval,
   82|      3|                              self->_timerLeeway);
   83|      3|    dispatch_source_set_event_handler(self->_timer, ^{
   84|      3|      if (![[GDTCORApplication sharedApplication] isRunningInBackground]) {
   85|      3|        GDTCORUploadConditions conditions = [self uploadConditions];
   86|      3|        GDTCORLogDebug("%@", @"Upload timer fired");
   87|      3|        [self uploadTargets:[self.registrar.targetToUploader allKeys] conditions:conditions];
   88|      3|      }
   89|      3|    });
   90|      3|    GDTCORLogDebug("%@", @"Upload timer started");
   91|      3|    dispatch_resume(self->_timer);
   92|      3|  });
   93|      3|}
   94|       |
   95|       |/** Stops the currently running timer. */
   96|      0|- (void)stopTimer {
   97|      0|  if (_timer) {
   98|      0|    dispatch_source_cancel(_timer);
   99|      0|  }
  100|      0|}
  101|       |
  102|       |/** Triggers the uploader implementations for the given targets to upload.
  103|       | *
  104|       | * @param targets An array of targets to trigger.
  105|       | * @param conditions The set of upload conditions.
  106|       | */
  107|      3|- (void)uploadTargets:(NSArray<NSNumber *> *)targets conditions:(GDTCORUploadConditions)conditions {
  108|      3|  dispatch_async(_coordinationQueue, ^{
  109|      3|    if ((conditions & GDTCORUploadConditionNoNetwork) == GDTCORUploadConditionNoNetwork) {
  110|      0|      return;
  111|      0|    }
  112|      9|    for (NSNumber *target in targets) {
  113|      9|      // Don't trigger uploads for targets that have an in-flight package already.
  114|      9|      if (self->_targetToInFlightPackages[target]) {
  115|      1|        GDTCORLogDebug("Target %@ will not upload, there's an upload in flight", target);
  116|      1|        continue;
  117|      1|      }
  118|      8|      // Ask the uploader if they can upload and do so, if it can.
  119|      8|      id<GDTCORUploader> uploader = self.registrar.targetToUploader[target];
  120|      8|      if ([uploader readyToUploadTarget:target.intValue conditions:conditions]) {
  121|      4|        id<GDTCORPrioritizer> prioritizer = self.registrar.targetToPrioritizer[target];
  122|      4|        GDTCORUploadPackage *package = [prioritizer uploadPackageWithTarget:target.intValue
  123|      4|                                                                 conditions:conditions];
  124|      4|        if (package.events.count) {
  125|      1|          self->_targetToInFlightPackages[target] = package;
  126|      1|          GDTCORLogDebug("Package of %ld events is being handed over to an uploader",
  127|      1|                         (long)package.events.count);
  128|      1|          [uploader uploadPackage:package];
  129|      3|        } else {
  130|      3|          [package completeDelivery];
  131|      3|        }
  132|      4|      }
  133|      8|      GDTCORLogDebug("Target %@ is not ready to upload", target);
  134|      8|    }
  135|      3|  });
  136|      3|}
  137|       |
  138|       |/** Returns the current upload conditions after making determinations about the network connection.
  139|       | *
  140|       | * @return The current upload conditions.
  141|       | */
  142|      3|- (GDTCORUploadConditions)uploadConditions {
  143|       |#if TARGET_OS_WATCH
  144|       |  return GDTCORUploadConditionNoNetwork;
  145|       |#else
  146|       |  SCNetworkReachabilityFlags currentFlags = [GDTCORReachability currentFlags];
  147|      3|  BOOL reachable =
  148|      3|      (currentFlags & kSCNetworkReachabilityFlagsReachable) == kSCNetworkReachabilityFlagsReachable;
  149|      3|  BOOL connectionRequired = (currentFlags & kSCNetworkReachabilityFlagsConnectionRequired) ==
  150|      3|                            kSCNetworkReachabilityFlagsConnectionRequired;
  151|      3|  BOOL networkConnected = reachable && !connectionRequired;
  152|      3|
  153|      3|  if (!networkConnected) {
  154|      0|    return GDTCORUploadConditionNoNetwork;
  155|      0|  }
  156|      3|
  157|      3|  BOOL isWWAN = GDTCORReachabilityFlagsContainWWAN(currentFlags);
  158|      3|  if (isWWAN) {
  159|      0|    return GDTCORUploadConditionMobileData;
  160|      3|  } else {
  161|      3|    return GDTCORUploadConditionWifiData;
  162|      3|  }
  163|      3|#endif
  164|      3|}
  165|       |
  166|       |#pragma mark - NSSecureCoding support
  167|       |
  168|       |/** The NSKeyedCoder key for the targetToInFlightPackages property. */
  169|       |static NSString *const ktargetToInFlightPackagesKey =
  170|       |    @"GDTCORUploadCoordinatortargetToInFlightPackages";
  171|       |
  172|      0|+ (BOOL)supportsSecureCoding {
  173|      0|  return YES;
  174|      0|}
  175|       |
  176|      0|- (instancetype)initWithCoder:(NSCoder *)aDecoder {
  177|      0|  GDTCORUploadCoordinator *sharedCoordinator = [GDTCORUploadCoordinator sharedInstance];
  178|      0|  dispatch_sync(sharedCoordinator->_coordinationQueue, ^{
  179|      0|    @try {
  180|      0|      NSSet *classes =
  181|      0|          [NSSet setWithObjects:[NSMutableDictionary class], [GDTCORUploadPackage class], nil];
  182|      0|      sharedCoordinator->_targetToInFlightPackages =
  183|      0|          [aDecoder decodeObjectOfClasses:classes forKey:ktargetToInFlightPackagesKey];
  184|      0|
  185|      0|    } @catch (NSException *exception) {
  186|      0|      sharedCoordinator->_targetToInFlightPackages = [NSMutableDictionary dictionary];
  187|      0|    }
  188|      0|  });
  189|      0|  return sharedCoordinator;
  190|      0|}
  191|       |
  192|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  193|      0|  dispatch_sync(_coordinationQueue, ^{
  194|      0|    // All packages that have been given to uploaders need to be tracked so that their expiration
  195|      0|    // timers can be called.
  196|      0|    if (self->_targetToInFlightPackages.count > 0) {
  197|      0|      [aCoder encodeObject:self->_targetToInFlightPackages forKey:ktargetToInFlightPackagesKey];
  198|      0|    }
  199|      0|  });
  200|      0|}
  201|       |
  202|       |#pragma mark - GDTCORLifecycleProtocol
  203|       |
  204|      2|- (void)appWillForeground:(GDTCORApplication *)app {
  205|      2|  // Not entirely thread-safe, but it should be fine.
  206|      2|  [self startTimer];
  207|      2|}
  208|       |
  209|      0|- (void)appWillBackground:(GDTCORApplication *)app {
  210|      0|  // Should be thread-safe. If it ends up not being, put this in a dispatch_sync.
  211|      0|  [self stopTimer];
  212|      0|}
  213|       |
  214|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
  215|      0|  dispatch_sync(_coordinationQueue, ^{
  216|      0|    [self stopTimer];
  217|      0|  });
  218|      0|}
  219|       |
  220|       |#pragma mark - GDTCORUploadPackageProtocol
  221|       |
  222|      3|- (void)packageDelivered:(GDTCORUploadPackage *)package successful:(BOOL)successful {
  223|      3|  if (!_coordinationQueue) {
  224|      0|    return;
  225|      0|  }
  226|      3|  dispatch_async(_coordinationQueue, ^{
  227|      3|    NSNumber *targetNumber = @(package.target);
  228|      3|    NSMutableDictionary<NSNumber *, GDTCORUploadPackage *> *targetToInFlightPackages =
  229|      3|        self->_targetToInFlightPackages;
  230|      3|    GDTCORRegistrar *registrar = self->_registrar;
  231|      3|    if (targetToInFlightPackages) {
  232|      3|      [targetToInFlightPackages removeObjectForKey:targetNumber];
  233|      3|    }
  234|      3|    if (registrar) {
  235|      3|      id<GDTCORPrioritizer> prioritizer = registrar.targetToPrioritizer[targetNumber];
  236|      3|      if (!prioritizer) {
  237|      0|        GDTCORLogError(GDTCORMCEPrioritizerError,
  238|      0|                       @"A prioritizer should be registered for this target: %@", targetNumber);
  239|      0|      }
  240|      3|      if ([prioritizer respondsToSelector:@selector(packageDelivered:successful:)]) {
  241|      3|        [prioritizer packageDelivered:package successful:successful];
  242|      3|      }
  243|      3|    }
  244|      3|    if (successful && package.events) {
  245|      3|      [self.storage removeEvents:package.events];
  246|      3|    }
  247|      3|  });
  248|      3|}
  249|       |
  250|      0|- (void)packageExpired:(GDTCORUploadPackage *)package {
  251|      0|  if (!_coordinationQueue) {
  252|      0|    return;
  253|      0|  }
  254|      0|  dispatch_async(_coordinationQueue, ^{
  255|      0|    NSNumber *targetNumber = @(package.target);
  256|      0|    NSMutableDictionary<NSNumber *, GDTCORUploadPackage *> *targetToInFlightPackages =
  257|      0|        self->_targetToInFlightPackages;
  258|      0|    GDTCORRegistrar *registrar = self->_registrar;
  259|      0|    if (targetToInFlightPackages) {
  260|      0|      [targetToInFlightPackages removeObjectForKey:targetNumber];
  261|      0|    }
  262|      0|    if (registrar) {
  263|      0|      id<GDTCORPrioritizer> prioritizer = registrar.targetToPrioritizer[targetNumber];
  264|      0|      id<GDTCORUploader> uploader = registrar.targetToUploader[targetNumber];
  265|      0|      if ([prioritizer respondsToSelector:@selector(packageExpired:)]) {
  266|      0|        [prioritizer packageExpired:package];
  267|      0|      }
  268|      0|      if ([uploader respondsToSelector:@selector(packageExpired:)]) {
  269|      0|        [uploader packageExpired:package];
  270|      0|      }
  271|      0|    }
  272|      0|  });
  273|      0|}
  274|       |
  275|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/GDTCORUploadPackage.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCORLibrary/Public/GDTCORUploadPackage.h"
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORClock.h>
   20|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   21|       |
   22|       |#import "GDTCORLibrary/Private/GDTCORStorage_Private.h"
   23|       |#import "GDTCORLibrary/Private/GDTCORUploadCoordinator.h"
   24|       |#import "GDTCORLibrary/Private/GDTCORUploadPackage_Private.h"
   25|       |
   26|       |@implementation GDTCORUploadPackage {
   27|       |  /** If YES, the package's -completeDelivery method has been called. */
   28|       |  BOOL _isDelivered;
   29|       |
   30|       |  /** If YES, is being handled by the handler. */
   31|       |  BOOL _isHandled;
   32|       |
   33|       |  /** A timer that will regularly check to see whether this package has expired or not. */
   34|       |  NSTimer *_expirationTimer;
   35|       |}
   36|       |
   37|      4|- (instancetype)initWithTarget:(GDTCORTarget)target {
   38|      4|  self = [super init];
   39|      4|  if (self) {
   40|      4|    _target = target;
   41|      4|    _storage = [GDTCORStorage sharedInstance];
   42|      4|    _deliverByTime = [GDTCORClock clockSnapshotInTheFuture:180000];
   43|      4|    _handler = [GDTCORUploadCoordinator sharedInstance];
   44|      4|    _expirationTimer = [NSTimer scheduledTimerWithTimeInterval:5.0
   45|      4|                                                        target:self
   46|      4|                                                      selector:@selector(checkIfPackageIsExpired:)
   47|      4|                                                      userInfo:nil
   48|      4|                                                       repeats:YES];
   49|      4|  }
   50|      4|  GDTCORLogDebug("Upload package created %@", self);
   51|      4|  return self;
   52|      4|}
   53|       |
   54|      0|- (instancetype)copy {
   55|      0|  GDTCORUploadPackage *newPackage = [[GDTCORUploadPackage alloc] initWithTarget:_target];
   56|      0|  newPackage->_events = [_events copy];
   57|      0|  GDTCORLogDebug("Copying UploadPackage %@ to %@", self, newPackage);
   58|      0|  return newPackage;
   59|      0|}
   60|       |
   61|      0|- (NSUInteger)hash {
   62|      0|  return [_events hash];
   63|      0|}
   64|       |
   65|      0|- (BOOL)isEqual:(id)object {
   66|      0|  return [self hash] == [object hash];
   67|      0|}
   68|       |
   69|      3|- (void)dealloc {
   70|      3|  [_expirationTimer invalidate];
   71|      3|}
   72|       |
   73|      0|- (void)setStorage:(GDTCORStorage *)storage {
   74|      0|  if (storage != _storage) {
   75|      0|    _storage = storage;
   76|      0|  }
   77|      0|}
   78|       |
   79|      3|- (void)completeDelivery {
   80|      3|  if (_isDelivered) {
   81|      0|    GDTCORLogError(GDTCORMCEDeliverTwice, @"%@",
   82|      0|                   @"It's an API violation to call -completeDelivery twice.");
   83|      0|  }
   84|      3|  _isDelivered = YES;
   85|      3|  if (!_isHandled && _handler &&
   86|      3|      [_handler respondsToSelector:@selector(packageDelivered:successful:)]) {
   87|      3|    [_expirationTimer invalidate];
   88|      3|    _isHandled = YES;
   89|      3|    [_handler packageDelivered:self successful:YES];
   90|      3|  }
   91|      3|  GDTCORLogDebug("Upload package delivered: %@", self);
   92|      3|}
   93|       |
   94|      0|- (void)retryDeliveryInTheFuture {
   95|      0|  if (!_isHandled && _handler &&
   96|      0|      [_handler respondsToSelector:@selector(packageDelivered:successful:)]) {
   97|      0|    [_expirationTimer invalidate];
   98|      0|    _isHandled = YES;
   99|      0|    [_handler packageDelivered:self successful:NO];
  100|      0|  }
  101|      0|  GDTCORLogDebug("Upload package will retry in the future: %@", self);
  102|      0|}
  103|       |
  104|      0|- (void)checkIfPackageIsExpired:(NSTimer *)timer {
  105|      0|  if ([[GDTCORClock snapshot] isAfter:_deliverByTime]) {
  106|      0|    if (_handler && [_handler respondsToSelector:@selector(packageExpired:)]) {
  107|      0|      _isHandled = YES;
  108|      0|      [_expirationTimer invalidate];
  109|      0|      GDTCORLogDebug("Upload package expired: %@", self);
  110|      0|      [_handler packageExpired:self];
  111|      0|    }
  112|      0|  }
  113|      0|}
  114|       |
  115|       |#pragma mark - NSSecureCoding
  116|       |
  117|       |/** The keyed archiver key for the events property. */
  118|       |static NSString *const kEventsKey = @"GDTCORUploadPackageEventsKey";
  119|       |
  120|       |/** The keyed archiver key for the _isHandled property. */
  121|       |static NSString *const kDeliverByTimeKey = @"GDTCORUploadPackageDeliveryByTimeKey";
  122|       |
  123|       |/** The keyed archiver key for the _isHandled ivar. */
  124|       |static NSString *const kIsHandledKey = @"GDTCORUploadPackageIsHandledKey";
  125|       |
  126|       |/** The keyed archiver key for the handler property. */
  127|       |static NSString *const kHandlerKey = @"GDTCORUploadPackageHandlerKey";
  128|       |
  129|       |/** The keyed archiver key for the target property. */
  130|       |static NSString *const kTargetKey = @"GDTCORUploadPackageTargetKey";
  131|       |
  132|      0|+ (BOOL)supportsSecureCoding {
  133|      0|  return YES;
  134|      0|}
  135|       |
  136|      0|- (void)encodeWithCoder:(nonnull NSCoder *)aCoder {
  137|      0|  [aCoder encodeObject:_events forKey:kEventsKey];
  138|      0|  [aCoder encodeObject:_deliverByTime forKey:kDeliverByTimeKey];
  139|      0|  [aCoder encodeBool:_isHandled forKey:kIsHandledKey];
  140|      0|  [aCoder encodeObject:_handler forKey:kHandlerKey];
  141|      0|  [aCoder encodeInteger:_target forKey:kTargetKey];
  142|      0|}
  143|       |
  144|      0|- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder {
  145|      0|  // Sets a global translation mapping to decode GDTCORStoredEvent objects encoded as instances of
  146|      0|  // GDTCOREvent instead.
  147|      0|  [NSKeyedUnarchiver setClass:[GDTCOREvent class] forClassName:@"GDTCORStoredEvent"];
  148|      0|
  149|      0|  GDTCORTarget target = [aDecoder decodeIntegerForKey:kTargetKey];
  150|      0|  self = [self initWithTarget:target];
  151|      0|  if (self) {
  152|      0|    NSSet *classes = [NSSet setWithObjects:[NSSet class], [GDTCOREvent class], nil];
  153|      0|    _events = [aDecoder decodeObjectOfClasses:classes forKey:kEventsKey];
  154|      0|    _deliverByTime = [aDecoder decodeObjectOfClass:[GDTCORClock class] forKey:kDeliverByTimeKey];
  155|      0|    _isHandled = [aDecoder decodeBoolForKey:kIsHandledKey];
  156|      0|    // _handler isn't technically NSSecureCoding, because we don't know the class of this object.
  157|      0|    // but it gets decoded anyway.
  158|      0|  }
  159|      0|  return self;
  160|      0|}
  161|       |
  162|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/Public/GDTCORAssert.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   20|       |
   21|       |/** A block type that could be run instead of normal assertion logging. No return type, no params.
   22|       | */
   23|       |typedef void (^GDTCORAssertionBlock)(void);
   24|       |
   25|       |/** Returns the result of executing a soft-linked method present in unit tests that allows a block
   26|       | * to be run instead of normal assertion logging. This helps ameliorate issues with catching
   27|       | * exceptions that occur on a dispatch_queue.
   28|       | *
   29|       | * @return A block that can be run instead of normal assert printing.
   30|       | */
   31|       |FOUNDATION_EXPORT GDTCORAssertionBlock _Nullable GDTCORAssertionBlockToRunInstead(void);
   32|       |
   33|       |#if defined(NS_BLOCK_ASSERTIONS)
   34|       |
   35|       |#define GDTCORAssert(condition, ...) \
   36|       |  do {                               \
   37|       |  } while (0);
   38|       |
   39|       |#define GDTCORFatalAssert(condition, ...) \
   40|       |  do {                                    \
   41|       |  } while (0);
   42|       |
   43|       |#else  // defined(NS_BLOCK_ASSERTIONS)
   44|       |
   45|       |/** Asserts using a console log, unless a block was specified to be run instead.
   46|       | *
   47|       | * @param condition The condition you'd expect to be YES.
   48|       | */
   49|       |#define GDTCORAssert(condition, format, ...)                                     \
   50|     18|  do {                                                                           \
   51|     18|    __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS                                          \
   52|     18|    if (__builtin_expect(!(condition), 0)) {                                     \
   53|      0|      GDTCORAssertionBlock assertionBlock = GDTCORAssertionBlockToRunInstead();  \
   54|      0|      if (assertionBlock) {                                                      \
   55|      0|        assertionBlock();                                                        \
   56|      0|      } else {                                                                   \
   57|      0|        NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__];    \
   58|      0|        __assert_file__ = __assert_file__ ? __assert_file__ : @"<Unknown File>"; \
   59|      0|        GDTCORLogAssert(NO, __assert_file__, __LINE__, format, ##__VA_ARGS__);   \
   60|      0|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS                                       \
   61|      0|      }                                                                          \
   62|      0|    }                                                                            \
   63|     18|  } while (0);
   64|       |
   65|       |/** Asserts by logging to the console and throwing an exception if NS_BLOCK_ASSERTIONS is not
   66|       | * defined.
   67|       | *
   68|       | * @param condition The condition you'd expect to be YES.
   69|       | */
   70|       |#define GDTCORFatalAssert(condition, format, ...)                                          \
   71|      1|  do {                                                                                     \
   72|      1|    __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS                                                    \
   73|      1|    if (__builtin_expect(!(condition), 0)) {                                               \
   74|      0|      GDTCORAssertionBlock assertionBlock = GDTCORAssertionBlockToRunInstead();            \
   75|      0|      if (assertionBlock) {                                                                \
   76|      0|        assertionBlock();                                                                  \
   77|      0|      } else {                                                                             \
   78|      0|        NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__];              \
   79|      0|        __assert_file__ = __assert_file__ ? __assert_file__ : @"<Unknown File>";           \
   80|      0|        GDTCORLogAssert(YES, __assert_file__, __LINE__, format, ##__VA_ARGS__);            \
   81|      0|        [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd                    \
   82|      0|                                                            object:self                    \
   83|      0|                                                              file:__assert_file__         \
   84|      0|                                                        lineNumber:__LINE__                \
   85|      0|                                                       description:format, ##__VA_ARGS__]; \
   86|      0|        __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS                                                 \
   87|      0|      }                                                                                    \
   88|      0|    }                                                                                      \
   89|      1|  } while (0);
   90|       |
   91|       |#endif  // defined(NS_BLOCK_ASSERTIONS)

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransport/GoogleDataTransport/GDTCORLibrary/Public/GDTCORConsoleLogger.h:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |// Set this to 1 to have the library print out as much as possible about what GDT is doing.
   20|       |#define GDT_VERBOSE_LOGGING 0
   21|       |
   22|       |/** A list of message codes to print in the logger that help to correspond printed messages with
   23|       | * code locations.
   24|       | *
   25|       | * Prefixes:
   26|       | * - MCW => MessageCodeWarning
   27|       | * - MCE => MessageCodeError
   28|       | */
   29|       |typedef NS_ENUM(NSInteger, GDTCORMessageCode) {
   30|       |
   31|       |  /** For warning messages concerning transportBytes: not being implemented by a data object. */
   32|       |  GDTCORMCWDataObjectMissingBytesImpl = 1,
   33|       |
   34|       |  /** For warning messages concerning a failed event upload. */
   35|       |  GDTCORMCWUploadFailed = 2,
   36|       |
   37|       |  /** For warning messages concerning a forced event upload. */
   38|       |  GDTCORMCWForcedUpload = 3,
   39|       |
   40|       |  /** For warning messages concerning a failed reachability call. */
   41|       |  GDTCORMCWReachabilityFailed = 4,
   42|       |
   43|       |  /** For error messages concerning transform: not being implemented by an event transformer. */
   44|       |  GDTCORMCETransformerDoesntImplementTransform = 1000,
   45|       |
   46|       |  /** For error messages concerning the creation of a directory failing. */
   47|       |  GDTCORMCEDirectoryCreationError = 1001,
   48|       |
   49|       |  /** For error messages concerning the writing of a event file. */
   50|       |  GDTCORMCEFileWriteError = 1002,
   51|       |
   52|       |  /** For error messages concerning the lack of a prioritizer for a given backend. */
   53|       |  GDTCORMCEPrioritizerError = 1003,
   54|       |
   55|       |  /** For error messages concerning a package delivery API violation. */
   56|       |  GDTCORMCEDeliverTwice = 1004,
   57|       |
   58|       |  /** For error messages concerning an error in an implementation of -transportBytes. */
   59|       |  GDTCORMCETransportBytesError = 1005,
   60|       |
   61|       |  /** For general purpose error messages in a dependency. */
   62|       |  GDTCORMCEGeneralError = 1006,
   63|       |
   64|       |  /** For fatal errors. Please go to https://github.com/firebase/firebase-ios-sdk/issues and open
   65|       |   * an issue if you encounter an error with this code.
   66|       |   */
   67|       |  GDTCORMCEFatalAssertion = 1007,
   68|       |
   69|       |  /** For error messages concerning the reading of a event file. */
   70|       |  GDTCORMCEFileReadError = 1008
   71|       |};
   72|       |
   73|       |/** Prints the given code and format string to the console.
   74|       | *
   75|       | * @param code The message code describing the nature of the log.
   76|       | * @param format The format string.
   77|       | */
   78|       |FOUNDATION_EXPORT
   79|       |void GDTCORLog(GDTCORMessageCode code, NSString *_Nonnull format, ...) NS_FORMAT_FUNCTION(2, 3);
   80|       |
   81|       |/** Prints an assert log to the console.
   82|       | *
   83|       | * @param wasFatal Send YES if the assertion should be fatal, NO otherwise.
   84|       | * @param file The file in which the failure occurred.
   85|       | * @param line The line number of the failure.
   86|       | * @param format The format string.
   87|       | */
   88|       |FOUNDATION_EXPORT void GDTCORLogAssert(BOOL wasFatal,
   89|       |                                       NSString *_Nonnull file,
   90|       |                                       NSInteger line,
   91|       |                                       NSString *_Nullable format,
   92|       |                                       ...) NS_FORMAT_FUNCTION(4, 5);
   93|       |
   94|       |/** Returns the string that represents some message code.
   95|       | *
   96|       | * @param code The code to convert to a string.
   97|       | * @return The string representing the message code.
   98|       | */
   99|       |FOUNDATION_EXPORT NSString *_Nonnull GDTCORMessageCodeEnumToString(GDTCORMessageCode code);
  100|       |
  101|       |// A define to wrap GULLogWarning with slightly more convenient usage.
  102|       |#define GDTCORLogWarning(MESSAGE_CODE, MESSAGE_FORMAT, ...) \
  103|      0|  GDTCORLog(MESSAGE_CODE, MESSAGE_FORMAT, __VA_ARGS__);
  104|       |
  105|       |// A define to wrap GULLogError with slightly more convenient usage and a failing assert.
  106|       |#define GDTCORLogError(MESSAGE_CODE, MESSAGE_FORMAT, ...) \
  107|      0|  GDTCORLog(MESSAGE_CODE, MESSAGE_FORMAT, __VA_ARGS__);
  108|       |
  109|       |// A define to wrap NSLog for verbose console logs only useful for local debugging.
  110|       |#if GDT_VERBOSE_LOGGING == 1
  111|       |#define GDTCORLogDebug(FORMAT, ...) NSLog(@"GDT: " FORMAT, __VA_ARGS__);
  112|       |#else
  113|       |#define GDTCORLogDebug(...)
  114|       |#endif  // GDT_VERBOSE_LOGGING == 1

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransportCCTSupport/GoogleDataTransportCCTSupport/GDTCCTLibrary/GDTCCTCompressionHelper.m:
    1|       |/*
    2|       | * Copyright 2020 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCCTLibrary/Private/GDTCCTCompressionHelper.h"
   18|       |
   19|       |#import <zlib.h>
   20|       |
   21|       |@implementation GDTCCTCompressionHelper
   22|       |
   23|      1|+ (nullable NSData *)gzippedData:(NSData *)data {
   24|      1|#if defined(__LP64__) && __LP64__
   25|      1|  // Don't support > 32bit length for 64 bit, see note in header.
   26|      1|  if (data.length > UINT_MAX) {
   27|      0|    return nil;
   28|      0|  }
   29|      1|#endif
   30|      1|
   31|      1|  const uint kChunkSize = 1024;
   32|      1|
   33|      1|  const void *bytes = [data bytes];
   34|      1|  NSUInteger length = [data length];
   35|      1|
   36|      1|  int level = Z_DEFAULT_COMPRESSION;
   37|      1|  if (!bytes || !length) {
   38|      0|    return nil;
   39|      0|  }
   40|      1|
   41|      1|  z_stream strm;
   42|      1|  bzero(&strm, sizeof(z_stream));
   43|      1|
   44|      1|  int memLevel = 8;          // Default.
   45|      1|  int windowBits = 15 + 16;  // Enable gzip header instead of zlib header.
   46|      1|
   47|      1|  int retCode;
   48|      1|  if (deflateInit2(&strm, level, Z_DEFLATED, windowBits, memLevel, Z_DEFAULT_STRATEGY) != Z_OK) {
   49|      0|    return nil;
   50|      0|  }
   51|      1|
   52|      1|  // Hint the size at 1/4 the input size.
   53|      1|  NSMutableData *result = [NSMutableData dataWithCapacity:(length / 4)];
   54|      1|  unsigned char output[kChunkSize];
   55|      1|
   56|      1|  // Setup the input.
   57|      1|  strm.avail_in = (unsigned int)length;
   58|      1|  strm.next_in = (unsigned char *)bytes;
   59|      1|
   60|      1|  // Collect the data.
   61|      1|  do {
   62|      1|    // update what we're passing in
   63|      1|    strm.avail_out = kChunkSize;
   64|      1|    strm.next_out = output;
   65|      1|    retCode = deflate(&strm, Z_FINISH);
   66|      1|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
   67|      0|      deflateEnd(&strm);
   68|      0|      return nil;
   69|      0|    }
   70|      1|    // Collect what we got.
   71|      1|    unsigned gotBack = kChunkSize - strm.avail_out;
   72|      1|    if (gotBack > 0) {
   73|      1|      [result appendBytes:output length:gotBack];
   74|      1|    }
   75|      1|
   76|      1|  } while (retCode == Z_OK);
   77|      1|
   78|      1|  // If the loop exits, it used all input and the stream ended.
   79|      1|  NSAssert(strm.avail_in == 0,
   80|      1|           @"Should have finished deflating without using all input, %u bytes left", strm.avail_in);
   81|      1|  NSAssert(retCode == Z_STREAM_END,
   82|      1|           @"thought we finished deflate w/o getting a result of stream end, code %d", retCode);
   83|      1|
   84|      1|  // Clean up.
   85|      1|  deflateEnd(&strm);
   86|      1|
   87|      1|  return result;
   88|      1|}
   89|       |
   90|      1|+ (BOOL)isGzipped:(NSData *)data {
   91|      1|  const UInt8 *bytes = (const UInt8 *)data.bytes;
   92|      1|  return (data.length >= 2 && bytes[0] == 0x1f && bytes[1] == 0x8b);
   93|      1|}
   94|       |
   95|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransportCCTSupport/GoogleDataTransportCCTSupport/GDTCCTLibrary/GDTCCTNanopbHelpers.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCCTLibrary/Private/GDTCCTNanopbHelpers.h"
   18|       |
   19|       |#if TARGET_OS_IOS || TARGET_OS_TV
   20|       |#import <UIKit/UIKit.h>
   21|       |#elif TARGET_OS_OSX
   22|       |#import <AppKit/AppKit.h>
   23|       |#endif  // TARGET_OS_IOS || TARGET_OS_TV
   24|       |
   25|       |#import <GoogleDataTransport/GDTCORClock.h>
   26|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   27|       |#import <GoogleDataTransport/GDTCOREvent.h>
   28|       |#import <GoogleDataTransport/GDTCORPlatform.h>
   29|       |
   30|       |#import <nanopb/pb.h>
   31|       |#import <nanopb/pb_decode.h>
   32|       |#import <nanopb/pb_encode.h>
   33|       |
   34|       |NSString *const GDTCCTNeedsNetworkConnectionInfo = @"needs_network_connection_info";
   35|       |
   36|       |NSString *const GDTCCTNetworkConnectionInfo = @"network_connection_info";
   37|       |
   38|       |#pragma mark - General purpose encoders
   39|       |
   40|      7|pb_bytes_array_t *GDTCCTEncodeString(NSString *string) {
   41|      7|  NSData *stringBytes = [string dataUsingEncoding:NSUTF8StringEncoding];
   42|      7|  return GDTCCTEncodeData(stringBytes);
   43|      7|}
   44|       |
   45|      8|pb_bytes_array_t *GDTCCTEncodeData(NSData *data) {
   46|      8|  pb_bytes_array_t *pbBytes = malloc(PB_BYTES_ARRAY_T_ALLOCSIZE(data.length));
   47|      8|  if (pbBytes != NULL) {
   48|      8|    memcpy(pbBytes->bytes, [data bytes], data.length);
   49|      8|    pbBytes->size = (pb_size_t)data.length;
   50|      8|  }
   51|      8|  return pbBytes;
   52|      8|}
   53|       |
   54|       |#pragma mark - CCT object constructors
   55|       |
   56|      1|NSData *_Nullable GDTCCTEncodeBatchedLogRequest(gdt_cct_BatchedLogRequest *batchedLogRequest) {
   57|      1|  pb_ostream_t sizestream = PB_OSTREAM_SIZING;
   58|      1|  // Encode 1 time to determine the size.
   59|      1|  if (!pb_encode(&sizestream, gdt_cct_BatchedLogRequest_fields, batchedLogRequest)) {
   60|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"Error in nanopb encoding for size: %s",
   61|      0|                   PB_GET_ERROR(&sizestream));
   62|      0|  }
   63|      1|
   64|      1|  // Encode a 2nd time to actually get the bytes from it.
   65|      1|  size_t bufferSize = sizestream.bytes_written;
   66|      1|  CFMutableDataRef dataRef = CFDataCreateMutable(CFAllocatorGetDefault(), bufferSize);
   67|      1|  CFDataSetLength(dataRef, bufferSize);
   68|      1|  pb_ostream_t ostream = pb_ostream_from_buffer((void *)CFDataGetBytePtr(dataRef), bufferSize);
   69|      1|  if (!pb_encode(&ostream, gdt_cct_BatchedLogRequest_fields, batchedLogRequest)) {
   70|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"Error in nanopb encoding for bytes: %s",
   71|      0|                   PB_GET_ERROR(&ostream));
   72|      0|  }
   73|      1|
   74|      1|  return CFBridgingRelease(dataRef);
   75|      1|}
   76|       |
   77|       |gdt_cct_BatchedLogRequest GDTCCTConstructBatchedLogRequest(
   78|      1|    NSDictionary<NSString *, NSSet<GDTCOREvent *> *> *logMappingIDToLogSet) {
   79|      1|  gdt_cct_BatchedLogRequest batchedLogRequest = gdt_cct_BatchedLogRequest_init_default;
   80|      1|  NSUInteger numberOfLogRequests = logMappingIDToLogSet.count;
   81|      1|  gdt_cct_LogRequest *logRequests = malloc(sizeof(gdt_cct_LogRequest) * numberOfLogRequests);
   82|      1|  if (logRequests == NULL) {
   83|      0|    return batchedLogRequest;
   84|      0|  }
   85|      1|
   86|      1|  __block int i = 0;
   87|      1|  [logMappingIDToLogSet enumerateKeysAndObjectsUsingBlock:^(NSString *_Nonnull logMappingID,
   88|      1|                                                            NSSet<GDTCOREvent *> *_Nonnull logSet,
   89|      1|                                                            BOOL *_Nonnull stop) {
   90|      1|    int32_t logSource = [logMappingID intValue];
   91|      1|    gdt_cct_LogRequest logRequest = GDTCCTConstructLogRequest(logSource, logSet);
   92|      1|    logRequests[i] = logRequest;
   93|      1|    i++;
   94|      1|  }];
   95|      1|
   96|      1|  batchedLogRequest.log_request = logRequests;
   97|      1|  batchedLogRequest.log_request_count = (pb_size_t)numberOfLogRequests;
   98|      1|  return batchedLogRequest;
   99|      1|}
  100|       |
  101|       |gdt_cct_LogRequest GDTCCTConstructLogRequest(int32_t logSource,
  102|      1|                                             NSSet<GDTCOREvent *> *_Nonnull logSet) {
  103|      1|  if (logSet.count == 0) {
  104|      0|    GDTCORLogError(GDTCORMCEGeneralError, @"%@",
  105|      0|                   @"An empty event set can't be serialized to proto.");
  106|      0|    gdt_cct_LogRequest logRequest = gdt_cct_LogRequest_init_default;
  107|      0|    return logRequest;
  108|      0|  }
  109|      1|  gdt_cct_LogRequest logRequest = gdt_cct_LogRequest_init_default;
  110|      1|  logRequest.log_source = logSource;
  111|      1|  logRequest.has_log_source = 1;
  112|      1|  logRequest.client_info = GDTCCTConstructClientInfo();
  113|      1|  logRequest.has_client_info = 1;
  114|      1|  logRequest.log_event = malloc(sizeof(gdt_cct_LogEvent) * logSet.count);
  115|      1|  if (logRequest.log_event == NULL) {
  116|      0|    return logRequest;
  117|      0|  }
  118|      1|  int i = 0;
  119|      1|  for (GDTCOREvent *log in logSet) {
  120|      1|    gdt_cct_LogEvent logEvent = GDTCCTConstructLogEvent(log);
  121|      1|    logRequest.log_event[i] = logEvent;
  122|      1|    i++;
  123|      1|  }
  124|      1|  logRequest.log_event_count = (pb_size_t)logSet.count;
  125|      1|
  126|      1|  GDTCORClock *currentTime = [GDTCORClock snapshot];
  127|      1|  logRequest.request_time_ms = currentTime.timeMillis;
  128|      1|  logRequest.has_request_time_ms = 1;
  129|      1|  logRequest.request_uptime_ms = currentTime.uptime;
  130|      1|  logRequest.has_request_uptime_ms = 1;
  131|      1|
  132|      1|  return logRequest;
  133|      1|}
  134|       |
  135|      1|gdt_cct_LogEvent GDTCCTConstructLogEvent(GDTCOREvent *event) {
  136|      1|  gdt_cct_LogEvent logEvent = gdt_cct_LogEvent_init_default;
  137|      1|  logEvent.event_time_ms = event.clockSnapshot.timeMillis;
  138|      1|  logEvent.has_event_time_ms = 1;
  139|      1|  logEvent.event_uptime_ms = event.clockSnapshot.uptime;
  140|      1|  logEvent.has_event_uptime_ms = 1;
  141|      1|  logEvent.timezone_offset_seconds = event.clockSnapshot.timezoneOffsetSeconds;
  142|      1|  logEvent.has_timezone_offset_seconds = 1;
  143|      1|  if (event.customPrioritizationParams[GDTCCTNetworkConnectionInfo]) {
  144|      0|    NSData *networkConnectionInfoData =
  145|      0|        event.customPrioritizationParams[GDTCCTNetworkConnectionInfo];
  146|      0|    [networkConnectionInfoData getBytes:&logEvent.network_connection_info
  147|      0|                                 length:networkConnectionInfoData.length];
  148|      0|    logEvent.has_network_connection_info = 1;
  149|      0|  }
  150|      1|  NSError *error;
  151|      1|  NSData *extensionBytes;
  152|      1|  if (event.fileURL) {
  153|      1|    extensionBytes = [NSData dataWithContentsOfURL:event.fileURL options:0 error:&error];
  154|      1|  } else {
  155|      0|    GDTCORLogError(GDTCORMCEFileReadError, @"%@", @"An event's fileURL property was nil.");
  156|      0|    return logEvent;
  157|      0|  }
  158|      1|  if (error) {
  159|      0|    GDTCORLogError(GDTCORMCEGeneralError,
  160|      0|                   @"There was an error reading extension bytes from disk: %@", error);
  161|      0|    return logEvent;
  162|      0|  }
  163|      1|  logEvent.source_extension = GDTCCTEncodeData(extensionBytes);  // read bytes from the file.
  164|      1|  return logEvent;
  165|      1|}
  166|       |
  167|      1|gdt_cct_ClientInfo GDTCCTConstructClientInfo() {
  168|      1|  gdt_cct_ClientInfo clientInfo = gdt_cct_ClientInfo_init_default;
  169|      1|  clientInfo.client_type = gdt_cct_ClientInfo_ClientType_IOS_FIREBASE;
  170|      1|  clientInfo.has_client_type = 1;
  171|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  172|      1|  clientInfo.ios_client_info = GDTCCTConstructiOSClientInfo();
  173|      1|  clientInfo.has_ios_client_info = 1;
  174|       |#elif TARGET_OS_OSX
  175|       |  // TODO(mikehaney24): Expand the proto to include macOS client info.
  176|       |#endif
  177|       |  return clientInfo;
  178|      1|}
  179|       |
  180|      1|gdt_cct_IosClientInfo GDTCCTConstructiOSClientInfo() {
  181|      1|  gdt_cct_IosClientInfo iOSClientInfo = gdt_cct_IosClientInfo_init_default;
  182|      1|#if TARGET_OS_IOS || TARGET_OS_TV
  183|      1|  UIDevice *device = [UIDevice currentDevice];
  184|      1|  NSBundle *bundle = [NSBundle mainBundle];
  185|      1|  NSLocale *locale = [NSLocale currentLocale];
  186|      1|  iOSClientInfo.os_full_version = GDTCCTEncodeString(device.systemVersion);
  187|      1|  NSArray *versionComponents = [device.systemVersion componentsSeparatedByString:@"."];
  188|      1|  iOSClientInfo.os_major_version = GDTCCTEncodeString(versionComponents[0]);
  189|      1|  NSString *version = [bundle objectForInfoDictionaryKey:(NSString *)kCFBundleVersionKey];
  190|      1|  if (version) {
  191|      1|    iOSClientInfo.application_build = GDTCCTEncodeString(version);
  192|      1|  }
  193|      1|  NSString *countryCode = [locale objectForKey:NSLocaleCountryCode];
  194|      1|  if (countryCode) {
  195|      1|    iOSClientInfo.country = GDTCCTEncodeString([locale objectForKey:NSLocaleCountryCode]);
  196|      1|  }
  197|      1|  iOSClientInfo.model = GDTCCTEncodeString(device.model);
  198|      1|  NSString *languageCode = bundle.preferredLocalizations.firstObject;
  199|      1|  iOSClientInfo.language_code =
  200|      1|      languageCode ? GDTCCTEncodeString(languageCode) : GDTCCTEncodeString(@"en");
  201|      1|  iOSClientInfo.application_bundle_id = GDTCCTEncodeString(bundle.bundleIdentifier);
  202|      1|#endif
  203|      1|  return iOSClientInfo;
  204|      1|}
  205|       |
  206|      0|NSData *GDTCCTConstructNetworkConnectionInfoData() {
  207|      0|  gdt_cct_NetworkConnectionInfo networkConnectionInfo = gdt_cct_NetworkConnectionInfo_init_default;
  208|      0|  NSInteger currentNetworkType = GDTCORNetworkTypeMessage();
  209|      0|  if (currentNetworkType) {
  210|      0|    networkConnectionInfo.has_network_type = 1;
  211|      0|    if (currentNetworkType == GDTCORNetworkTypeMobile) {
  212|      0|      networkConnectionInfo.network_type = gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE;
  213|      0|      networkConnectionInfo.mobile_subtype = GDTCCTNetworkConnectionInfoNetworkMobileSubtype();
  214|      0|      if (networkConnectionInfo.mobile_subtype !=
  215|      0|          gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE) {
  216|      0|        networkConnectionInfo.has_mobile_subtype = 1;
  217|      0|      }
  218|      0|    } else {
  219|      0|      networkConnectionInfo.network_type = gdt_cct_NetworkConnectionInfo_NetworkType_WIFI;
  220|      0|    }
  221|      0|  }
  222|      0|  NSData *networkConnectionInfoData = [NSData dataWithBytes:&networkConnectionInfo
  223|      0|                                                     length:sizeof(networkConnectionInfo)];
  224|      0|  return networkConnectionInfoData;
  225|      0|}
  226|       |
  227|      0|gdt_cct_NetworkConnectionInfo_MobileSubtype GDTCCTNetworkConnectionInfoNetworkMobileSubtype() {
  228|      0|  NSNumber *networkMobileSubtypeMessage = @(GDTCORNetworkMobileSubTypeMessage());
  229|      0|  if (!networkMobileSubtypeMessage.intValue) {
  230|      0|    return gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE;
  231|      0|  }
  232|      0|  static NSDictionary<NSNumber *, NSNumber *> *MessageToNetworkSubTypeMessage;
  233|      0|  static dispatch_once_t onceToken;
  234|      0|  dispatch_once(&onceToken, ^{
  235|      0|    MessageToNetworkSubTypeMessage = @{
  236|      0|      @(GDTCORNetworkMobileSubtypeGPRS) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_GPRS),
  237|      0|      @(GDTCORNetworkMobileSubtypeEdge) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_EDGE),
  238|      0|      @(GDTCORNetworkMobileSubtypeWCDMA) :
  239|      0|          @(gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE),
  240|      0|      @(GDTCORNetworkMobileSubtypeHSDPA) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_HSDPA),
  241|      0|      @(GDTCORNetworkMobileSubtypeHSUPA) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_HSUPA),
  242|      0|      @(GDTCORNetworkMobileSubtypeCDMA1x) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_CDMA),
  243|      0|      @(GDTCORNetworkMobileSubtypeCDMAEVDORev0) :
  244|      0|          @(gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_0),
  245|      0|      @(GDTCORNetworkMobileSubtypeCDMAEVDORevA) :
  246|      0|          @(gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_A),
  247|      0|      @(GDTCORNetworkMobileSubtypeCDMAEVDORevB) :
  248|      0|          @(gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_B),
  249|      0|      @(GDTCORNetworkMobileSubtypeHRPD) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_EHRPD),
  250|      0|      @(GDTCORNetworkMobileSubtypeLTE) : @(gdt_cct_NetworkConnectionInfo_MobileSubtype_LTE),
  251|      0|    };
  252|      0|  });
  253|      0|  NSNumber *networkMobileSubtype = MessageToNetworkSubTypeMessage[networkMobileSubtypeMessage];
  254|      0|  return networkMobileSubtype.intValue;
  255|      0|}
  256|       |
  257|       |#pragma mark - CCT Object decoders
  258|       |
  259|      0|gdt_cct_LogResponse GDTCCTDecodeLogResponse(NSData *data, NSError **error) {
  260|      0|  gdt_cct_LogResponse response = gdt_cct_LogResponse_init_default;
  261|      0|  pb_istream_t istream = pb_istream_from_buffer([data bytes], [data length]);
  262|      0|  if (!pb_decode(&istream, gdt_cct_LogResponse_fields, &response)) {
  263|      0|    NSString *nanopb_error = [NSString stringWithFormat:@"%s", PB_GET_ERROR(&istream)];
  264|      0|    NSDictionary *userInfo = @{@"nanopb error:" : nanopb_error};
  265|      0|    if (error != NULL) {
  266|      0|      *error = [NSError errorWithDomain:NSURLErrorDomain code:-1 userInfo:userInfo];
  267|      0|    }
  268|      0|    response = (gdt_cct_LogResponse)gdt_cct_LogResponse_init_default;
  269|      0|  }
  270|      0|  return response;
  271|      0|}

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransportCCTSupport/GoogleDataTransportCCTSupport/GDTCCTLibrary/GDTCCTPrioritizer.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCCTLibrary/Private/GDTCCTPrioritizer.h"
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   20|       |#import <GoogleDataTransport/GDTCOREvent.h>
   21|       |#import <GoogleDataTransport/GDTCORPlatform.h>
   22|       |#import <GoogleDataTransport/GDTCORRegistrar.h>
   23|       |#import <GoogleDataTransport/GDTCORTargets.h>
   24|       |
   25|       |#import "GDTCCTLibrary/Private/GDTCCTNanopbHelpers.h"
   26|       |
   27|       |const static int64_t kMillisPerDay = 8.64e+7;
   28|       |
   29|       |/** Creates and/or returns a singleton NSString that is the NSCoding file location.
   30|       | *
   31|       | * @return The NSCoding file path.
   32|       | */
   33|      6|static NSString *ArchivePath() {
   34|      6|  static NSString *archivePath;
   35|      6|  static dispatch_once_t onceToken;
   36|      6|  dispatch_once(&onceToken, ^{
   37|      1|    archivePath = [GDTCORRootDirectory() URLByAppendingPathComponent:@"GDTCCTPrioritizer"].path;
   38|      1|  });
   39|      6|  return archivePath;
   40|      6|}
   41|       |
   42|       |@implementation GDTCCTPrioritizer
   43|       |
   44|      1|+ (void)load {
   45|      1|  GDTCCTPrioritizer *prioritizer = [GDTCCTPrioritizer sharedInstance];
   46|      1|  [[GDTCORRegistrar sharedInstance] registerPrioritizer:prioritizer target:kGDTCORTargetCCT];
   47|      1|  [[GDTCORRegistrar sharedInstance] registerPrioritizer:prioritizer target:kGDTCORTargetFLL];
   48|      1|  [[GDTCORRegistrar sharedInstance] registerPrioritizer:prioritizer target:kGDTCORTargetCSH];
   49|      1|}
   50|       |
   51|      0|+ (BOOL)supportsSecureCoding {
   52|      0|  return YES;
   53|      0|}
   54|       |
   55|      4|+ (instancetype)sharedInstance {
   56|      4|  static GDTCCTPrioritizer *sharedInstance;
   57|      4|  static dispatch_once_t onceToken;
   58|      4|  dispatch_once(&onceToken, ^{
   59|      1|    sharedInstance = [[GDTCCTPrioritizer alloc] init];
   60|      1|  });
   61|      4|  return sharedInstance;
   62|      4|}
   63|       |
   64|      1|- (instancetype)init {
   65|      1|  self = [super init];
   66|      1|  if (self) {
   67|      1|    _queue = dispatch_queue_create("com.google.GDTCCTPrioritizer", DISPATCH_QUEUE_SERIAL);
   68|      1|    _CCTEvents = [[NSMutableSet alloc] init];
   69|      1|    _FLLEvents = [[NSMutableSet alloc] init];
   70|      1|    _CSHEvents = [[NSMutableSet alloc] init];
   71|      1|  }
   72|      1|  return self;
   73|      1|}
   74|       |
   75|       |#pragma mark - GDTCORPrioritizer Protocol
   76|       |
   77|      2|- (void)prioritizeEvent:(GDTCOREvent *)event {
   78|      2|  if (event.customPrioritizationParams[GDTCCTNeedsNetworkConnectionInfo]) {
   79|      0|    NSData *networkInfoData = GDTCCTConstructNetworkConnectionInfoData();
   80|      0|    if (networkInfoData) {
   81|      0|      event.customPrioritizationParams = @{GDTCCTNetworkConnectionInfo : networkInfoData};
   82|      0|    }
   83|      0|  }
   84|      2|  dispatch_async(_queue, ^{
   85|      2|    switch (event.target) {
   86|      2|      case kGDTCORTargetCCT:
   87|      0|        [self.CCTEvents addObject:event];
   88|      0|        break;
   89|      2|
   90|      2|      case kGDTCORTargetFLL:
   91|      2|        [self.FLLEvents addObject:event];
   92|      2|        break;
   93|      2|
   94|      2|      case kGDTCORTargetCSH:
   95|      0|        [self.CSHEvents addObject:event];
   96|      0|        break;
   97|      2|
   98|      2|      default:
   99|      0|        GDTCORLogDebug("GDTCCTPrioritizer doesn't support target %ld", (long)event.target);
  100|      0|        break;
  101|      2|    }
  102|      2|  });
  103|      2|}
  104|       |
  105|       |- (GDTCORUploadPackage *)uploadPackageWithTarget:(GDTCORTarget)target
  106|      4|                                      conditions:(GDTCORUploadConditions)conditions {
  107|      4|  GDTCORUploadPackage *package = [[GDTCORUploadPackage alloc] initWithTarget:target];
  108|      4|  dispatch_sync(_queue, ^{
  109|      4|    NSSet<GDTCOREvent *> *eventsThatWillBeSent = [self eventsForTarget:target
  110|      4|                                                            conditions:conditions];
  111|      4|    package.events = eventsThatWillBeSent;
  112|      4|  });
  113|      4|  GDTCORLogDebug("CCT: %lu events are in the upload package", (unsigned long)package.events.count);
  114|      4|  return package;
  115|      4|}
  116|       |
  117|       |#pragma mark - Private helper methods
  118|       |
  119|       |/** The different possible quality of service specifiers. High values indicate high priority. */
  120|       |typedef NS_ENUM(NSInteger, GDTCCTQoSTier) {
  121|       |  /** The QoS tier wasn't set, and won't ever be sent. */
  122|       |  GDTCCTQoSDefault = 0,
  123|       |
  124|       |  /** This event is internal telemetry data that should not be sent on its own if possible. */
  125|       |  GDTCCTQoSTelemetry = 1,
  126|       |
  127|       |  /** This event should be sent, but in a batch only roughly once per day. */
  128|       |  GDTCCTQoSDaily = 2,
  129|       |
  130|       |  /** This event should only be uploaded on wifi. */
  131|       |  GDTCCTQoSWifiOnly = 5,
  132|       |};
  133|       |
  134|      0|- (void)saveState {
  135|      0|  dispatch_sync(_queue, ^{
  136|      0|    NSError *error;
  137|      0|    GDTCOREncodeArchive(self, ArchivePath(), &error);
  138|      0|    if (error) {
  139|      0|      GDTCORLogDebug(@"Serializing GDTCCTPrioritizer to an archive failed: %@", error);
  140|      0|    }
  141|      0|  });
  142|      0|  GDTCORLogDebug(@"GDTCCTPrioritizer saved state to %@ as requested by GDT.", ArchivePath());
  143|      0|}
  144|       |
  145|       |/** Converts a GDTCOREventQoS to a GDTCCTQoS tier.
  146|       | *
  147|       | * @param qosTier The GDTCOREventQoS value.
  148|       | * @return A static NSNumber that represents the CCT QoS tier.
  149|       | */
  150|       |FOUNDATION_STATIC_INLINE
  151|      1|NSNumber *GDTCCTQosTierFromGDTCOREventQosTier(GDTCOREventQoS qosTier) {
  152|      1|  switch (qosTier) {
  153|      1|    case GDTCOREventQoSWifiOnly:
  154|      0|      return @(GDTCCTQoSWifiOnly);
  155|      1|      break;
  156|      1|
  157|      1|    case GDTCOREventQoSTelemetry:
  158|      1|      // falls through.
  159|      1|    case GDTCOREventQoSDaily:
  160|      1|      return @(GDTCCTQoSDaily);
  161|      1|      break;
  162|      1|
  163|      1|    default:
  164|      0|      return @(GDTCCTQoSDefault);
  165|      1|      break;
  166|      1|  }
  167|      1|}
  168|       |
  169|       |/** Constructs a set of events for upload to CCT, FLL, or CSH backends. These backends are
  170|       | * request-proto and batching compatible, so they construct event batches the same way.
  171|       | *
  172|       | * @param conditions The set of conditions the upload package should be made under.
  173|       | * @param target The target backend.
  174|       | * @return A set of events for the target.
  175|       | */
  176|       |- (NSSet<GDTCOREvent *> *)eventsForTarget:(GDTCORTarget)target
  177|      4|                               conditions:(GDTCORUploadConditions)conditions {
  178|      4|  GDTCORClock __strong **timeOfLastDailyUpload = NULL;
  179|      4|  NSSet<GDTCOREvent *> *eventsToFilter;
  180|      4|  switch (target) {
  181|      4|    case kGDTCORTargetCCT:
  182|      2|      eventsToFilter = self.CCTEvents;
  183|      2|      timeOfLastDailyUpload = &self->_CCTTimeOfLastDailyUpload;
  184|      2|      break;
  185|      4|
  186|      4|    case kGDTCORTargetFLL:
  187|      2|      eventsToFilter = self.FLLEvents;
  188|      2|      timeOfLastDailyUpload = &self->_FLLOfLastDailyUpload;
  189|      2|      break;
  190|      4|
  191|      4|    case kGDTCORTargetCSH:
  192|      0|      // This backend doesn't batch and uploads all events as soon as possible without respect to
  193|      0|      // any upload condition.
  194|      0|      return self.CSHEvents;
  195|      4|      break;
  196|      4|
  197|      4|    default:
  198|      0|      // Return an empty set.
  199|      0|      return [[NSSet alloc] init];
  200|      4|      break;
  201|      4|  }
  202|      4|
  203|      4|  NSMutableSet<GDTCOREvent *> *eventsThatWillBeSent = [[NSMutableSet alloc] init];
  204|      4|  // A high priority event effectively flushes all events to be sent.
  205|      4|  if ((conditions & GDTCORUploadConditionHighPriority) == GDTCORUploadConditionHighPriority) {
  206|      0|    GDTCORLogDebug("%@", @"CCT: A high priority event is flushing all events.");
  207|      0|    return eventsToFilter;
  208|      0|  }
  209|      4|
  210|      4|  // If on wifi, upload logs that are ok to send on wifi.
  211|      4|  if ((conditions & GDTCORUploadConditionWifiData) == GDTCORUploadConditionWifiData) {
  212|      4|    [eventsThatWillBeSent unionSet:[self logEventsOkToSendOnWifi:eventsToFilter]];
  213|      4|    GDTCORLogDebug("%@", @"CCT: events ok to send on wifi are being added to the upload package");
  214|      4|  } else {
  215|      0|    [eventsThatWillBeSent unionSet:[self logEventsOkToSendOnMobileData:eventsToFilter]];
  216|      0|    GDTCORLogDebug("%@", @"CCT: events ok to send on mobile are being added to the upload package");
  217|      0|  }
  218|      4|
  219|      4|  // If it's been > 24h since the last daily upload, upload logs with the daily QoS.
  220|      4|  if (*timeOfLastDailyUpload) {
  221|      2|    int64_t millisSinceLastUpload =
  222|      2|        [GDTCORClock snapshot].timeMillis - (*timeOfLastDailyUpload).timeMillis;
  223|      2|    if (millisSinceLastUpload > kMillisPerDay) {
  224|      0|      [eventsThatWillBeSent unionSet:[self logEventsOkToSendDaily:eventsToFilter]];
  225|      0|      GDTCORLogDebug("%@", @"CCT: events ok to send daily are being added to the upload package");
  226|      0|    }
  227|      2|  } else {
  228|      2|    *timeOfLastDailyUpload = [GDTCORClock snapshot];
  229|      2|    [eventsThatWillBeSent unionSet:[self logEventsOkToSendDaily:eventsToFilter]];
  230|      2|    GDTCORLogDebug("%@", @"CCT: events ok to send daily are being added to the upload package");
  231|      2|  }
  232|      4|  return eventsThatWillBeSent;
  233|      4|}
  234|       |
  235|       |/** Returns a set of logs that are ok to upload whilst on mobile data.
  236|       | *
  237|       | * @note This should be called from a thread safe method.
  238|       | * @return A set of logs that are ok to upload whilst on mobile data.
  239|       | */
  240|      0|- (NSSet<GDTCOREvent *> *)logEventsOkToSendOnMobileData:(NSSet<GDTCOREvent *> *)events {
  241|      0|  return [events objectsPassingTest:^BOOL(GDTCOREvent *_Nonnull event, BOOL *_Nonnull stop) {
  242|      0|    return [GDTCCTQosTierFromGDTCOREventQosTier(event.qosTier) isEqual:@(GDTCCTQoSDefault)];
  243|      0|  }];
  244|      0|}
  245|       |
  246|       |/** Returns a set of logs that are ok to upload whilst on wifi.
  247|       | *
  248|       | * @note This should be called from a thread safe method.
  249|       | * @return A set of logs that are ok to upload whilst on wifi.
  250|       | */
  251|      4|- (NSSet<GDTCOREvent *> *)logEventsOkToSendOnWifi:(NSSet<GDTCOREvent *> *)events {
  252|      4|  return [events objectsPassingTest:^BOOL(GDTCOREvent *_Nonnull event, BOOL *_Nonnull stop) {
  253|      1|    NSNumber *qosTier = GDTCCTQosTierFromGDTCOREventQosTier(event.qosTier);
  254|      1|    return [qosTier isEqual:@(GDTCCTQoSDefault)] || [qosTier isEqual:@(GDTCCTQoSWifiOnly)] ||
  255|      1|           [qosTier isEqual:@(GDTCCTQoSDaily)];
  256|      1|  }];
  257|      4|}
  258|       |
  259|       |/** Returns a set of logs that only should have a single upload attempt per day.
  260|       | *
  261|       | * @note This should be called from a thread safe method.
  262|       | * @return A set of logs that are ok to upload only once per day.
  263|       | */
  264|      2|- (NSSet<GDTCOREvent *> *)logEventsOkToSendDaily:(NSSet<GDTCOREvent *> *)events {
  265|      2|  return [events objectsPassingTest:^BOOL(GDTCOREvent *_Nonnull event, BOOL *_Nonnull stop) {
  266|      0|    return [GDTCCTQosTierFromGDTCOREventQosTier(event.qosTier) isEqual:@(GDTCCTQoSDaily)];
  267|      0|  }];
  268|      2|}
  269|       |
  270|       |#pragma mark - NSSecureCoding
  271|       |
  272|       |/** NSSecureCoding key for the CCTEvents property. */
  273|       |static NSString *const GDTCCTUploaderCCTEventsKey = @"GDTCCTUploaderCCTEventsKey";
  274|       |
  275|       |/** NSSecureCoding key for the CCTEvents property. */
  276|       |static NSString *const GDTCCTUploaderFLLEventsKey = @"GDTCCTUploaderFLLEventsKey";
  277|       |
  278|       |/** NSSecureCoding key for the CCTEvents property. */
  279|       |static NSString *const GDTCCTUploaderCSHEventsKey = @"GDTCCTUploaderCSHEventsKey";
  280|       |
  281|      0|- (instancetype)initWithCoder:(NSCoder *)coder {
  282|      0|  GDTCCTPrioritizer *sharedInstance = [GDTCCTPrioritizer sharedInstance];
  283|      0|  if (sharedInstance) {
  284|      0|    NSSet *classes = [NSSet setWithObjects:[NSMutableSet class], [GDTCOREvent class], nil];
  285|      0|    NSMutableSet *decodedCCTEvents = [coder decodeObjectOfClasses:classes
  286|      0|                                                           forKey:GDTCCTUploaderCCTEventsKey];
  287|      0|    if (decodedCCTEvents) {
  288|      0|      sharedInstance->_CCTEvents = decodedCCTEvents;
  289|      0|    }
  290|      0|    NSMutableSet *decodedFLLEvents = [coder decodeObjectOfClasses:classes
  291|      0|                                                           forKey:GDTCCTUploaderFLLEventsKey];
  292|      0|    if (decodedFLLEvents) {
  293|      0|      sharedInstance->_FLLEvents = decodedFLLEvents;
  294|      0|    }
  295|      0|    NSMutableSet *decodedCSHEvents = [coder decodeObjectOfClasses:classes
  296|      0|                                                           forKey:GDTCCTUploaderCSHEventsKey];
  297|      0|    if (decodedCSHEvents) {
  298|      0|      sharedInstance->_CSHEvents = decodedCSHEvents;
  299|      0|    }
  300|      0|  }
  301|      0|  return sharedInstance;
  302|      0|}
  303|       |
  304|      0|- (void)encodeWithCoder:(NSCoder *)coder {
  305|      0|  GDTCCTPrioritizer *sharedInstance = [GDTCCTPrioritizer sharedInstance];
  306|      0|  NSMutableSet<GDTCOREvent *> *CCTEvents = sharedInstance->_CCTEvents;
  307|      0|  if (CCTEvents) {
  308|      0|    [coder encodeObject:CCTEvents forKey:GDTCCTUploaderCCTEventsKey];
  309|      0|  }
  310|      0|  NSMutableSet<GDTCOREvent *> *FLLEvents = sharedInstance->_FLLEvents;
  311|      0|  if (FLLEvents) {
  312|      0|    [coder encodeObject:FLLEvents forKey:GDTCCTUploaderFLLEventsKey];
  313|      0|  }
  314|      0|  NSMutableSet<GDTCOREvent *> *CSHEvents = sharedInstance->_CSHEvents;
  315|      0|  if (CSHEvents) {
  316|      0|    [coder encodeObject:CSHEvents forKey:GDTCCTUploaderCSHEventsKey];
  317|      0|  }
  318|      0|}
  319|       |
  320|       |#pragma mark - GDTCORLifecycleProtocol
  321|       |
  322|      6|- (void)appWillForeground:(GDTCORApplication *)app {
  323|      6|  NSError *error;
  324|      6|  GDTCORDecodeArchive([GDTCCTPrioritizer class], ArchivePath(), nil, &error);
  325|      6|  if (error) {
  326|      0|    GDTCORLogDebug(@"Deserializing GDTCCTPrioritizer from an archive failed: %@", error);
  327|      0|  }
  328|      6|}
  329|       |
  330|      0|- (void)appWillBackground:(GDTCORApplication *)app {
  331|      0|  dispatch_async(_queue, ^{
  332|      0|    // Immediately request a background task to run until the end of the current queue of work, and
  333|      0|    // cancel it once the work is done.
  334|      0|    __block GDTCORBackgroundIdentifier bgID =
  335|      0|        [app beginBackgroundTaskWithName:@"GDTStorage"
  336|      0|                       expirationHandler:^{
  337|      0|                         [app endBackgroundTask:bgID];
  338|      0|                         bgID = GDTCORBackgroundIdentifierInvalid;
  339|      0|                       }];
  340|      0|    NSError *error;
  341|      0|    GDTCOREncodeArchive(self, ArchivePath(), &error);
  342|      0|    if (error) {
  343|      0|      GDTCORLogDebug(@"Serializing GDTCCTPrioritizer to an archive failed: %@", error);
  344|      0|    }
  345|      0|
  346|      0|    // End the background task if it's still valid.
  347|      0|    [app endBackgroundTask:bgID];
  348|      0|    bgID = GDTCORBackgroundIdentifierInvalid;
  349|      0|  });
  350|      0|}
  351|       |
  352|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
  353|      0|  dispatch_sync(_queue, ^{
  354|      0|    NSError *error;
  355|      0|    GDTCOREncodeArchive(self, ArchivePath(), &error);
  356|      0|    if (error) {
  357|      0|      GDTCORLogDebug(@"Serializing GDTCCTPrioritizer to an archive failed: %@", error);
  358|      0|    }
  359|      0|  });
  360|      0|}
  361|       |
  362|       |#pragma mark - GDTCORUploadPackageProtocol
  363|       |
  364|      3|- (void)packageDelivered:(GDTCORUploadPackage *)package successful:(BOOL)successful {
  365|      3|  // If sending the package wasn't successful, we should keep track of these events.
  366|      3|  if (!successful) {
  367|      0|    return;
  368|      0|  }
  369|      3|
  370|      3|  dispatch_async(_queue, ^{
  371|      3|    NSSet<GDTCOREvent *> *events = [package.events copy];
  372|      3|    for (GDTCOREvent *event in events) {
  373|      0|      // We don't know what collection the event was contained in, so attempt removal from all.
  374|      0|      [self.CCTEvents removeObject:event];
  375|      0|      [self.FLLEvents removeObject:event];
  376|      0|      [self.CSHEvents removeObject:event];
  377|      0|    }
  378|      3|  });
  379|      3|}
  380|       |
  381|      0|- (void)packageExpired:(GDTCORUploadPackage *)package {
  382|      0|  [self packageDelivered:package successful:YES];
  383|      0|}
  384|       |
  385|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransportCCTSupport/GoogleDataTransportCCTSupport/GDTCCTLibrary/GDTCCTUploader.m:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "GDTCCTLibrary/Private/GDTCCTUploader.h"
   18|       |
   19|       |#import <GoogleDataTransport/GDTCORConsoleLogger.h>
   20|       |#import <GoogleDataTransport/GDTCORPlatform.h>
   21|       |#import <GoogleDataTransport/GDTCORRegistrar.h>
   22|       |
   23|       |#import <nanopb/pb.h>
   24|       |#import <nanopb/pb_decode.h>
   25|       |#import <nanopb/pb_encode.h>
   26|       |
   27|       |#import "GDTCCTLibrary/Private/GDTCCTCompressionHelper.h"
   28|       |#import "GDTCCTLibrary/Private/GDTCCTNanopbHelpers.h"
   29|       |#import "GDTCCTLibrary/Private/GDTCCTPrioritizer.h"
   30|       |
   31|       |#import "GDTCCTLibrary/Protogen/nanopb/cct.nanopb.h"
   32|       |
   33|       |#ifdef GDTCCTSUPPORT_VERSION
   34|       |#define STR(x) STR_EXPAND(x)
   35|       |#define STR_EXPAND(x) #x
   36|       |static NSString *const kGDTCCTSupportSDKVersion = @STR(GDTCCTSUPPORT_VERSION);
   37|       |#else
   38|       |static NSString *const kGDTCCTSupportSDKVersion = @"UNKNOWN";
   39|       |#endif  // GDTCCTSUPPORT_VERSION
   40|       |
   41|       |#if !NDEBUG
   42|       |NSNotificationName const GDTCCTUploadCompleteNotification = @"com.GDTCCTUploader.UploadComplete";
   43|       |#endif  // #if !NDEBUG
   44|       |
   45|       |@interface GDTCCTUploader () <NSURLSessionDelegate>
   46|       |
   47|       |// Redeclared as readwrite.
   48|       |@property(nullable, nonatomic, readwrite) NSURLSessionUploadTask *currentTask;
   49|       |
   50|       |@end
   51|       |
   52|       |@implementation GDTCCTUploader
   53|       |
   54|      1|+ (void)load {
   55|      1|  GDTCCTUploader *uploader = [GDTCCTUploader sharedInstance];
   56|      1|  [[GDTCORRegistrar sharedInstance] registerUploader:uploader target:kGDTCORTargetCCT];
   57|      1|  [[GDTCORRegistrar sharedInstance] registerUploader:uploader target:kGDTCORTargetFLL];
   58|      1|  [[GDTCORRegistrar sharedInstance] registerUploader:uploader target:kGDTCORTargetCSH];
   59|      1|}
   60|       |
   61|      1|+ (instancetype)sharedInstance {
   62|      1|  static GDTCCTUploader *sharedInstance;
   63|      1|  static dispatch_once_t onceToken;
   64|      1|  dispatch_once(&onceToken, ^{
   65|      1|    sharedInstance = [[GDTCCTUploader alloc] init];
   66|      1|  });
   67|      1|  return sharedInstance;
   68|      1|}
   69|       |
   70|      1|- (instancetype)init {
   71|      1|  self = [super init];
   72|      1|  if (self) {
   73|      1|    _uploaderQueue = dispatch_queue_create("com.google.GDTCCTUploader", DISPATCH_QUEUE_SERIAL);
   74|      1|    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
   75|      1|    _uploaderSession = [NSURLSession sessionWithConfiguration:config
   76|      1|                                                     delegate:self
   77|      1|                                                delegateQueue:nil];
   78|      1|  }
   79|      1|  return self;
   80|      1|}
   81|       |
   82|       |/**
   83|       | *
   84|       | */
   85|      1|- (nullable NSURL *)serverURLForTarget:(GDTCORTarget)target {
   86|      1|  // These strings should be interleaved to construct the real URL. This is just to (hopefully)
   87|      1|  // fool github URL scanning bots.
   88|      1|  static NSURL *CCTServerURL;
   89|      1|  static dispatch_once_t CCTOnceToken;
   90|      1|  dispatch_once(&CCTOnceToken, ^{
   91|      1|    const char *p1 = "hts/frbslgiggolai.o/0clgbth";
   92|      1|    const char *p2 = "tp:/ieaeogn.ogepscmvc/o/ac";
   93|      1|    const char URL[54] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],  p1[4],
   94|      1|                          p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],  p1[8],  p2[8],
   95|      1|                          p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11], p1[12], p2[12], p1[13],
   96|      1|                          p2[13], p1[14], p2[14], p1[15], p2[15], p1[16], p2[16], p1[17], p2[17],
   97|      1|                          p1[18], p2[18], p1[19], p2[19], p1[20], p2[20], p1[21], p2[21], p1[22],
   98|      1|                          p2[22], p1[23], p2[23], p1[24], p2[24], p1[25], p2[25], p1[26], '\0'};
   99|      1|    CCTServerURL = [NSURL URLWithString:[NSString stringWithUTF8String:URL]];
  100|      1|  });
  101|      1|
  102|      1|  static NSURL *FLLServerURL;
  103|      1|  static dispatch_once_t FLLOnceToken;
  104|      1|  dispatch_once(&FLLOnceToken, ^{
  105|      1|    const char *p1 = "hts/frbslgigp.ogepscmv/ieo/eaybtho";
  106|      1|    const char *p2 = "tp:/ieaeogn-agolai.o/1frlglgc/aclg";
  107|      1|    const char URL[69] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],  p1[4],
  108|      1|                          p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],  p1[8],  p2[8],
  109|      1|                          p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11], p1[12], p2[12], p1[13],
  110|      1|                          p2[13], p1[14], p2[14], p1[15], p2[15], p1[16], p2[16], p1[17], p2[17],
  111|      1|                          p1[18], p2[18], p1[19], p2[19], p1[20], p2[20], p1[21], p2[21], p1[22],
  112|      1|                          p2[22], p1[23], p2[23], p1[24], p2[24], p1[25], p2[25], p1[26], p2[26],
  113|      1|                          p1[27], p2[27], p1[28], p2[28], p1[29], p2[29], p1[30], p2[30], p1[31],
  114|      1|                          p2[31], p1[32], p2[32], p1[33], p2[33], '\0'};
  115|      1|    FLLServerURL = [NSURL URLWithString:[NSString stringWithUTF8String:URL]];
  116|      1|  });
  117|      1|
  118|      1|  static NSURL *CSHServerURL;
  119|      1|  static dispatch_once_t CSHOnceToken;
  120|      1|  dispatch_once(&CSHOnceToken, ^{
  121|      1|    // These strings should be interleaved to construct the real URL. This is just to (hopefully)
  122|      1|    // fool github URL scanning bots.
  123|      1|    const char *p1 = "hts/cahyiseot-agolai.o/1frlglgc/aclg";
  124|      1|    const char *p2 = "tp:/rsltcrprsp.ogepscmv/ieo/eaybtho";
  125|      1|    const char URL[72] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],  p1[4],
  126|      1|                          p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],  p1[8],  p2[8],
  127|      1|                          p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11], p1[12], p2[12], p1[13],
  128|      1|                          p2[13], p1[14], p2[14], p1[15], p2[15], p1[16], p2[16], p1[17], p2[17],
  129|      1|                          p1[18], p2[18], p1[19], p2[19], p1[20], p2[20], p1[21], p2[21], p1[22],
  130|      1|                          p2[22], p1[23], p2[23], p1[24], p2[24], p1[25], p2[25], p1[26], p2[26],
  131|      1|                          p1[27], p2[27], p1[28], p2[28], p1[29], p2[29], p1[30], p2[30], p1[31],
  132|      1|                          p2[31], p1[32], p2[32], p1[33], p2[33], p1[34], p2[34], p1[35], '\0'};
  133|      1|    CSHServerURL = [NSURL URLWithString:[NSString stringWithUTF8String:URL]];
  134|      1|  });
  135|      1|
  136|      1|#if !NDEBUG
  137|      1|  if (_testServerURL) {
  138|      0|    return _testServerURL;
  139|      0|  }
  140|      1|#endif  // !NDEBUG
  141|      1|
  142|      1|  switch (target) {
  143|      1|    case kGDTCORTargetCCT:
  144|      0|      return CCTServerURL;
  145|      1|
  146|      1|    case kGDTCORTargetFLL:
  147|      1|      return FLLServerURL;
  148|      1|
  149|      1|    case kGDTCORTargetCSH:
  150|      0|      return CSHServerURL;
  151|      1|
  152|      1|    default:
  153|      0|      GDTCORLogDebug("GDTCCTUploader doesn't support target %ld", (long)target);
  154|      0|      return nil;
  155|      1|      break;
  156|      1|  }
  157|      1|}
  158|       |
  159|      1|- (NSString *)FLLAndCSHAPIKey {
  160|      1|  static NSString *defaultServerKey;
  161|      1|  static dispatch_once_t onceToken;
  162|      1|  dispatch_once(&onceToken, ^{
  163|      1|    // These strings should be interleaved to construct the real key.
  164|      1|    const char *p1 = "AzSBG0honD6A-PxV5nBc";
  165|      1|    const char *p2 = "Iay44Iwtu2vV0AOrz1C";
  166|      1|    const char defaultKey[40] = {p1[0],  p2[0],  p1[1],  p2[1],  p1[2],  p2[2],  p1[3],  p2[3],
  167|      1|                                 p1[4],  p2[4],  p1[5],  p2[5],  p1[6],  p2[6],  p1[7],  p2[7],
  168|      1|                                 p1[8],  p2[8],  p1[9],  p2[9],  p1[10], p2[10], p1[11], p2[11],
  169|      1|                                 p1[12], p2[12], p1[13], p2[13], p1[14], p2[14], p1[15], p2[15],
  170|      1|                                 p1[16], p2[16], p1[17], p2[17], p1[18], p2[18], p1[19], '\0'};
  171|      1|    defaultServerKey = [NSString stringWithUTF8String:defaultKey];
  172|      1|  });
  173|      1|  return defaultServerKey;
  174|      1|}
  175|       |
  176|      1|- (void)uploadPackage:(GDTCORUploadPackage *)package {
  177|      1|  __block GDTCORBackgroundIdentifier bgID = GDTCORBackgroundIdentifierInvalid;
  178|      1|  bgID = [[GDTCORApplication sharedApplication]
  179|      1|      beginBackgroundTaskWithName:@"GDTCCTUploader-upload"
  180|      1|                expirationHandler:^{
  181|      0|                  if (bgID != GDTCORBackgroundIdentifierInvalid) {
  182|      0|                    // Cancel the upload and complete delivery.
  183|      0|                    [self.currentTask cancel];
  184|      0|                    [self.currentUploadPackage completeDelivery];
  185|      0|
  186|      0|                    // End the background task.
  187|      0|                    [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
  188|      0|                  }
  189|      0|                }];
  190|      1|
  191|      1|  dispatch_async(_uploaderQueue, ^{
  192|      1|    if (self->_currentTask || self->_currentUploadPackage) {
  193|      0|      GDTCORLogWarning(GDTCORMCWUploadFailed, @"%@",
  194|      0|                       @"An upload shouldn't be initiated with another in progress.");
  195|      0|      return;
  196|      0|    }
  197|      1|    GDTCORTarget target = package.target;
  198|      1|    id completionHandler = ^(NSData *_Nullable data, NSURLResponse *_Nullable response,
  199|      1|                             NSError *_Nullable error) {
  200|      0|      GDTCORLogDebug("%@", @"CCT: request completed");
  201|      0|      if (error) {
  202|      0|        GDTCORLogWarning(GDTCORMCWUploadFailed, @"There was an error uploading events: %@", error);
  203|      0|      }
  204|      0|      NSError *decodingError;
  205|      0|      GDTCORClock *futureUploadTime;
  206|      0|      if (data) {
  207|      0|        gdt_cct_LogResponse logResponse = GDTCCTDecodeLogResponse(data, &decodingError);
  208|      0|        if (!decodingError && logResponse.has_next_request_wait_millis) {
  209|      0|          GDTCORLogDebug(
  210|      0|              "CCT: The backend responded asking to not upload for %lld millis from now.",
  211|      0|              logResponse.next_request_wait_millis);
  212|      0|          futureUploadTime =
  213|      0|              [GDTCORClock clockSnapshotInTheFuture:logResponse.next_request_wait_millis];
  214|      0|        } else if (decodingError) {
  215|      0|          GDTCORLogDebug(@"There was a response decoding error: %@", decodingError);
  216|      0|        }
  217|      0|        pb_release(gdt_cct_LogResponse_fields, &logResponse);
  218|      0|      }
  219|      0|      if (!futureUploadTime) {
  220|      0|        GDTCORLogDebug("%@", @"CCT: The backend response failed to parse, so the next request "
  221|      0|                             @"won't occur until 15 minutes from now");
  222|      0|        // 15 minutes from now.
  223|      0|        futureUploadTime = [GDTCORClock clockSnapshotInTheFuture:15 * 60 * 1000];
  224|      0|      }
  225|      0|      switch (target) {
  226|      0|        case kGDTCORTargetCCT:
  227|      0|          self->_CCTNextUploadTime = futureUploadTime;
  228|      0|          break;
  229|      0|
  230|      0|        case kGDTCORTargetFLL:
  231|      0|          // Falls through.
  232|      0|        case kGDTCORTargetCSH:
  233|      0|          self->_FLLNextUploadTime = futureUploadTime;
  234|      0|        default:
  235|      0|          break;
  236|      0|      }
  237|      0|
  238|      0|      // Only retry if one of these codes is returned, or there was an error.
  239|      0|      if (error || ((NSHTTPURLResponse *)response).statusCode == 429 ||
  240|      0|          ((NSHTTPURLResponse *)response).statusCode == 503) {
  241|      0|        [package retryDeliveryInTheFuture];
  242|      0|      } else {
  243|      0|#if !NDEBUG
  244|      0|        // Post a notification when in DEBUG mode to state how many packages were uploaded. Useful
  245|      0|        // for validation during tests.
  246|      0|        [[NSNotificationCenter defaultCenter] postNotificationName:GDTCCTUploadCompleteNotification
  247|      0|                                                            object:@(package.events.count)];
  248|      0|#endif  // #if !NDEBUG
  249|      0|        GDTCORLogDebug("%@", @"CCT: package delivered");
  250|      0|        [package completeDelivery];
  251|      0|      }
  252|      0|
  253|      0|      // End the background task if there was one.
  254|      0|      if (bgID != GDTCORBackgroundIdentifierInvalid) {
  255|      0|        [[GDTCORApplication sharedApplication] endBackgroundTask:bgID];
  256|      0|        bgID = GDTCORBackgroundIdentifierInvalid;
  257|      0|      }
  258|      0|      self.currentTask = nil;
  259|      0|      self.currentUploadPackage = nil;
  260|      0|    };
  261|      1|    self->_currentUploadPackage = package;
  262|      1|    NSData *requestProtoData =
  263|      1|        [self constructRequestProtoFromPackage:(GDTCORUploadPackage *)package];
  264|      1|    NSData *gzippedData = [GDTCCTCompressionHelper gzippedData:requestProtoData];
  265|      1|    BOOL usingGzipData = gzippedData != nil && gzippedData.length < requestProtoData.length;
  266|      1|    NSData *dataToSend = usingGzipData ? gzippedData : requestProtoData;
  267|      1|    NSURLRequest *request = [self constructRequestForTarget:target data:dataToSend];
  268|      1|    GDTCORLogDebug("CTT: request created: %@", request);
  269|      1|    self.currentTask = [self.uploaderSession uploadTaskWithRequest:request
  270|      1|                                                          fromData:dataToSend
  271|      1|                                                 completionHandler:completionHandler];
  272|      1|    GDTCORLogDebug("%@", @"CCT: The upload task is about to begin.");
  273|      1|    [self.currentTask resume];
  274|      1|  });
  275|      1|}
  276|       |
  277|      8|- (BOOL)readyToUploadTarget:(GDTCORTarget)target conditions:(GDTCORUploadConditions)conditions {
  278|      8|  __block BOOL result = NO;
  279|      8|  dispatch_sync(_uploaderQueue, ^{
  280|      8|    if (target == kGDTCORTargetCSH) {
  281|      3|      if ([GDTCCTPrioritizer sharedInstance].CSHEvents.count > 0) {
  282|      0|        result = YES;
  283|      3|      } else {
  284|      3|        result = NO;
  285|      3|      }
  286|      3|      return;
  287|      3|    }
  288|      5|
  289|      5|    if (self->_currentUploadPackage) {
  290|      1|      result = NO;
  291|      1|      GDTCORLogDebug("%@", @"CCT: can't upload because a package is in flight");
  292|      1|      return;
  293|      1|    }
  294|      4|    if (self->_currentTask) {
  295|      0|      result = NO;
  296|      0|      GDTCORLogDebug("%@", @"CCT: can't upload because a task is in progress");
  297|      0|      return;
  298|      0|    }
  299|      4|    if ((conditions & GDTCORUploadConditionHighPriority) == GDTCORUploadConditionHighPriority) {
  300|      0|      result = YES;
  301|      0|      GDTCORLogDebug("%@", @"CCT: a high priority event is allowing an upload");
  302|      0|      return;
  303|      0|    }
  304|      4|    switch (target) {
  305|      4|      case kGDTCORTargetCCT:
  306|      2|        if (self->_CCTNextUploadTime) {
  307|      0|          result = [[GDTCORClock snapshot] isAfter:self->_CCTNextUploadTime];
  308|      0|        }
  309|      2|        break;
  310|      4|
  311|      4|      case kGDTCORTargetFLL:
  312|      2|        if (self->_FLLNextUploadTime) {
  313|      0|          result = [[GDTCORClock snapshot] isAfter:self->_FLLNextUploadTime];
  314|      0|        }
  315|      2|        break;
  316|      4|
  317|      4|      default:
  318|      0|        // The CSH backend should be handled above.
  319|      0|        break;
  320|      4|    }
  321|      4|    if (result) {
  322|      0|      GDTCORLogDebug("CCT: can upload to target %ld because the request wait time has transpired",
  323|      0|                     (long)target);
  324|      4|    } else {
  325|      4|      GDTCORLogDebug("CCT: can't upload to target %ld because the backend asked to wait",
  326|      4|                     (long)target);
  327|      4|    }
  328|      4|    result = YES;
  329|      4|    GDTCORLogDebug("CCT: can upload to target %ld because nothing is preventing it", (long)target);
  330|      4|  });
  331|      8|  return result;
  332|      8|}
  333|       |
  334|       |#pragma mark - Private helper methods
  335|       |
  336|       |/** Constructs data given an upload package.
  337|       | *
  338|       | * @param package The upload package used to construct the request proto bytes.
  339|       | * @return Proto bytes representing a gdt_cct_LogRequest object.
  340|       | */
  341|      1|- (nonnull NSData *)constructRequestProtoFromPackage:(GDTCORUploadPackage *)package {
  342|      1|  // Segment the log events by log type.
  343|      1|  NSMutableDictionary<NSString *, NSMutableSet<GDTCOREvent *> *> *logMappingIDToLogSet =
  344|      1|      [[NSMutableDictionary alloc] init];
  345|      1|  [package.events enumerateObjectsUsingBlock:^(GDTCOREvent *_Nonnull event, BOOL *_Nonnull stop) {
  346|      1|    NSMutableSet *logSet = logMappingIDToLogSet[event.mappingID];
  347|      1|    logSet = logSet ? logSet : [[NSMutableSet alloc] init];
  348|      1|    [logSet addObject:event];
  349|      1|    logMappingIDToLogSet[event.mappingID] = logSet;
  350|      1|  }];
  351|      1|
  352|      1|  gdt_cct_BatchedLogRequest batchedLogRequest =
  353|      1|      GDTCCTConstructBatchedLogRequest(logMappingIDToLogSet);
  354|      1|
  355|      1|  NSData *data = GDTCCTEncodeBatchedLogRequest(&batchedLogRequest);
  356|      1|  pb_release(gdt_cct_BatchedLogRequest_fields, &batchedLogRequest);
  357|      1|  return data ? data : [[NSData alloc] init];
  358|      1|}
  359|       |
  360|       |/** Constructs a request to FLL given a URL and request body data.
  361|       | *
  362|       | * @param target The target backend to send the request to.
  363|       | * @param data The request body data.
  364|       | * @return A new NSURLRequest ready to be sent to FLL.
  365|       | */
  366|      1|- (NSURLRequest *)constructRequestForTarget:(GDTCORTarget)target data:(NSData *)data {
  367|      1|  NSURL *URL = [self serverURLForTarget:target];
  368|      1|  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
  369|      1|  NSString *targetString;
  370|      1|  switch (target) {
  371|      1|    case kGDTCORTargetCCT:
  372|      0|      targetString = @"cct";
  373|      0|      break;
  374|      1|
  375|      1|    case kGDTCORTargetFLL:
  376|      1|      targetString = @"fll";
  377|      1|      break;
  378|      1|
  379|      1|    case kGDTCORTargetCSH:
  380|      0|      targetString = @"csh";
  381|      0|      break;
  382|      1|
  383|      1|    default:
  384|      0|      targetString = @"unknown";
  385|      0|      break;
  386|      1|  }
  387|      1|  NSString *userAgent =
  388|      1|      [NSString stringWithFormat:@"datatransport/%@ %@support/%@ apple/", kGDTCORVersion,
  389|      1|                                 targetString, kGDTCCTSupportSDKVersion];
  390|      1|  if (target == kGDTCORTargetFLL || target == kGDTCORTargetCSH) {
  391|      1|    [request setValue:[self FLLAndCSHAPIKey] forHTTPHeaderField:@"X-Goog-Api-Key"];
  392|      1|  }
  393|      1|  if ([GDTCCTCompressionHelper isGzipped:data]) {
  394|      1|    [request setValue:@"gzip" forHTTPHeaderField:@"Content-Encoding"];
  395|      1|  }
  396|      1|  [request setValue:@"application/x-protobuf" forHTTPHeaderField:@"Content-Type"];
  397|      1|  [request setValue:@"gzip" forHTTPHeaderField:@"Accept-Encoding"];
  398|      1|  [request setValue:userAgent forHTTPHeaderField:@"User-Agent"];
  399|      1|  request.HTTPMethod = @"POST";
  400|      1|  [request setHTTPBody:data];
  401|      1|  return request;
  402|      1|}
  403|       |
  404|       |#pragma mark - GDTCORUploadPackageProtocol
  405|       |
  406|      0|- (void)packageExpired:(GDTCORUploadPackage *)package {
  407|      0|  dispatch_async(_uploaderQueue, ^{
  408|      0|    [self.currentTask cancel];
  409|      0|    self.currentTask = nil;
  410|      0|    self.currentUploadPackage = nil;
  411|      0|  });
  412|      0|}
  413|       |
  414|       |#pragma mark - GDTCORLifecycleProtocol
  415|       |
  416|      0|- (void)appWillTerminate:(GDTCORApplication *)application {
  417|      0|  dispatch_sync(_uploaderQueue, ^{
  418|      0|    [self.currentTask cancel];
  419|      0|    [self.currentUploadPackage completeDelivery];
  420|      0|  });
  421|      0|}
  422|       |
  423|       |#pragma mark - NSURLSessionDelegate
  424|       |
  425|       |- (void)URLSession:(NSURLSession *)session
  426|       |                          task:(NSURLSessionTask *)task
  427|       |    willPerformHTTPRedirection:(NSHTTPURLResponse *)response
  428|       |                    newRequest:(NSURLRequest *)request
  429|      0|             completionHandler:(void (^)(NSURLRequest *_Nullable))completionHandler {
  430|      0|  if (!completionHandler) {
  431|      0|    return;
  432|      0|  }
  433|      0|  if (response.statusCode == 302 || response.statusCode == 301) {
  434|      0|    if ([request.URL isEqual:[self serverURLForTarget:kGDTCORTargetFLL]]) {
  435|      0|      NSURLRequest *newRequest = [self constructRequestForTarget:kGDTCORTargetCCT
  436|      0|                                                            data:task.originalRequest.HTTPBody];
  437|      0|      completionHandler(newRequest);
  438|      0|    }
  439|      0|  } else {
  440|      0|    completionHandler(request);
  441|      0|  }
  442|      0|}
  443|       |
  444|       |@end

/Users/xschoeman/Documents/git/XouTube/Pods/GoogleDataTransportCCTSupport/GoogleDataTransportCCTSupport/GDTCCTLibrary/Protogen/nanopb/cct.nanopb.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |/* Automatically generated nanopb header */
   18|       |/* Generated by nanopb-0.3.9.3 */
   19|       |
   20|       |#ifndef PB_GDT_CCT_CCT_NANOPB_H_INCLUDED
   21|       |#define PB_GDT_CCT_CCT_NANOPB_H_INCLUDED
   22|       |#include <nanopb/pb.h>
   23|       |
   24|       |/* @@protoc_insertion_point(includes) */
   25|       |#if PB_PROTO_HEADER_VERSION != 30
   26|       |#error Regenerate this file with the current version of nanopb generator.
   27|       |#endif
   28|       |
   29|       |
   30|       |/* Enum definitions */
   31|       |typedef enum _gdt_cct_NetworkConnectionInfo_NetworkType {
   32|       |    gdt_cct_NetworkConnectionInfo_NetworkType_NONE = -1,
   33|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE = 0,
   34|       |    gdt_cct_NetworkConnectionInfo_NetworkType_WIFI = 1,
   35|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_MMS = 2,
   36|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_SUPL = 3,
   37|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_DUN = 4,
   38|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_HIPRI = 5,
   39|       |    gdt_cct_NetworkConnectionInfo_NetworkType_WIMAX = 6,
   40|       |    gdt_cct_NetworkConnectionInfo_NetworkType_BLUETOOTH = 7,
   41|       |    gdt_cct_NetworkConnectionInfo_NetworkType_DUMMY = 8,
   42|       |    gdt_cct_NetworkConnectionInfo_NetworkType_ETHERNET = 9,
   43|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_FOTA = 10,
   44|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_IMS = 11,
   45|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_CBS = 12,
   46|       |    gdt_cct_NetworkConnectionInfo_NetworkType_WIFI_P2P = 13,
   47|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_IA = 14,
   48|       |    gdt_cct_NetworkConnectionInfo_NetworkType_MOBILE_EMERGENCY = 15,
   49|       |    gdt_cct_NetworkConnectionInfo_NetworkType_PROXY = 16,
   50|       |    gdt_cct_NetworkConnectionInfo_NetworkType_VPN = 17
   51|       |} gdt_cct_NetworkConnectionInfo_NetworkType;
   52|       |#define _gdt_cct_NetworkConnectionInfo_NetworkType_MIN gdt_cct_NetworkConnectionInfo_NetworkType_NONE
   53|       |#define _gdt_cct_NetworkConnectionInfo_NetworkType_MAX gdt_cct_NetworkConnectionInfo_NetworkType_VPN
   54|       |#define _gdt_cct_NetworkConnectionInfo_NetworkType_ARRAYSIZE ((gdt_cct_NetworkConnectionInfo_NetworkType)(gdt_cct_NetworkConnectionInfo_NetworkType_VPN+1))
   55|       |
   56|       |typedef enum _gdt_cct_NetworkConnectionInfo_MobileSubtype {
   57|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE = 0,
   58|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_GPRS = 1,
   59|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EDGE = 2,
   60|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_UMTS = 3,
   61|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_CDMA = 4,
   62|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_0 = 5,
   63|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_A = 6,
   64|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_RTT = 7,
   65|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSDPA = 8,
   66|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSUPA = 9,
   67|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSPA = 10,
   68|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_IDEN = 11,
   69|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EVDO_B = 12,
   70|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_LTE = 13,
   71|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_EHRPD = 14,
   72|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_HSPAP = 15,
   73|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_GSM = 16,
   74|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_TD_SCDMA = 17,
   75|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_IWLAN = 18,
   76|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_LTE_CA = 19,
   77|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype_COMBINED = 100
   78|       |} gdt_cct_NetworkConnectionInfo_MobileSubtype;
   79|       |#define _gdt_cct_NetworkConnectionInfo_MobileSubtype_MIN gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE
   80|       |#define _gdt_cct_NetworkConnectionInfo_MobileSubtype_MAX gdt_cct_NetworkConnectionInfo_MobileSubtype_COMBINED
   81|       |#define _gdt_cct_NetworkConnectionInfo_MobileSubtype_ARRAYSIZE ((gdt_cct_NetworkConnectionInfo_MobileSubtype)(gdt_cct_NetworkConnectionInfo_MobileSubtype_COMBINED+1))
   82|       |
   83|       |typedef enum _gdt_cct_ClientInfo_ClientType {
   84|       |    gdt_cct_ClientInfo_ClientType_CLIENT_UNKNOWN = 0,
   85|       |    gdt_cct_ClientInfo_ClientType_IOS_FIREBASE = 15
   86|       |} gdt_cct_ClientInfo_ClientType;
   87|      2|#define _gdt_cct_ClientInfo_ClientType_MIN gdt_cct_ClientInfo_ClientType_CLIENT_UNKNOWN
   88|       |#define _gdt_cct_ClientInfo_ClientType_MAX gdt_cct_ClientInfo_ClientType_IOS_FIREBASE
   89|       |#define _gdt_cct_ClientInfo_ClientType_ARRAYSIZE ((gdt_cct_ClientInfo_ClientType)(gdt_cct_ClientInfo_ClientType_IOS_FIREBASE+1))
   90|       |
   91|       |typedef enum _gdt_cct_QosTierConfiguration_QosTier {
   92|       |    gdt_cct_QosTierConfiguration_QosTier_DEFAULT = 0,
   93|       |    gdt_cct_QosTierConfiguration_QosTier_UNMETERED_ONLY = 1,
   94|       |    gdt_cct_QosTierConfiguration_QosTier_UNMETERED_OR_DAILY = 2,
   95|       |    gdt_cct_QosTierConfiguration_QosTier_FAST_IF_RADIO_AWAKE = 3,
   96|       |    gdt_cct_QosTierConfiguration_QosTier_NEVER = 4
   97|       |} gdt_cct_QosTierConfiguration_QosTier;
   98|       |#define _gdt_cct_QosTierConfiguration_QosTier_MIN gdt_cct_QosTierConfiguration_QosTier_DEFAULT
   99|       |#define _gdt_cct_QosTierConfiguration_QosTier_MAX gdt_cct_QosTierConfiguration_QosTier_NEVER
  100|       |#define _gdt_cct_QosTierConfiguration_QosTier_ARRAYSIZE ((gdt_cct_QosTierConfiguration_QosTier)(gdt_cct_QosTierConfiguration_QosTier_NEVER+1))
  101|       |
  102|       |/* Struct definitions */
  103|       |typedef struct _gdt_cct_BatchedLogRequest {
  104|       |    pb_size_t log_request_count;
  105|       |    struct _gdt_cct_LogRequest *log_request;
  106|       |/* @@protoc_insertion_point(struct:gdt_cct_BatchedLogRequest) */
  107|       |} gdt_cct_BatchedLogRequest;
  108|       |
  109|       |typedef struct _gdt_cct_IosClientInfo {
  110|       |    pb_bytes_array_t *os_major_version;
  111|       |    pb_bytes_array_t *os_full_version;
  112|       |    pb_bytes_array_t *application_build;
  113|       |    pb_bytes_array_t *country;
  114|       |    pb_bytes_array_t *model;
  115|       |    pb_bytes_array_t *language_code;
  116|       |    pb_bytes_array_t *application_bundle_id;
  117|       |/* @@protoc_insertion_point(struct:gdt_cct_IosClientInfo) */
  118|       |} gdt_cct_IosClientInfo;
  119|       |
  120|       |typedef struct _gdt_cct_ClientInfo {
  121|       |    bool has_client_type;
  122|       |    gdt_cct_ClientInfo_ClientType client_type;
  123|       |    bool has_ios_client_info;
  124|       |    gdt_cct_IosClientInfo ios_client_info;
  125|       |/* @@protoc_insertion_point(struct:gdt_cct_ClientInfo) */
  126|       |} gdt_cct_ClientInfo;
  127|       |
  128|       |typedef struct _gdt_cct_NetworkConnectionInfo {
  129|       |    bool has_network_type;
  130|       |    gdt_cct_NetworkConnectionInfo_NetworkType network_type;
  131|       |    bool has_mobile_subtype;
  132|       |    gdt_cct_NetworkConnectionInfo_MobileSubtype mobile_subtype;
  133|       |/* @@protoc_insertion_point(struct:gdt_cct_NetworkConnectionInfo) */
  134|       |} gdt_cct_NetworkConnectionInfo;
  135|       |
  136|       |typedef struct _gdt_cct_QosTierConfiguration {
  137|       |    bool has_qos_tier;
  138|       |    gdt_cct_QosTierConfiguration_QosTier qos_tier;
  139|       |    bool has_log_source;
  140|       |    int32_t log_source;
  141|       |/* @@protoc_insertion_point(struct:gdt_cct_QosTierConfiguration) */
  142|       |} gdt_cct_QosTierConfiguration;
  143|       |
  144|       |typedef struct _gdt_cct_QosTiersOverride {
  145|       |    pb_size_t qos_tier_configuration_count;
  146|       |    struct _gdt_cct_QosTierConfiguration *qos_tier_configuration;
  147|       |    bool has_qos_tier_fingerprint;
  148|       |    int64_t qos_tier_fingerprint;
  149|       |/* @@protoc_insertion_point(struct:gdt_cct_QosTiersOverride) */
  150|       |} gdt_cct_QosTiersOverride;
  151|       |
  152|       |typedef struct _gdt_cct_LogEvent {
  153|       |    bool has_event_time_ms;
  154|       |    int64_t event_time_ms;
  155|       |    pb_bytes_array_t *source_extension;
  156|       |    bool has_event_code;
  157|       |    int32_t event_code;
  158|       |    bool has_timezone_offset_seconds;
  159|       |    int64_t timezone_offset_seconds;
  160|       |    bool has_event_uptime_ms;
  161|       |    int64_t event_uptime_ms;
  162|       |    bool has_network_connection_info;
  163|       |    gdt_cct_NetworkConnectionInfo network_connection_info;
  164|       |/* @@protoc_insertion_point(struct:gdt_cct_LogEvent) */
  165|       |} gdt_cct_LogEvent;
  166|       |
  167|       |typedef struct _gdt_cct_LogRequest {
  168|       |    bool has_client_info;
  169|       |    gdt_cct_ClientInfo client_info;
  170|       |    bool has_log_source;
  171|       |    int32_t log_source;
  172|       |    pb_size_t log_event_count;
  173|       |    struct _gdt_cct_LogEvent *log_event;
  174|       |    bool has_request_time_ms;
  175|       |    int64_t request_time_ms;
  176|       |    bool has_request_uptime_ms;
  177|       |    int64_t request_uptime_ms;
  178|       |    bool has_qos_tier;
  179|       |    gdt_cct_QosTierConfiguration_QosTier qos_tier;
  180|       |/* @@protoc_insertion_point(struct:gdt_cct_LogRequest) */
  181|       |} gdt_cct_LogRequest;
  182|       |
  183|       |typedef struct _gdt_cct_LogResponse {
  184|       |    bool has_next_request_wait_millis;
  185|       |    int64_t next_request_wait_millis;
  186|       |    bool has_qos_tier;
  187|       |    gdt_cct_QosTiersOverride qos_tier;
  188|       |/* @@protoc_insertion_point(struct:gdt_cct_LogResponse) */
  189|       |} gdt_cct_LogResponse;
  190|       |
  191|       |/* Default values for struct fields */
  192|       |extern const gdt_cct_NetworkConnectionInfo_NetworkType gdt_cct_NetworkConnectionInfo_network_type_default;
  193|       |extern const gdt_cct_NetworkConnectionInfo_MobileSubtype gdt_cct_NetworkConnectionInfo_mobile_subtype_default;
  194|       |extern const gdt_cct_QosTierConfiguration_QosTier gdt_cct_LogRequest_qos_tier_default;
  195|       |extern const int32_t gdt_cct_QosTierConfiguration_log_source_default;
  196|       |
  197|       |/* Initializer values for message structs */
  198|      1|#define gdt_cct_LogEvent_init_default            {false, 0, NULL, false, 0, false, 0, false, 0, false, gdt_cct_NetworkConnectionInfo_init_default}
  199|      1|#define gdt_cct_NetworkConnectionInfo_init_default {false, gdt_cct_NetworkConnectionInfo_NetworkType_NONE, false, gdt_cct_NetworkConnectionInfo_MobileSubtype_UNKNOWN_MOBILE_SUBTYPE}
  200|      3|#define gdt_cct_IosClientInfo_init_default       {NULL, NULL, NULL, NULL, NULL, NULL, NULL}
  201|      2|#define gdt_cct_ClientInfo_init_default          {false, _gdt_cct_ClientInfo_ClientType_MIN, false, gdt_cct_IosClientInfo_init_default}
  202|      1|#define gdt_cct_BatchedLogRequest_init_default   {0, NULL}
  203|      1|#define gdt_cct_LogRequest_init_default          {false, gdt_cct_ClientInfo_init_default, false, 0, 0, NULL, false, 0, false, 0, false, gdt_cct_QosTierConfiguration_QosTier_DEFAULT}
  204|       |#define gdt_cct_QosTierConfiguration_init_default {false, _gdt_cct_QosTierConfiguration_QosTier_MIN, false, 0}
  205|      0|#define gdt_cct_QosTiersOverride_init_default    {0, NULL, false, 0}
  206|      0|#define gdt_cct_LogResponse_init_default         {false, 0, false, gdt_cct_QosTiersOverride_init_default}
  207|       |#define gdt_cct_LogEvent_init_zero               {false, 0, NULL, false, 0, false, 0, false, 0, false, gdt_cct_NetworkConnectionInfo_init_zero}
  208|       |#define gdt_cct_NetworkConnectionInfo_init_zero  {false, _gdt_cct_NetworkConnectionInfo_NetworkType_MIN, false, _gdt_cct_NetworkConnectionInfo_MobileSubtype_MIN}
  209|       |#define gdt_cct_IosClientInfo_init_zero          {NULL, NULL, NULL, NULL, NULL, NULL, NULL}
  210|       |#define gdt_cct_ClientInfo_init_zero             {false, _gdt_cct_ClientInfo_ClientType_MIN, false, gdt_cct_IosClientInfo_init_zero}
  211|       |#define gdt_cct_BatchedLogRequest_init_zero      {0, NULL}
  212|       |#define gdt_cct_LogRequest_init_zero             {false, gdt_cct_ClientInfo_init_zero, false, 0, 0, NULL, false, 0, false, 0, false, _gdt_cct_QosTierConfiguration_QosTier_MIN}
  213|       |#define gdt_cct_QosTierConfiguration_init_zero   {false, _gdt_cct_QosTierConfiguration_QosTier_MIN, false, 0}
  214|       |#define gdt_cct_QosTiersOverride_init_zero       {0, NULL, false, 0}
  215|       |#define gdt_cct_LogResponse_init_zero            {false, 0, false, gdt_cct_QosTiersOverride_init_zero}
  216|       |
  217|       |/* Field tags (for use in manual encoding/decoding) */
  218|       |#define gdt_cct_BatchedLogRequest_log_request_tag 1
  219|       |#define gdt_cct_IosClientInfo_os_major_version_tag 3
  220|       |#define gdt_cct_IosClientInfo_os_full_version_tag 4
  221|       |#define gdt_cct_IosClientInfo_application_build_tag 5
  222|       |#define gdt_cct_IosClientInfo_country_tag        6
  223|       |#define gdt_cct_IosClientInfo_model_tag          7
  224|       |#define gdt_cct_IosClientInfo_language_code_tag  8
  225|       |#define gdt_cct_IosClientInfo_application_bundle_id_tag 11
  226|       |#define gdt_cct_ClientInfo_client_type_tag       1
  227|       |#define gdt_cct_ClientInfo_ios_client_info_tag   4
  228|       |#define gdt_cct_NetworkConnectionInfo_network_type_tag 1
  229|       |#define gdt_cct_NetworkConnectionInfo_mobile_subtype_tag 2
  230|       |#define gdt_cct_QosTierConfiguration_qos_tier_tag 2
  231|       |#define gdt_cct_QosTierConfiguration_log_source_tag 3
  232|       |#define gdt_cct_QosTiersOverride_qos_tier_configuration_tag 1
  233|       |#define gdt_cct_QosTiersOverride_qos_tier_fingerprint_tag 2
  234|       |#define gdt_cct_LogEvent_event_time_ms_tag       1
  235|       |#define gdt_cct_LogEvent_event_code_tag          11
  236|       |#define gdt_cct_LogEvent_event_uptime_ms_tag     17
  237|       |#define gdt_cct_LogEvent_source_extension_tag    6
  238|       |#define gdt_cct_LogEvent_timezone_offset_seconds_tag 15
  239|       |#define gdt_cct_LogEvent_network_connection_info_tag 23
  240|       |#define gdt_cct_LogRequest_request_time_ms_tag   4
  241|       |#define gdt_cct_LogRequest_request_uptime_ms_tag 8
  242|       |#define gdt_cct_LogRequest_client_info_tag       1
  243|       |#define gdt_cct_LogRequest_log_source_tag        2
  244|       |#define gdt_cct_LogRequest_log_event_tag         3
  245|       |#define gdt_cct_LogRequest_qos_tier_tag          9
  246|       |#define gdt_cct_LogResponse_next_request_wait_millis_tag 1
  247|       |#define gdt_cct_LogResponse_qos_tier_tag         3
  248|       |
  249|       |/* Struct field encoding specification for nanopb */
  250|       |extern const pb_field_t gdt_cct_LogEvent_fields[7];
  251|       |extern const pb_field_t gdt_cct_NetworkConnectionInfo_fields[3];
  252|       |extern const pb_field_t gdt_cct_IosClientInfo_fields[8];
  253|       |extern const pb_field_t gdt_cct_ClientInfo_fields[3];
  254|       |extern const pb_field_t gdt_cct_BatchedLogRequest_fields[2];
  255|       |extern const pb_field_t gdt_cct_LogRequest_fields[7];
  256|       |extern const pb_field_t gdt_cct_QosTierConfiguration_fields[3];
  257|       |extern const pb_field_t gdt_cct_QosTiersOverride_fields[3];
  258|       |extern const pb_field_t gdt_cct_LogResponse_fields[3];
  259|       |
  260|       |/* Maximum encoded size of messages (where known) */
  261|       |/* gdt_cct_LogEvent_size depends on runtime parameters */
  262|       |#define gdt_cct_NetworkConnectionInfo_size       13
  263|       |/* gdt_cct_IosClientInfo_size depends on runtime parameters */
  264|       |/* gdt_cct_ClientInfo_size depends on runtime parameters */
  265|       |/* gdt_cct_BatchedLogRequest_size depends on runtime parameters */
  266|       |/* gdt_cct_LogRequest_size depends on runtime parameters */
  267|       |#define gdt_cct_QosTierConfiguration_size        13
  268|       |/* gdt_cct_QosTiersOverride_size depends on runtime parameters */
  269|       |/* gdt_cct_LogResponse_size depends on runtime parameters */
  270|       |
  271|       |/* Message IDs (where set with "msgid" option) */
  272|       |#ifdef PB_MSGID
  273|       |
  274|       |#define CCT_MESSAGES \
  275|       |
  276|       |
  277|       |#endif
  278|       |
  279|       |/* @@protoc_insertion_point(eof) */
  280|       |
  281|       |#endif

/Users/xschoeman/Documents/git/XouTube/Pods/Headers/Public/FirebaseCoreDiagnosticsInterop/FIRCoreDiagnosticsData.h:
    1|       |/*
    2|       | * Copyright 2019 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** If present, is a BOOL wrapped in an NSNumber. */
   22|     14|#define kFIRCDIsDataCollectionDefaultEnabledKey @"FIRCDIsDataCollectionDefaultEnabledKey"
   23|       |
   24|       |/** If present, is an int32_t wrapped in an NSNumber. */
   25|      8|#define kFIRCDConfigurationTypeKey @"FIRCDConfigurationTypeKey"
   26|       |
   27|       |/** If present, is an NSString. */
   28|      6|#define kFIRCDSdkNameKey @"FIRCDSdkNameKey"
   29|       |
   30|       |/** If present, is an NSString. */
   31|      6|#define kFIRCDSdkVersionKey @"FIRCDSdkVersionKey"
   32|       |
   33|       |/** If present, is an int32_t wrapped in an NSNumber. */
   34|     24|#define kFIRCDllAppsCountKey @"FIRCDllAppsCountKey"
   35|       |
   36|       |/** If present, is an NSString. */
   37|      8|#define kFIRCDGoogleAppIDKey @"FIRCDGoogleAppIDKey"
   38|       |
   39|       |/** If present, is an NSString. */
   40|      8|#define kFIRCDBundleIDKey @"FIRCDBundleID"
   41|       |
   42|       |/** If present, is a BOOL wrapped in an NSNumber. */
   43|      8|#define kFIRCDUsingOptionsFromDefaultPlistKey @"FIRCDUsingOptionsFromDefaultPlistKey"
   44|       |
   45|       |/** If present, is an NSString. */
   46|      8|#define kFIRCDLibraryVersionIDKey @"FIRCDLibraryVersionIDKey"
   47|       |
   48|       |/** If present, is an NSString. */
   49|     14|#define kFIRCDFirebaseUserAgentKey @"FIRCDFirebaseUserAgentKey"
   50|       |
   51|       |/** Defines the interface of a data object needed to log diagnostics data. */
   52|       |@protocol FIRCoreDiagnosticsData <NSObject>
   53|       |
   54|       |@required
   55|       |
   56|       |/** A dictionary containing data (non-exhaustive) to be logged in diagnostics. */
   57|       |@property(nonatomic) NSDictionary<NSString *, id> *diagnosticObjects;
   58|       |
   59|       |@end
   60|       |
   61|       |NS_ASSUME_NONNULL_END

/Users/xschoeman/Documents/git/XouTube/Pods/nanopb/pb.h:
    1|       |/* Common parts of the nanopb library. Most of these are quite low-level
    2|       | * stuff. For the high-level interface, see pb_encode.h and pb_decode.h.
    3|       | */
    4|       |
    5|       |#ifndef PB_H_INCLUDED
    6|       |#define PB_H_INCLUDED
    7|       |
    8|       |/*****************************************************************
    9|       | * Nanopb compilation time options. You can change these here by *
   10|       | * uncommenting the lines, or on the compiler command line.      *
   11|       | *****************************************************************/
   12|       |
   13|       |/* Enable support for dynamically allocated fields */
   14|       |/* #define PB_ENABLE_MALLOC 1 */
   15|       |
   16|       |/* Define this if your CPU / compiler combination does not support
   17|       | * unaligned memory access to packed structures. */
   18|       |/* #define PB_NO_PACKED_STRUCTS 1 */
   19|       |
   20|       |/* Increase the number of required fields that are tracked.
   21|       | * A compiler warning will tell if you need this. */
   22|       |/* #define PB_MAX_REQUIRED_FIELDS 256 */
   23|       |
   24|       |/* Add support for tag numbers > 255 and fields larger than 255 bytes. */
   25|       |/* #define PB_FIELD_16BIT 1 */
   26|       |
   27|       |/* Add support for tag numbers > 65536 and fields larger than 65536 bytes. */
   28|       |/* #define PB_FIELD_32BIT 1 */
   29|       |
   30|       |/* Disable support for error messages in order to save some code space. */
   31|       |/* #define PB_NO_ERRMSG 1 */
   32|       |
   33|       |/* Disable support for custom streams (support only memory buffers). */
   34|       |/* #define PB_BUFFER_ONLY 1 */
   35|       |
   36|       |/* Switch back to the old-style callback function signature.
   37|       | * This was the default until nanopb-0.2.1. */
   38|       |/* #define PB_OLD_CALLBACK_STYLE */
   39|       |
   40|       |
   41|       |/******************************************************************
   42|       | * You usually don't need to change anything below this line.     *
   43|       | * Feel free to look around and use the defined macros, though.   *
   44|       | ******************************************************************/
   45|       |
   46|       |
   47|       |/* Version of the nanopb library. Just in case you want to check it in
   48|       | * your own program. */
   49|       |#define NANOPB_VERSION nanopb-0.3.9.1
   50|       |
   51|       |/* Include all the system headers needed by nanopb. You will need the
   52|       | * definitions of the following:
   53|       | * - strlen, memcpy, memset functions
   54|       | * - [u]int_least8_t, uint_fast8_t, [u]int_least16_t, [u]int32_t, [u]int64_t
   55|       | * - size_t
   56|       | * - bool
   57|       | *
   58|       | * If you don't have the standard header files, you can instead provide
   59|       | * a custom header that defines or includes all this. In that case,
   60|       | * define PB_SYSTEM_HEADER to the path of this file.
   61|       | */
   62|       |#ifdef PB_SYSTEM_HEADER
   63|       |#include PB_SYSTEM_HEADER
   64|       |#else
   65|       |#include <stdint.h>
   66|       |#include <stddef.h>
   67|       |#include <stdbool.h>
   68|       |#include <string.h>
   69|       |
   70|       |#ifdef PB_ENABLE_MALLOC
   71|       |#include <stdlib.h>
   72|       |#endif
   73|       |#endif
   74|       |
   75|       |/* Macro for defining packed structures (compiler dependent).
   76|       | * This just reduces memory requirements, but is not required.
   77|       | */
   78|       |#if defined(PB_NO_PACKED_STRUCTS)
   79|       |    /* Disable struct packing */
   80|       |#   define PB_PACKED_STRUCT_START
   81|       |#   define PB_PACKED_STRUCT_END
   82|       |#   define pb_packed
   83|       |#elif defined(__GNUC__) || defined(__clang__)
   84|       |    /* For GCC and clang */
   85|       |#   define PB_PACKED_STRUCT_START
   86|       |#   define PB_PACKED_STRUCT_END
   87|       |#   define pb_packed __attribute__((packed))
   88|       |#elif defined(__ICCARM__) || defined(__CC_ARM)
   89|       |    /* For IAR ARM and Keil MDK-ARM compilers */
   90|       |#   define PB_PACKED_STRUCT_START _Pragma("pack(push, 1)")
   91|       |#   define PB_PACKED_STRUCT_END _Pragma("pack(pop)")
   92|       |#   define pb_packed
   93|       |#elif defined(_MSC_VER) && (_MSC_VER >= 1500)
   94|       |    /* For Microsoft Visual C++ */
   95|       |#   define PB_PACKED_STRUCT_START __pragma(pack(push, 1))
   96|       |#   define PB_PACKED_STRUCT_END __pragma(pack(pop))
   97|       |#   define pb_packed
   98|       |#else
   99|       |    /* Unknown compiler */
  100|       |#   define PB_PACKED_STRUCT_START
  101|       |#   define PB_PACKED_STRUCT_END
  102|       |#   define pb_packed
  103|       |#endif
  104|       |
  105|       |/* Handly macro for suppressing unreferenced-parameter compiler warnings. */
  106|       |#ifndef PB_UNUSED
  107|       |#define PB_UNUSED(x) (void)(x)
  108|       |#endif
  109|       |
  110|       |/* Compile-time assertion, used for checking compatible compilation options.
  111|       | * If this does not work properly on your compiler, use
  112|       | * #define PB_NO_STATIC_ASSERT to disable it.
  113|       | *
  114|       | * But before doing that, check carefully the error message / place where it
  115|       | * comes from to see if the error has a real cause. Unfortunately the error
  116|       | * message is not always very clear to read, but you can see the reason better
  117|       | * in the place where the PB_STATIC_ASSERT macro was called.
  118|       | */
  119|       |#ifndef PB_NO_STATIC_ASSERT
  120|       |#ifndef PB_STATIC_ASSERT
  121|       |#define PB_STATIC_ASSERT(COND,MSG) typedef char PB_STATIC_ASSERT_MSG(MSG, __LINE__, __COUNTER__)[(COND)?1:-1];
  122|       |#define PB_STATIC_ASSERT_MSG(MSG, LINE, COUNTER) PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER)
  123|       |#define PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER) pb_static_assertion_##MSG##LINE##COUNTER
  124|       |#endif
  125|       |#else
  126|       |#define PB_STATIC_ASSERT(COND,MSG)
  127|       |#endif
  128|       |
  129|       |/* Number of required fields to keep track of. */
  130|       |#ifndef PB_MAX_REQUIRED_FIELDS
  131|       |#define PB_MAX_REQUIRED_FIELDS 64
  132|       |#endif
  133|       |
  134|       |#if PB_MAX_REQUIRED_FIELDS < 64
  135|       |#error You should not lower PB_MAX_REQUIRED_FIELDS from the default value (64).
  136|       |#endif
  137|       |
  138|       |/* List of possible field types. These are used in the autogenerated code.
  139|       | * Least-significant 4 bits tell the scalar type
  140|       | * Most-significant 4 bits specify repeated/required/packed etc.
  141|       | */
  142|       |
  143|       |typedef uint_least8_t pb_type_t;
  144|       |
  145|       |/**** Field data types ****/
  146|       |
  147|       |/* Numeric types */
  148|       |#define PB_LTYPE_VARINT  0x00 /* int32, int64, enum, bool */
  149|       |#define PB_LTYPE_UVARINT 0x01 /* uint32, uint64 */
  150|       |#define PB_LTYPE_SVARINT 0x02 /* sint32, sint64 */
  151|       |#define PB_LTYPE_FIXED32 0x03 /* fixed32, sfixed32, float */
  152|       |#define PB_LTYPE_FIXED64 0x04 /* fixed64, sfixed64, double */
  153|       |
  154|       |/* Marker for last packable field type. */
  155|       |#define PB_LTYPE_LAST_PACKABLE 0x04
  156|       |
  157|       |/* Byte array with pre-allocated buffer.
  158|       | * data_size is the length of the allocated PB_BYTES_ARRAY structure. */
  159|       |#define PB_LTYPE_BYTES 0x05
  160|       |
  161|       |/* String with pre-allocated buffer.
  162|       | * data_size is the maximum length. */
  163|       |#define PB_LTYPE_STRING 0x06
  164|       |
  165|       |/* Submessage
  166|       | * submsg_fields is pointer to field descriptions */
  167|       |#define PB_LTYPE_SUBMESSAGE 0x07
  168|       |
  169|       |/* Extension pseudo-field
  170|       | * The field contains a pointer to pb_extension_t */
  171|       |#define PB_LTYPE_EXTENSION 0x08
  172|       |
  173|       |/* Byte array with inline, pre-allocated byffer.
  174|       | * data_size is the length of the inline, allocated buffer.
  175|       | * This differs from PB_LTYPE_BYTES by defining the element as
  176|       | * pb_byte_t[data_size] rather than pb_bytes_array_t. */
  177|       |#define PB_LTYPE_FIXED_LENGTH_BYTES 0x09
  178|       |
  179|       |/* Number of declared LTYPES */
  180|       |#define PB_LTYPES_COUNT 0x0A
  181|       |#define PB_LTYPE_MASK 0x0F
  182|       |
  183|       |/**** Field repetition rules ****/
  184|       |
  185|       |#define PB_HTYPE_REQUIRED 0x00
  186|       |#define PB_HTYPE_OPTIONAL 0x10
  187|       |#define PB_HTYPE_REPEATED 0x20
  188|       |#define PB_HTYPE_ONEOF    0x30
  189|       |#define PB_HTYPE_MASK     0x30
  190|       |
  191|       |/**** Field allocation types ****/
  192|       | 
  193|       |#define PB_ATYPE_STATIC   0x00
  194|       |#define PB_ATYPE_POINTER  0x80
  195|       |#define PB_ATYPE_CALLBACK 0x40
  196|       |#define PB_ATYPE_MASK     0xC0
  197|       |
  198|       |#define PB_ATYPE(x) ((x) & PB_ATYPE_MASK)
  199|       |#define PB_HTYPE(x) ((x) & PB_HTYPE_MASK)
  200|       |#define PB_LTYPE(x) ((x) & PB_LTYPE_MASK)
  201|       |
  202|       |/* Data type used for storing sizes of struct fields
  203|       | * and array counts.
  204|       | */
  205|       |#if defined(PB_FIELD_32BIT)
  206|       |    typedef uint32_t pb_size_t;
  207|       |    typedef int32_t pb_ssize_t;
  208|       |#elif defined(PB_FIELD_16BIT)
  209|       |    typedef uint_least16_t pb_size_t;
  210|       |    typedef int_least16_t pb_ssize_t;
  211|       |#else
  212|       |    typedef uint_least8_t pb_size_t;
  213|       |    typedef int_least8_t pb_ssize_t;
  214|       |#endif
  215|       |#define PB_SIZE_MAX ((pb_size_t)-1)
  216|       |
  217|       |/* Data type for storing encoded data and other byte streams.
  218|       | * This typedef exists to support platforms where uint8_t does not exist.
  219|       | * You can regard it as equivalent on uint8_t on other platforms.
  220|       | */
  221|       |typedef uint_least8_t pb_byte_t;
  222|       |
  223|       |/* This structure is used in auto-generated constants
  224|       | * to specify struct fields.
  225|       | * You can change field sizes if you need structures
  226|       | * larger than 256 bytes or field tags larger than 256.
  227|       | * The compiler should complain if your .proto has such
  228|       | * structures. Fix that by defining PB_FIELD_16BIT or
  229|       | * PB_FIELD_32BIT.
  230|       | */
  231|       |PB_PACKED_STRUCT_START
  232|       |typedef struct pb_field_s pb_field_t;
  233|       |struct pb_field_s {
  234|       |    pb_size_t tag;
  235|       |    pb_type_t type;
  236|       |    pb_size_t data_offset; /* Offset of field data, relative to previous field. */
  237|       |    pb_ssize_t size_offset; /* Offset of array size or has-boolean, relative to data */
  238|       |    pb_size_t data_size; /* Data size in bytes for a single item */
  239|       |    pb_size_t array_size; /* Maximum number of entries in array */
  240|       |    
  241|       |    /* Field definitions for submessage
  242|       |     * OR default value for all other non-array, non-callback types
  243|       |     * If null, then field will zeroed. */
  244|       |    const void *ptr;
  245|       |} pb_packed;
  246|       |PB_PACKED_STRUCT_END
  247|       |
  248|       |/* Make sure that the standard integer types are of the expected sizes.
  249|       | * Otherwise fixed32/fixed64 fields can break.
  250|       | *
  251|       | * If you get errors here, it probably means that your stdint.h is not
  252|       | * correct for your platform.
  253|       | */
  254|       |#ifndef PB_WITHOUT_64BIT
  255|       |PB_STATIC_ASSERT(sizeof(int64_t) == 2 * sizeof(int32_t), INT64_T_WRONG_SIZE)
  256|       |PB_STATIC_ASSERT(sizeof(uint64_t) == 2 * sizeof(uint32_t), UINT64_T_WRONG_SIZE)
  257|       |#endif
  258|       |
  259|       |/* This structure is used for 'bytes' arrays.
  260|       | * It has the number of bytes in the beginning, and after that an array.
  261|       | * Note that actual structs used will have a different length of bytes array.
  262|       | */
  263|       |#define PB_BYTES_ARRAY_T(n) struct { pb_size_t size; pb_byte_t bytes[n]; }
  264|     24|#define PB_BYTES_ARRAY_T_ALLOCSIZE(n) ((size_t)n + offsetof(pb_bytes_array_t, bytes))
  265|       |
  266|       |struct pb_bytes_array_s {
  267|       |    pb_size_t size;
  268|       |    pb_byte_t bytes[1];
  269|       |};
  270|       |typedef struct pb_bytes_array_s pb_bytes_array_t;
  271|       |
  272|       |/* This structure is used for giving the callback function.
  273|       | * It is stored in the message structure and filled in by the method that
  274|       | * calls pb_decode.
  275|       | *
  276|       | * The decoding callback will be given a limited-length stream
  277|       | * If the wire type was string, the length is the length of the string.
  278|       | * If the wire type was a varint/fixed32/fixed64, the length is the length
  279|       | * of the actual value.
  280|       | * The function may be called multiple times (especially for repeated types,
  281|       | * but also otherwise if the message happens to contain the field multiple
  282|       | * times.)
  283|       | *
  284|       | * The encoding callback will receive the actual output stream.
  285|       | * It should write all the data in one call, including the field tag and
  286|       | * wire type. It can write multiple fields.
  287|       | *
  288|       | * The callback can be null if you want to skip a field.
  289|       | */
  290|       |typedef struct pb_istream_s pb_istream_t;
  291|       |typedef struct pb_ostream_s pb_ostream_t;
  292|       |typedef struct pb_callback_s pb_callback_t;
  293|       |struct pb_callback_s {
  294|       |#ifdef PB_OLD_CALLBACK_STYLE
  295|       |    /* Deprecated since nanopb-0.2.1 */
  296|       |    union {
  297|       |        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void *arg);
  298|       |        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, const void *arg);
  299|       |    } funcs;
  300|       |#else
  301|       |    /* New function signature, which allows modifying arg contents in callback. */
  302|       |    union {
  303|       |        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void **arg);
  304|       |        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, void * const *arg);
  305|       |    } funcs;
  306|       |#endif    
  307|       |    
  308|       |    /* Free arg for use by callback */
  309|       |    void *arg;
  310|       |};
  311|       |
  312|       |/* Wire types. Library user needs these only in encoder callbacks. */
  313|       |typedef enum {
  314|       |    PB_WT_VARINT = 0,
  315|       |    PB_WT_64BIT  = 1,
  316|       |    PB_WT_STRING = 2,
  317|       |    PB_WT_32BIT  = 5
  318|       |} pb_wire_type_t;
  319|       |
  320|       |/* Structure for defining the handling of unknown/extension fields.
  321|       | * Usually the pb_extension_type_t structure is automatically generated,
  322|       | * while the pb_extension_t structure is created by the user. However,
  323|       | * if you want to catch all unknown fields, you can also create a custom
  324|       | * pb_extension_type_t with your own callback.
  325|       | */
  326|       |typedef struct pb_extension_type_s pb_extension_type_t;
  327|       |typedef struct pb_extension_s pb_extension_t;
  328|       |struct pb_extension_type_s {
  329|       |    /* Called for each unknown field in the message.
  330|       |     * If you handle the field, read off all of its data and return true.
  331|       |     * If you do not handle the field, do not read anything and return true.
  332|       |     * If you run into an error, return false.
  333|       |     * Set to NULL for default handler.
  334|       |     */
  335|       |    bool (*decode)(pb_istream_t *stream, pb_extension_t *extension,
  336|       |                   uint32_t tag, pb_wire_type_t wire_type);
  337|       |    
  338|       |    /* Called once after all regular fields have been encoded.
  339|       |     * If you have something to write, do so and return true.
  340|       |     * If you do not have anything to write, just return true.
  341|       |     * If you run into an error, return false.
  342|       |     * Set to NULL for default handler.
  343|       |     */
  344|       |    bool (*encode)(pb_ostream_t *stream, const pb_extension_t *extension);
  345|       |    
  346|       |    /* Free field for use by the callback. */
  347|       |    const void *arg;
  348|       |};
  349|       |
  350|       |struct pb_extension_s {
  351|       |    /* Type describing the extension field. Usually you'll initialize
  352|       |     * this to a pointer to the automatically generated structure. */
  353|       |    const pb_extension_type_t *type;
  354|       |    
  355|       |    /* Destination for the decoded data. This must match the datatype
  356|       |     * of the extension field. */
  357|       |    void *dest;
  358|       |    
  359|       |    /* Pointer to the next extension handler, or NULL.
  360|       |     * If this extension does not match a field, the next handler is
  361|       |     * automatically called. */
  362|       |    pb_extension_t *next;
  363|       |
  364|       |    /* The decoder sets this to true if the extension was found.
  365|       |     * Ignored for encoding. */
  366|       |    bool found;
  367|       |};
  368|       |
  369|       |/* Memory allocation functions to use. You can define pb_realloc and
  370|       | * pb_free to custom functions if you want. */
  371|       |#ifdef PB_ENABLE_MALLOC
  372|       |#   ifndef pb_realloc
  373|       |#       define pb_realloc(ptr, size) realloc(ptr, size)
  374|       |#   endif
  375|       |#   ifndef pb_free
  376|       |#       define pb_free(ptr) free(ptr)
  377|       |#   endif
  378|       |#endif
  379|       |
  380|       |/* This is used to inform about need to regenerate .pb.h/.pb.c files. */
  381|       |#define PB_PROTO_HEADER_VERSION 30
  382|       |
  383|       |/* These macros are used to declare pb_field_t's in the constant array. */
  384|       |/* Size of a structure member, in bytes. */
  385|       |#define pb_membersize(st, m) (sizeof ((st*)0)->m)
  386|       |/* Number of entries in an array. */
  387|       |#define pb_arraysize(st, m) (pb_membersize(st, m) / pb_membersize(st, m[0]))
  388|       |/* Delta from start of one member to the start of another member. */
  389|       |#define pb_delta(st, m1, m2) ((int)offsetof(st, m1) - (int)offsetof(st, m2))
  390|       |/* Marks the end of the field list */
  391|       |#define PB_LAST_FIELD {0,(pb_type_t) 0,0,0,0,0,0}
  392|       |
  393|       |/* Macros for filling in the data_offset field */
  394|       |/* data_offset for first field in a message */
  395|       |#define PB_DATAOFFSET_FIRST(st, m1, m2) (offsetof(st, m1))
  396|       |/* data_offset for subsequent fields */
  397|       |#define PB_DATAOFFSET_OTHER(st, m1, m2) (offsetof(st, m1) - offsetof(st, m2) - pb_membersize(st, m2))
  398|       |/* data offset for subsequent fields inside an union (oneof) */
  399|       |#define PB_DATAOFFSET_UNION(st, m1, m2) (PB_SIZE_MAX)
  400|       |/* Choose first/other based on m1 == m2 (deprecated, remains for backwards compatibility) */
  401|       |#define PB_DATAOFFSET_CHOOSE(st, m1, m2) (int)(offsetof(st, m1) == offsetof(st, m2) \
  402|       |                                  ? PB_DATAOFFSET_FIRST(st, m1, m2) \
  403|       |                                  : PB_DATAOFFSET_OTHER(st, m1, m2))
  404|       |
  405|       |/* Required fields are the simplest. They just have delta (padding) from
  406|       | * previous field end, and the size of the field. Pointer is used for
  407|       | * submessages and default values.
  408|       | */
  409|       |#define PB_REQUIRED_STATIC(tag, st, m, fd, ltype, ptr) \
  410|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, \
  411|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  412|       |
  413|       |/* Optional fields add the delta to the has_ variable. */
  414|       |#define PB_OPTIONAL_STATIC(tag, st, m, fd, ltype, ptr) \
  415|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
  416|       |    fd, \
  417|       |    pb_delta(st, has_ ## m, m), \
  418|       |    pb_membersize(st, m), 0, ptr}
  419|       |
  420|       |#define PB_SINGULAR_STATIC(tag, st, m, fd, ltype, ptr) \
  421|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
  422|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  423|       |
  424|       |/* Repeated fields have a _count field and also the maximum number of entries. */
  425|       |#define PB_REPEATED_STATIC(tag, st, m, fd, ltype, ptr) \
  426|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | ltype, \
  427|       |    fd, \
  428|       |    pb_delta(st, m ## _count, m), \
  429|       |    pb_membersize(st, m[0]), \
  430|       |    pb_arraysize(st, m), ptr}
  431|       |
  432|       |/* Allocated fields carry the size of the actual data, not the pointer */
  433|       |#define PB_REQUIRED_POINTER(tag, st, m, fd, ltype, ptr) \
  434|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_REQUIRED | ltype, \
  435|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  436|       |
  437|       |/* Optional fields don't need a has_ variable, as information would be redundant */
  438|       |#define PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr) \
  439|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, \
  440|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  441|       |
  442|       |/* Same as optional fields*/
  443|       |#define PB_SINGULAR_POINTER(tag, st, m, fd, ltype, ptr) \
  444|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, \
  445|       |    fd, 0, pb_membersize(st, m[0]), 0, ptr}
  446|       |
  447|       |/* Repeated fields have a _count field and a pointer to array of pointers */
  448|       |#define PB_REPEATED_POINTER(tag, st, m, fd, ltype, ptr) \
  449|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_REPEATED | ltype, \
  450|       |    fd, pb_delta(st, m ## _count, m), \
  451|       |    pb_membersize(st, m[0]), 0, ptr}
  452|       |
  453|       |/* Callbacks are much like required fields except with special datatype. */
  454|       |#define PB_REQUIRED_CALLBACK(tag, st, m, fd, ltype, ptr) \
  455|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REQUIRED | ltype, \
  456|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  457|       |
  458|       |#define PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr) \
  459|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, \
  460|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  461|       |
  462|       |#define PB_SINGULAR_CALLBACK(tag, st, m, fd, ltype, ptr) \
  463|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, \
  464|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  465|       |    
  466|       |#define PB_REPEATED_CALLBACK(tag, st, m, fd, ltype, ptr) \
  467|       |    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REPEATED | ltype, \
  468|       |    fd, 0, pb_membersize(st, m), 0, ptr}
  469|       |
  470|       |/* Optional extensions don't have the has_ field, as that would be redundant.
  471|       | * Furthermore, the combination of OPTIONAL without has_ field is used
  472|       | * for indicating proto3 style fields. Extensions exist in proto2 mode only,
  473|       | * so they should be encoded according to proto2 rules. To avoid the conflict,
  474|       | * extensions are marked as REQUIRED instead.
  475|       | */
  476|       |#define PB_OPTEXT_STATIC(tag, st, m, fd, ltype, ptr) \
  477|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, \
  478|       |    0, \
  479|       |    0, \
  480|       |    pb_membersize(st, m), 0, ptr}
  481|       |
  482|       |#define PB_OPTEXT_POINTER(tag, st, m, fd, ltype, ptr) \
  483|       |    PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr)
  484|       |
  485|       |#define PB_OPTEXT_CALLBACK(tag, st, m, fd, ltype, ptr) \
  486|       |    PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr)
  487|       |
  488|       |/* The mapping from protobuf types to LTYPEs is done using these macros. */
  489|       |#define PB_LTYPE_MAP_BOOL               PB_LTYPE_VARINT
  490|       |#define PB_LTYPE_MAP_BYTES              PB_LTYPE_BYTES
  491|       |#define PB_LTYPE_MAP_DOUBLE             PB_LTYPE_FIXED64
  492|       |#define PB_LTYPE_MAP_ENUM               PB_LTYPE_VARINT
  493|       |#define PB_LTYPE_MAP_UENUM              PB_LTYPE_UVARINT
  494|       |#define PB_LTYPE_MAP_FIXED32            PB_LTYPE_FIXED32
  495|       |#define PB_LTYPE_MAP_FIXED64            PB_LTYPE_FIXED64
  496|       |#define PB_LTYPE_MAP_FLOAT              PB_LTYPE_FIXED32
  497|       |#define PB_LTYPE_MAP_INT32              PB_LTYPE_VARINT
  498|       |#define PB_LTYPE_MAP_INT64              PB_LTYPE_VARINT
  499|       |#define PB_LTYPE_MAP_MESSAGE            PB_LTYPE_SUBMESSAGE
  500|       |#define PB_LTYPE_MAP_SFIXED32           PB_LTYPE_FIXED32
  501|       |#define PB_LTYPE_MAP_SFIXED64           PB_LTYPE_FIXED64
  502|       |#define PB_LTYPE_MAP_SINT32             PB_LTYPE_SVARINT
  503|       |#define PB_LTYPE_MAP_SINT64             PB_LTYPE_SVARINT
  504|       |#define PB_LTYPE_MAP_STRING             PB_LTYPE_STRING
  505|       |#define PB_LTYPE_MAP_UINT32             PB_LTYPE_UVARINT
  506|       |#define PB_LTYPE_MAP_UINT64             PB_LTYPE_UVARINT
  507|       |#define PB_LTYPE_MAP_EXTENSION          PB_LTYPE_EXTENSION
  508|       |#define PB_LTYPE_MAP_FIXED_LENGTH_BYTES PB_LTYPE_FIXED_LENGTH_BYTES
  509|       |
  510|       |/* This is the actual macro used in field descriptions.
  511|       | * It takes these arguments:
  512|       | * - Field tag number
  513|       | * - Field type:   BOOL, BYTES, DOUBLE, ENUM, UENUM, FIXED32, FIXED64,
  514|       | *                 FLOAT, INT32, INT64, MESSAGE, SFIXED32, SFIXED64
  515|       | *                 SINT32, SINT64, STRING, UINT32, UINT64 or EXTENSION
  516|       | * - Field rules:  REQUIRED, OPTIONAL or REPEATED
  517|       | * - Allocation:   STATIC, CALLBACK or POINTER
  518|       | * - Placement: FIRST or OTHER, depending on if this is the first field in structure.
  519|       | * - Message name
  520|       | * - Field name
  521|       | * - Previous field name (or field name again for first field)
  522|       | * - Pointer to default value or submsg fields.
  523|       | */
  524|       |
  525|       |#define PB_FIELD(tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  526|       |        PB_ ## rules ## _ ## allocation(tag, message, field, \
  527|       |        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  528|       |        PB_LTYPE_MAP_ ## type, ptr)
  529|       |
  530|       |/* Field description for repeated static fixed count fields.*/
  531|       |#define PB_REPEATED_FIXED_COUNT(tag, type, placement, message, field, prevfield, ptr) \
  532|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | PB_LTYPE_MAP_ ## type, \
  533|       |    PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  534|       |    0, \
  535|       |    pb_membersize(message, field[0]), \
  536|       |    pb_arraysize(message, field), ptr}
  537|       |
  538|       |/* Field description for oneof fields. This requires taking into account the
  539|       | * union name also, that's why a separate set of macros is needed.
  540|       | */
  541|       |#define PB_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
  542|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
  543|       |    fd, pb_delta(st, which_ ## u, u.m), \
  544|       |    pb_membersize(st, u.m), 0, ptr}
  545|       |
  546|       |#define PB_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
  547|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
  548|       |    fd, pb_delta(st, which_ ## u, u.m), \
  549|       |    pb_membersize(st, u.m[0]), 0, ptr}
  550|       |
  551|       |#define PB_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  552|       |        PB_ONEOF_ ## allocation(union_name, tag, message, field, \
  553|       |        PB_DATAOFFSET_ ## placement(message, union_name.field, prevfield), \
  554|       |        PB_LTYPE_MAP_ ## type, ptr)
  555|       |
  556|       |#define PB_ANONYMOUS_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
  557|       |    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
  558|       |    fd, pb_delta(st, which_ ## u, m), \
  559|       |    pb_membersize(st, m), 0, ptr}
  560|       |
  561|       |#define PB_ANONYMOUS_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
  562|       |    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
  563|       |    fd, pb_delta(st, which_ ## u, m), \
  564|       |    pb_membersize(st, m[0]), 0, ptr}
  565|       |
  566|       |#define PB_ANONYMOUS_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
  567|       |        PB_ANONYMOUS_ONEOF_ ## allocation(union_name, tag, message, field, \
  568|       |        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
  569|       |        PB_LTYPE_MAP_ ## type, ptr)
  570|       |
  571|       |/* These macros are used for giving out error messages.
  572|       | * They are mostly a debugging aid; the main error information
  573|       | * is the true/false return value from functions.
  574|       | * Some code space can be saved by disabling the error
  575|       | * messages if not used.
  576|       | *
  577|       | * PB_SET_ERROR() sets the error message if none has been set yet.
  578|       | *                msg must be a constant string literal.
  579|       | * PB_GET_ERROR() always returns a pointer to a string.
  580|       | * PB_RETURN_ERROR() sets the error and returns false from current
  581|       | *                   function.
  582|       | */
  583|       |#ifdef PB_NO_ERRMSG
  584|       |#define PB_SET_ERROR(stream, msg) PB_UNUSED(stream)
  585|       |#define PB_GET_ERROR(stream) "(errmsg disabled)"
  586|       |#else
  587|       |#define PB_SET_ERROR(stream, msg) (stream->errmsg = (stream)->errmsg ? (stream)->errmsg : (msg))
  588|      0|#define PB_GET_ERROR(stream) ((stream)->errmsg ? (stream)->errmsg : "(none)")
  589|       |#endif
  590|       |
  591|       |#define PB_RETURN_ERROR(stream, msg) return PB_SET_ERROR(stream, msg), false
  592|       |
  593|       |#endif

/Users/xschoeman/Documents/git/XouTube/Pods/nanopb/pb_encode.h:
    1|       |/* pb_encode.h: Functions to encode protocol buffers. Depends on pb_encode.c.
    2|       | * The main function is pb_encode. You also need an output stream, and the
    3|       | * field descriptions created by nanopb_generator.py.
    4|       | */
    5|       |
    6|       |#ifndef PB_ENCODE_H_INCLUDED
    7|       |#define PB_ENCODE_H_INCLUDED
    8|       |
    9|       |#include "pb.h"
   10|       |
   11|       |#ifdef __cplusplus
   12|       |extern "C" {
   13|       |#endif
   14|       |
   15|       |/* Structure for defining custom output streams. You will need to provide
   16|       | * a callback function to write the bytes to your storage, which can be
   17|       | * for example a file or a network socket.
   18|       | *
   19|       | * The callback must conform to these rules:
   20|       | *
   21|       | * 1) Return false on IO errors. This will cause encoding to abort.
   22|       | * 2) You can use state to store your own data (e.g. buffer pointer).
   23|       | * 3) pb_write will update bytes_written after your callback runs.
   24|       | * 4) Substreams will modify max_size and bytes_written. Don't use them
   25|       | *    to calculate any pointers.
   26|       | */
   27|       |struct pb_ostream_s
   28|       |{
   29|       |#ifdef PB_BUFFER_ONLY
   30|       |    /* Callback pointer is not used in buffer-only configuration.
   31|       |     * Having an int pointer here allows binary compatibility but
   32|       |     * gives an error if someone tries to assign callback function.
   33|       |     * Also, NULL pointer marks a 'sizing stream' that does not
   34|       |     * write anything.
   35|       |     */
   36|       |    int *callback;
   37|       |#else
   38|       |    bool (*callback)(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
   39|       |#endif
   40|       |    void *state;          /* Free field for use by callback implementation. */
   41|       |    size_t max_size;      /* Limit number of output bytes written (or use SIZE_MAX). */
   42|       |    size_t bytes_written; /* Number of bytes written so far. */
   43|       |    
   44|       |#ifndef PB_NO_ERRMSG
   45|       |    const char *errmsg;
   46|       |#endif
   47|       |};
   48|       |
   49|       |/***************************
   50|       | * Main encoding functions *
   51|       | ***************************/
   52|       |
   53|       |/* Encode a single protocol buffers message from C structure into a stream.
   54|       | * Returns true on success, false on any failure.
   55|       | * The actual struct pointed to by src_struct must match the description in fields.
   56|       | * All required fields in the struct are assumed to have been filled in.
   57|       | *
   58|       | * Example usage:
   59|       | *    MyMessage msg = {};
   60|       | *    uint8_t buffer[64];
   61|       | *    pb_ostream_t stream;
   62|       | *
   63|       | *    msg.field1 = 42;
   64|       | *    stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
   65|       | *    pb_encode(&stream, MyMessage_fields, &msg);
   66|       | */
   67|       |bool pb_encode(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   68|       |
   69|       |/* Same as pb_encode, but prepends the length of the message as a varint.
   70|       | * Corresponds to writeDelimitedTo() in Google's protobuf API.
   71|       | */
   72|       |bool pb_encode_delimited(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   73|       |
   74|       |/* Same as pb_encode, but appends a null byte to the message for termination.
   75|       | * NOTE: This behaviour is not supported in most other protobuf implementations, so pb_encode_delimited()
   76|       | * is a better option for compatibility.
   77|       | */
   78|       |bool pb_encode_nullterminated(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
   79|       |
   80|       |/* Encode the message to get the size of the encoded data, but do not store
   81|       | * the data. */
   82|       |bool pb_get_encoded_size(size_t *size, const pb_field_t fields[], const void *src_struct);
   83|       |
   84|       |/**************************************
   85|       | * Functions for manipulating streams *
   86|       | **************************************/
   87|       |
   88|       |/* Create an output stream for writing into a memory buffer.
   89|       | * The number of bytes written can be found in stream.bytes_written after
   90|       | * encoding the message.
   91|       | *
   92|       | * Alternatively, you can use a custom stream that writes directly to e.g.
   93|       | * a file or a network socket.
   94|       | */
   95|       |pb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize);
   96|       |
   97|       |/* Pseudo-stream for measuring the size of a message without actually storing
   98|       | * the encoded data.
   99|       | * 
  100|       | * Example usage:
  101|       | *    MyMessage msg = {};
  102|       | *    pb_ostream_t stream = PB_OSTREAM_SIZING;
  103|       | *    pb_encode(&stream, MyMessage_fields, &msg);
  104|       | *    printf("Message size is %d\n", stream.bytes_written);
  105|       | */
  106|       |#ifndef PB_NO_ERRMSG
  107|      5|#define PB_OSTREAM_SIZING {0,0,0,0,0}
  108|       |#else
  109|       |#define PB_OSTREAM_SIZING {0,0,0,0}
  110|       |#endif
  111|       |
  112|       |/* Function to write into a pb_ostream_t stream. You can use this if you need
  113|       | * to append or prepend some custom headers to the message.
  114|       | */
  115|       |bool pb_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
  116|       |
  117|       |
  118|       |/************************************************
  119|       | * Helper functions for writing field callbacks *
  120|       | ************************************************/
  121|       |
  122|       |/* Encode field header based on type and field number defined in the field
  123|       | * structure. Call this from the callback before writing out field contents. */
  124|       |bool pb_encode_tag_for_field(pb_ostream_t *stream, const pb_field_t *field);
  125|       |
  126|       |/* Encode field header by manually specifing wire type. You need to use this
  127|       | * if you want to write out packed arrays from a callback field. */
  128|       |bool pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, uint32_t field_number);
  129|       |
  130|       |/* Encode an integer in the varint format.
  131|       | * This works for bool, enum, int32, int64, uint32 and uint64 field types. */
  132|       |#ifndef PB_WITHOUT_64BIT
  133|       |bool pb_encode_varint(pb_ostream_t *stream, uint64_t value);
  134|       |#else
  135|       |bool pb_encode_varint(pb_ostream_t *stream, uint32_t value);
  136|       |#endif
  137|       |
  138|       |/* Encode an integer in the zig-zagged svarint format.
  139|       | * This works for sint32 and sint64. */
  140|       |#ifndef PB_WITHOUT_64BIT
  141|       |bool pb_encode_svarint(pb_ostream_t *stream, int64_t value);
  142|       |#else
  143|       |bool pb_encode_svarint(pb_ostream_t *stream, int32_t value);
  144|       |#endif
  145|       |
  146|       |/* Encode a string or bytes type field. For strings, pass strlen(s) as size. */
  147|       |bool pb_encode_string(pb_ostream_t *stream, const pb_byte_t *buffer, size_t size);
  148|       |
  149|       |/* Encode a fixed32, sfixed32 or float value.
  150|       | * You need to pass a pointer to a 4-byte wide C variable. */
  151|       |bool pb_encode_fixed32(pb_ostream_t *stream, const void *value);
  152|       |
  153|       |#ifndef PB_WITHOUT_64BIT
  154|       |/* Encode a fixed64, sfixed64 or double value.
  155|       | * You need to pass a pointer to a 8-byte wide C variable. */
  156|       |bool pb_encode_fixed64(pb_ostream_t *stream, const void *value);
  157|       |#endif
  158|       |
  159|       |/* Encode a submessage field.
  160|       | * You need to pass the pb_field_t array and pointer to struct, just like
  161|       | * with pb_encode(). This internally encodes the submessage twice, first to
  162|       | * calculate message size and then to actually write it out.
  163|       | */
  164|       |bool pb_encode_submessage(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
  165|       |
  166|       |#ifdef __cplusplus
  167|       |} /* extern "C" */
  168|       |#endif
  169|       |
  170|       |#endif

/Users/xschoeman/Documents/git/XouTube/XouTube/AppDelegate.swift:
    1|       |//
    2|       |//  AppDelegate.swift
    3|       |//  XouTube
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/02/05.
    6|       |//  Copyright © 2020 Xander Schoeman. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import Firebase
   11|       |
   12|       |@UIApplicationMain
   13|       |class AppDelegate: UIResponder, UIApplicationDelegate {
   14|       |    func application(_ application: UIApplication,
   15|      1|                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
   16|      1|        // Override point for customization after application launch.
   17|      1|        FirebaseApp.configure()
   18|      1|        return true
   19|      1|    }
   20|       |
   21|       |    // MARK: UISceneSession Lifecycle
   22|       |
   23|       |    func application(_ application: UIApplication,
   24|       |                     configurationForConnecting connectingSceneSession: UISceneSession,
   25|      0|                     options: UIScene.ConnectionOptions) -> UISceneConfiguration {
   26|      0|        // Called when a new scene session is being created.
   27|      0|        // Use this method to select a configuration to create the new scene with.
   28|      0|        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
   29|      0|    }
   30|       |
   31|      0|    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
   32|      0|        // Called when the user discards a scene session.
   33|      0|        // If any sessions were discarded while
   34|      0|        //the application was not running, this will be
   35|      0|        //called shortly after application:didFinishLaunchingWithOptions.
   36|      0|        // Use this method to release any resources that
   37|      0|        //were specific to the discarded scenes, as they will not return.
   38|      0|    }
   39|       |
   40|       |}

/Users/xschoeman/Documents/git/XouTube/XouTube/MVVMView/AnimeDetailedInfoView.swift:
    1|       |//
    2|       |//  AnimeDetailedInfoView.swift
    3|       |//  XouTube
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/19.
    6|       |//  Copyright © 2020 Xander Schoeman. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |import XouDevSpec
   12|       |import Firebase
   13|       |
   14|       |public var faveAnimeListViewModelObject = [AnimeTableViewModel]()
   15|       |public class AnimeDetailedInfoView: UIViewController {
   16|       |
   17|       |    @IBOutlet weak var lblAnimeTitle: UILabel!
   18|       |    @IBOutlet weak var imgAnimeImage: UIImageView!
   19|       |    @IBOutlet weak var txtViewAnimeSynopsis: UITextView!
   20|       |    @IBOutlet weak var lblAnimeScore: UILabel!
   21|       |    @IBOutlet weak var lblAnimeEpisodes: UILabel!
   22|       |    @IBOutlet weak var lblAnimeRated: UILabel!
   23|       |    @IBOutlet weak var lblAnimeStartDate: UILabel!
   24|       |    @IBOutlet weak var lblAnimeEndDate: UILabel!
   25|       |    @IBOutlet weak var lblAnimeAiring: UILabel!
   26|       |    @IBOutlet weak var lblAnimeURL: UILabel!
   27|      0|    @IBAction func btnFavourite(_ sender: UIButton) {
   28|      0|        Analytics.logEvent("FavouriteAnimePressed", parameters: nil)
   29|      0|        var fave = AnimeTableViewModel()
   30|      0|        fave.airing = animeList.airing ?? true
   31|      0|        fave.start_date = animeList.start_date ?? ""
   32|      0|        fave.end_date = animeList.end_date ?? ""
   33|      0|        fave.mal_id = animeList.mal_id ?? 0
   34|      0|        fave.members = animeList.members ?? 0
   35|      0|        fave.rated = animeList.rated ?? ""
   36|      0|        fave.image_url = animeList.image_url ?? ""
   37|      0|        fave.url = animeList.url ?? ""
   38|      0|        fave.synopsis = animeList.synopsis ?? ""
   39|      0|        fave.end_date = animeList.end_date ?? ""
   40|      0|        fave.title = animeList.title ?? "Unknown"
   41|      0|        fave.episodes = animeList.episodes ?? 0
   42|      0|        fave.score = animeList.score ?? 0.0
   43|      0|        fave.type = animeList.type ?? ""
   44|      0|        faveAnimeListViewModelObject.append(fave)
   45|      0|        displayDefaultAlert(title: "Added to favourites!", message: "= )")
   46|      0|    }
   47|       |    var animeList = AnimeTableViewModel()
   48|       |
   49|      0|    override public func viewDidLoad() {
   50|      0|        super.viewDidLoad()
   51|      0|        lblAnimeTitle.text = animeList.title
   52|      0|        if let imageUrl = animeList.image_url {
   53|      0|          imgAnimeImage.loadImageUsingUrlString(urlString: imageUrl)
   54|      0|        }
   55|      0|        txtViewAnimeSynopsis.text = animeList.synopsis
   56|      0|        lblAnimeScore.text = "\(animeList.score ?? 0.0)"
   57|      0|        lblAnimeEpisodes.text = "\(animeList.episodes ?? 0)"
   58|      0|        lblAnimeRated.text = animeList.rated
   59|      0|        lblAnimeStartDate.text = animeList.start_date
   60|      0|        lblAnimeEndDate.text = animeList.end_date
   61|      0|        lblAnimeURL.text = animeList.type
   62|      0|        if animeList.airing ?? false {
   63|      0|            lblAnimeAiring.text = "True"
   64|      0|        } else {
   65|      0|            lblAnimeAiring.text = "False"
   66|      0|        }
   67|      0|    }
   68|      0|    func displayDefaultAlert(title: String?, message: String?) {
   69|      0|        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
   70|      0|        let okAction = UIAlertAction(title: "Ok", style: .default, handler: nil)
   71|      0|        alert.addAction(okAction)
   72|      0|        self.present(alert, animated: true, completion: nil)
   73|      0|    }
   74|       |}

/Users/xschoeman/Documents/git/XouTube/XouTube/MVVMView/AnimeTable.swift:
    1|       |//
    2|       |//  AnimeTable.swift
    3|       |//  XouTube
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/03.
    6|       |//  Copyright © 2020 Xander Schoeman. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import XouDevSpec
   11|       |import Firebase
   12|       |
   13|       |public class AnimeTable: UITableViewController {
   14|       |    @IBOutlet weak var tableViewAnime: UITableView!
   15|       |    @IBOutlet weak var srchBar: UISearchBar!
   16|       |    var animeViewModel = [AnimeTableViewModel]()
   17|       |    var animeListt = [AnimeTableViewModel]()
   18|       |    var animeList = [AnimeTableViewModel]() {
   19|      0|        didSet {
   20|      0|            DispatchQueue.main.async {
   21|      0|                self.tableView.reloadData()
   22|      0|                self.navigationItem.title = "Anime: \(self.animeList.count)"
   23|      0|            }
   24|      0|        }
   25|       |    }
   26|       |
   27|      0|    override public func viewDidLoad() {
   28|      0|    super.viewDidLoad()
   29|      0|    fetchTopData()
   30|      0|                     }
   31|      0|    public func fetchTopData() {
   32|      0|        var apiCaller = ApiCallerRepo()
   33|      0|        apiCaller.getAnimeTopData { [weak self] result in
   34|      0|        switch result {
   35|      0|        case .failure( let error):
   36|      0|        print(error)
   37|      0|        case .success(let animes):
   38|      0|        self?.animeViewModel = animes.map({return AnimeTableViewModel(topAnime: $0)})
   39|      0|        DispatchQueue.main.async {
   40|      0|        self?.tableView.reloadData()
   41|      0|           }
   42|      0|        }
   43|      0|        }
   44|      0|    }
   45|       |
   46|       |}
   47|       |
   48|       | extension AnimeTable: UISearchBarDelegate {
   49|      0|        public override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   50|      0|                return animeViewModel.count
   51|      0|        }
   52|      0|    public override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   53|      0|            let cell = tableView.dequeueReusableCell(withIdentifier: "animeVidCell", for: indexPath) as? AnimeVideoCell
   54|      0|            let anime = animeViewModel[indexPath.row]
   55|      0|            cell?.animeViewModel = anime
   56|      0|            return cell!
   57|      0|        }
   58|      0|        public override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
   59|      0|            Analytics.logEvent(AnalyticsEventSelectItem, parameters: ["AnimeItemFromApiSelected": indexPath.row])
   60|      0|            let newViewController = storyboard?.instantiateViewController(withIdentifier:
   61|      0|                "AnimeDetailedInfoID") as? AnimeDetailedInfoView
   62|      0|            newViewController?.animeList = animeViewModel[indexPath.row]
   63|      0|            self.navigationController?.pushViewController(newViewController!, animated: true)
   64|      0|        }
   65|      0|    public func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
   66|      0|        Analytics.logEvent(AnalyticsEventSearch, parameters: ["AnimeSearchValue": searchBar.text as Any])
   67|      0|        var objcGenreglobal = GlobalDataGenre()
   68|      0|        print(objcGenreglobal.genre)
   69|      0|        let replacedString = searchBar.text?.replacingOccurrences(of: " ", with: "%20")
   70|      0|        guard let searchBarText = replacedString else {return}
   71|      0|        let apiCaller = ApiCallerRepo.init(SearchText: searchBarText, GenreSelected: objcGenreglobal.message)
   72|      0|        apiCaller.getAnimeData { [weak self] result in
   73|      0|            switch result {
   74|      0|            case .failure( let error):
   75|      0|            print(error)
   76|      0|            case .success(let animes):
   77|      0|            self?.animeViewModel = animes.map({return AnimeTableViewModel(SearchedAnime: $0)})
   78|      0|            DispatchQueue.main.async {
   79|      0|            self?.tableView.reloadData()
   80|      0|            }
   81|      0|        }
   82|      0|        }
   83|      0|    }
   84|       |    }

/Users/xschoeman/Documents/git/XouTube/XouTube/MVVMView/FavouritesView.swift:
    1|       |//
    2|       |//  FavouritesView.swift
    3|       |//  XouTube
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/23.
    6|       |//  Copyright © 2020 Xander Schoeman. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import XouDevSpec
   11|       |import Firebase
   12|       |
   13|       |public class FavouritesView: UITableViewController {
   14|       |    @IBOutlet weak var tableViewAnime: UITableView!
   15|       |
   16|       |    var mangaList = faveMangaListViewModelObject {
   17|      0|        didSet {
   18|      0|            DispatchQueue.main.async {
   19|      0|                self.tableView.reloadData()
   20|      0|                self.navigationItem.title = "Favourites Left: \(self.animeList.count + self.mangaList.count)"
   21|      0|            }
   22|      0|        }
   23|       |    }
   24|       |    var animeList = faveAnimeListViewModelObject {
   25|      0|        didSet {
   26|      0|            DispatchQueue.main.async {
   27|      0|                self.tableView.reloadData()
   28|      0|                self.navigationItem.title = "Favourites Left: \(self.animeList.count + self.mangaList.count)"
   29|      0|            }
   30|      0|        }
   31|       |    }
   32|      0|    override public func viewDidLoad() {
   33|      0|        super.viewDidLoad()
   34|      0|                     }
   35|      0|    override public func viewDidAppear(_ animated: Bool) {
   36|      0|    }
   37|       |
   38|       |}
   39|       |
   40|       |extension FavouritesView {
   41|       |
   42|      0|    override public func numberOfSections(in tableView: UITableView) -> Int {
   43|      0|        return 2
   44|      0|    }
   45|      0|        public override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   46|      0|           var numberOfRows = 1
   47|      0|            if (section == 0) {
   48|      0|              numberOfRows =  animeList.count
   49|      0|                return numberOfRows
   50|      0|            } else if (section == 1) {
   51|      0|               numberOfRows =  mangaList.count
   52|      0|               return numberOfRows
   53|      0|            }
   54|      0|            return numberOfRows
   55|      0|        }
   56|       |        //swiftlint:disable all
   57|      0|        public override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   58|      0|            var cell = AnimeFavouriteCell()
   59|      0|            switch indexPath.section {
   60|      0|             case 0:
   61|      0|                cell = tableView.dequeueReusableCell(withIdentifier: "animeFavouriteCell", for: indexPath) as! AnimeFavouriteCell
   62|      0|             let anime = animeList[indexPath.row]
   63|      0|             cell.animeViewModel = anime
   64|      0|             case 1:
   65|      0|             cell = tableView.dequeueReusableCell(withIdentifier: "mangaFavouriteCell", for: indexPath) as! AnimeFavouriteCell
   66|      0|             let manga = mangaList[indexPath.row]
   67|      0|             cell.mangaViewModel = manga
   68|      0|             default:
   69|      0|             print("An error has occured in the table cells")
   70|      0|               }
   71|      0|             return cell
   72|      0|        }
   73|       |        //swiftlint:enable all
   74|       |    public override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle,
   75|      0|                                   forRowAt indexPath: IndexPath) {
   76|      0|        switch indexPath.section {
   77|      0|         case 0:
   78|      0|         if editingStyle == .delete {
   79|      0|         Analytics.logEvent("AnimeDeleted", parameters: nil)
   80|      0|         animeList.remove(at: indexPath.row)
   81|      0|         tableView.deleteRows(at: [indexPath], with: .bottom)
   82|      0|         faveAnimeListViewModelObject.remove(at: indexPath.row)
   83|      0|         }
   84|      0|         case 1:
   85|      0|         if editingStyle == .delete {
   86|      0|         Analytics.logEvent("MangaDeleted", parameters: nil)
   87|      0|         mangaList.remove(at: indexPath.row)
   88|      0|         tableView.deleteRows(at: [indexPath], with: .bottom)
   89|      0|         faveMangaListViewModelObject.remove(at: indexPath.row)
   90|      0|         }
   91|      0|         default:
   92|      0|         print("An error has occured in the table delete")
   93|      0|           }
   94|      0|    }
   95|       |
   96|       |    }

/Users/xschoeman/Documents/git/XouTube/XouTube/MVVMView/HomeView.m:
    1|       |//
    2|       |//  HomeView.m
    3|       |//  XouTube
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/30.
    6|       |//  Copyright © 2020 Xander Schoeman. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "HomeView.h"
   10|       |#import "GenreModel.h"
   11|       |#import "GlobalDataGenre.h"
   12|       |
   13|       |@interface HomeView ()
   14|       |
   15|       |@end
   16|       |
   17|       |@implementation HomeView
   18|       |
   19|      0|- (IBAction)btnAction:(id)sender {
   20|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Action&"];
   21|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   22|      0|    _lblWelcome.text = @"Action";
   23|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   24|      0|    //[GlobalDataGenre sharedGlobalData].message;;
   25|      0|}
   26|       |
   27|      0|- (IBAction)btnGame:(id)sender {
   28|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Game&"];
   29|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   30|      0|    _lblWelcome.text = @"Game";
   31|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   32|      0|}
   33|       |
   34|      0|- (IBAction)btnSliceOfLife:(id)sender {
   35|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Slice%20Of%20Life&"];
   36|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   37|      0|    _lblWelcome.text = @"Slice Of Life";
   38|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   39|      0|}
   40|       |
   41|      0|- (IBAction)btnSuperPower:(id)sender {
   42|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Super%20Power&"];
   43|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   44|      0|    _lblWelcome.text = @"Super Power";
   45|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   46|      0|}
   47|       |
   48|      0|- (IBAction)btnAdventure:(id)sender {
   49|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Adventure&"];
   50|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   51|      0|    _lblWelcome.text = @"Adventure";
   52|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   53|      0|}
   54|       |
   55|      0|- (IBAction)btnMilitary:(id)sender {
   56|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Military&"];
   57|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   58|      0|    _lblWelcome.text = @"Military";
   59|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   60|      0|}
   61|       |
   62|      0|- (IBAction)btnRomance:(id)sender {
   63|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Romance&"];
   64|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   65|      0|    _lblWelcome.text = @"Romance";
   66|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   67|      0|}
   68|       |
   69|      0|- (IBAction)btnVampire:(id)sender {
   70|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Vampire&"];
   71|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   72|      0|    _lblWelcome.text = @"Vampire";
   73|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   74|      0|}
   75|       |
   76|      0|- (IBAction)btnSports:(id)sender {
   77|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Sports&"];
   78|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   79|      0|    _lblWelcome.text = @"Sports";
   80|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   81|      0|}
   82|       |
   83|      0|- (IBAction)btnSupernatural:(id)sender {
   84|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Supernatural&"];
   85|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   86|      0|    _lblWelcome.text = @"Supernatural";
   87|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   88|      0|}
   89|       |
   90|      0|- (IBAction)btnSchool:(id)sender {
   91|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=School&"];
   92|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
   93|      0|    _lblWelcome.text = @"School";
   94|      0|    _lblWelcome.textColor = UIColor.orangeColor;
   95|      0|}
   96|       |
   97|      0|- (IBAction)btnDrama:(id)sender {
   98|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Drama&"];
   99|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
  100|      0|    _lblWelcome.text = @"Drama";
  101|      0|    _lblWelcome.textColor = UIColor.orangeColor;
  102|      0|}
  103|       |
  104|      0|- (IBAction)btnComedy:(id)sender {
  105|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Comedy&"];
  106|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
  107|      0|    _lblWelcome.text = @"Comedy";
  108|      0|    _lblWelcome.textColor = UIColor.orangeColor;
  109|      0|}
  110|       |
  111|      0|- (IBAction)btnHorror:(id)sender {
  112|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Horror&"];
  113|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
  114|      0|    _lblWelcome.text = @"Horror";
  115|      0|    _lblWelcome.textColor = UIColor.orangeColor;
  116|      0|}
  117|       |
  118|      0|- (IBAction)btnSciFi:(id)sender {
  119|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Sci%20Fi&"];
  120|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
  121|      0|    _lblWelcome.text = @"SciFi";
  122|      0|    _lblWelcome.textColor = UIColor.orangeColor;
  123|      0|}
  124|       |
  125|      0|- (IBAction)btnFantasy:(id)sender {
  126|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Fantasy&"];
  127|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
  128|      0|    _lblWelcome.text = @"Fantasy";
  129|      0|    _lblWelcome.textColor = UIColor.orangeColor;
  130|      0|}
  131|       |
  132|      0|- (IBAction)btnMartialArts:(id)sender {
  133|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Martial%20Arts&"];
  134|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
  135|      0|    _lblWelcome.text = @"Martial Arts";
  136|      0|    _lblWelcome.textColor = UIColor.orangeColor;
  137|      0|}
  138|       |
  139|      0|- (IBAction)btnKids:(id)sender {
  140|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Kids&"];
  141|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
  142|      0|    _lblWelcome.text = @"Kids";
  143|      0|    _lblWelcome.textColor = UIColor.orangeColor;
  144|      0|}
  145|       |
  146|      0|- (IBAction)btnMagic:(id)sender {
  147|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Magic&"];
  148|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
  149|      0|    _lblWelcome.text = @"Magic";
  150|      0|    _lblWelcome.textColor = UIColor.orangeColor;
  151|      0|}
  152|       |
  153|      0|- (IBAction)btnMystery:(id)sender {
  154|      0|    [[GlobalDataGenre sharedGlobalData] initWith: @"genre=Mystery&"];
  155|      0|    [[GlobalDataGenre sharedGlobalData] mySetMessageFunc];
  156|      0|    _lblWelcome.text = @"Mystery";
  157|      0|    _lblWelcome.textColor = UIColor.orangeColor;
  158|      0|}
  159|       |
  160|      1|- (void)viewDidLoad {
  161|      1|    [super viewDidLoad];
  162|      1|}
  163|       |
  164|       |
  165|       |
  166|      0|- (IBAction)btnAnime:(id)sender {
  167|      0|[self performSelector:@selector(showAnime) withObject:nil];
  168|      0|}
  169|       |
  170|      0|- (IBAction)btnManga:(id)sender {
  171|      0|[self performSelector:@selector(showManga) withObject:nil];
  172|      0|}
  173|       |
  174|      0|- (IBAction)btnFaves:(id)sender {
  175|      0|[self performSelector:@selector(showFaves) withObject:nil];
  176|      0|}
  177|       |
  178|      0|- (IBAction)btnProfile:(id)sender {
  179|      0|[self performSelector:@selector(showProfile) withObject:nil];
  180|      0|}
  181|       |
  182|      0|-(void)showAnime {
  183|      0|    [self performSegueWithIdentifier:@"segAnimeTable" sender:self];
  184|      0|}
  185|      0|-(void)showManga {
  186|      0|    [self performSegueWithIdentifier:@"segMangaTable" sender:self];
  187|      0|}
  188|      0|-(void)showFaves {
  189|      0|    [self performSegueWithIdentifier:@"segFavourites" sender:self];
  190|      0|}
  191|      0|-(void)showProfile {
  192|      0|    [self performSegueWithIdentifier:@"segProfile" sender:self];
  193|      0|}
  194|       |@end

/Users/xschoeman/Documents/git/XouTube/XouTube/MVVMView/MangaDetailedInfoView.swift:
    1|       |//
    2|       |//  MangaDetailedInfoView.swift
    3|       |//  XouTube
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/26.
    6|       |//  Copyright © 2020 Xander Schoeman. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |import XouDevSpec
   12|       |import Firebase
   13|       |
   14|       |public var faveMangaListViewModelObject = [MangaTableViewModel]()
   15|       |public class MangaDetailedInfoView: UIViewController {
   16|       |
   17|       |    @IBOutlet weak var lblAnimeTitle: UILabel!
   18|       |    @IBOutlet weak var imgAnimeImage: UIImageView!
   19|       |    @IBOutlet weak var txtViewAnimeSynopsis: UITextView!
   20|       |    @IBOutlet weak var lblAnimeScore: UILabel!
   21|       |    @IBOutlet weak var lblAnimeEpisodes: UILabel!
   22|       |    @IBOutlet weak var lblAnimeRated: UILabel!
   23|       |    @IBOutlet weak var lblAnimeStartDate: UILabel!
   24|       |    @IBOutlet weak var lblAnimeEndDate: UILabel!
   25|       |    @IBOutlet weak var lblAnimeAiring: UILabel!
   26|       |    @IBOutlet weak var lblAnimeURL: UILabel!
   27|      0|    @IBAction func btnFavourite(_ sender: UIButton) {
   28|      0|        Analytics.logEvent("FavouriteMangaPressed", parameters: nil)
   29|      0|        var fave = MangaTableViewModel()
   30|      0|        fave.publishing = mangaList.publishing ?? true
   31|      0|        fave.start_date = mangaList.start_date ?? ""
   32|      0|        fave.end_date = mangaList.end_date ?? ""
   33|      0|        fave.mal_id = mangaList.mal_id ?? 0
   34|      0|        fave.members = mangaList.members ?? 0
   35|      0|        fave.chapters = mangaList.chapters ?? 0
   36|      0|        fave.image_url = mangaList.image_url ?? ""
   37|      0|        fave.url = mangaList.url ?? ""
   38|      0|        fave.synopsis = mangaList.synopsis ?? ""
   39|      0|        fave.end_date = mangaList.end_date ?? ""
   40|      0|        fave.title = mangaList.title ?? "Unknown"
   41|      0|        fave.volumes = mangaList.volumes ?? 0
   42|      0|        fave.score = mangaList.score ?? 0.0
   43|      0|        fave.type = mangaList.type ?? ""
   44|      0|        faveMangaListViewModelObject.append(fave)
   45|      0|        displayDefaultAlert(title: "Added to favourites!", message: " = )")
   46|      0|    }
   47|       |    var mangaList = MangaTableViewModel()
   48|       |
   49|      0|    override public func viewDidLoad() {
   50|      0|        super.viewDidLoad()
   51|      0|        lblAnimeTitle.text = mangaList.title
   52|      0|        if let imageUrl = mangaList.image_url {
   53|      0|          imgAnimeImage.loadImageUsingUrlString(urlString: imageUrl)
   54|      0|        }
   55|      0|        txtViewAnimeSynopsis.text = mangaList.synopsis
   56|      0|        lblAnimeScore.text = "\(mangaList.score ?? 0.0)"
   57|      0|        lblAnimeEpisodes.text = "\(mangaList.chapters ?? 0)"
   58|      0|        lblAnimeRated.text = "\(mangaList.volumes ?? 0)"
   59|      0|        lblAnimeStartDate.text = mangaList.start_date
   60|      0|        lblAnimeEndDate.text = mangaList.end_date
   61|      0|        lblAnimeURL.text = mangaList.type
   62|      0|        if mangaList.publishing ?? false {
   63|      0|            lblAnimeAiring.text = "True"
   64|      0|        } else {
   65|      0|            lblAnimeAiring.text = "False"
   66|      0|        }
   67|      0|    }
   68|      0|    func displayDefaultAlert(title: String?, message: String?) {
   69|      0|        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
   70|      0|        let okAction = UIAlertAction(title: "Ok", style: .default, handler: nil)
   71|      0|        alert.addAction(okAction)
   72|      0|        self.present(alert, animated: true, completion: nil)
   73|      0|    }
   74|       |}

/Users/xschoeman/Documents/git/XouTube/XouTube/MVVMView/MangaTableView.swift:
    1|       |//
    2|       |//  MangaTableView.swift
    3|       |//  XouTube
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/26.
    6|       |//  Copyright © 2020 Xander Schoeman. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import XouDevSpec
   11|       |import Firebase
   12|       |
   13|       |public class MangaTableView: UITableViewController {
   14|       |    @IBOutlet weak var tableViewAnime: UITableView!
   15|       |    @IBOutlet weak var searchBar: UISearchBar!
   16|       |    var mangaList = [MangaTableViewModel]() {
   17|      0|        didSet {
   18|      0|            DispatchQueue.main.async {
   19|      0|                self.tableView.reloadData()
   20|      0|                self.navigationItem.title = "Manga: \(self.mangaList.count)"
   21|      0|            }
   22|      0|        }
   23|       |    }
   24|      0|    override public func viewDidLoad() {
   25|      0|        super.viewDidLoad()
   26|      0|                     }
   27|      0|    override public func viewDidAppear(_ animated: Bool) {
   28|      0|    }
   29|       |
   30|       |}
   31|       |extension MangaTableView: UISearchBarDelegate {
   32|      0|        public override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   33|      0|            return mangaList.count
   34|      0|        }
   35|       |        //swiftlint:disable all
   36|      0|        public override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   37|      0|            let cell = tableView.dequeueReusableCell(withIdentifier: "animeVidCell", for: indexPath) as! AnimeVideoCell
   38|      0|            let manga = mangaList[indexPath.row]
   39|      0|            cell.mangaViewModel = manga
   40|      0|            return cell
   41|      0|        }
   42|       |        //swiftlint:enable all
   43|      0|        public override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
   44|      0|            Analytics.logEvent(AnalyticsEventSelectItem, parameters: ["MangaItemFromApiSelected": indexPath.row])
   45|      0|            let newViewController = storyboard?.instantiateViewController(withIdentifier:
   46|      0|                "MangaDetailedInfoID") as? MangaDetailedInfoView
   47|      0|            newViewController?.mangaList = mangaList[indexPath.row]
   48|      0|            self.navigationController?.pushViewController(newViewController!, animated: true)
   49|      0|        }
   50|      0|    public func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
   51|      0|        Analytics.logEvent(AnalyticsEventSearch, parameters: ["MangaSearchValue": searchBar.text as Any])
   52|      0|          var objcGenreglobal = GlobalDataGenre()
   53|      0|          let replacedString = searchBar.text?.replacingOccurrences(of: " ", with: "%20")
   54|      0|          guard let searchBarText = replacedString else {return}
   55|      0|        let apiCaller = ApiCallerRepo.init(SearchText: searchBarText, GenreSelected: objcGenreglobal.message)
   56|      0|          apiCaller.getMangaData { [weak self] result in
   57|      0|              switch result {
   58|      0|              case .failure( let error):
   59|      0|                  print(error)
   60|      0|              case .success(let animes):
   61|      0|                  self?.mangaList = animes.map({return MangaTableViewModel(SearchedManga: $0)})
   62|      0|                  DispatchQueue.main.async {
   63|      0|                  self?.tableView.reloadData()
   64|      0|                  }
   65|      0|          }
   66|      0|          }
   67|      0|    }
   68|       |    }

/Users/xschoeman/Documents/git/XouTube/XouTube/MVVMView/ProfileView.swift:
    1|       |//
    2|       |//  ProfileView.swift
    3|       |//  XouTube
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/03/30.
    6|       |//  Copyright © 2020 Xander Schoeman. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import Firebase
   11|       |
   12|       |class ProfileView: UIViewController {
   13|      0|    @IBAction func btnSignIn(_ sender: UIButton) {
   14|      0|        Analytics.logEvent("SignInPressed", parameters: nil)
   15|      0|    }
   16|      0|    @IBAction func btnSignUp(_ sender: UIButton) {
   17|      0|        Analytics.logEvent("SignUpPressed", parameters: nil)
   18|      0|    }
   19|      0|    override func viewDidLoad() {
   20|      0|        super.viewDidLoad()
   21|      0|
   22|      0|    }
   23|       |
   24|       |}

/Users/xschoeman/Documents/git/XouTube/XouTube/SceneDelegate.swift:
    1|       |//
    2|       |//  SceneDelegate.swift
    3|       |//  XouTube
    4|       |//
    5|       |//  Created by Xander Schoeman on 2020/02/05.
    6|       |//  Copyright © 2020 Xander Schoeman. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class SceneDelegate: UIResponder, UIWindowSceneDelegate {
   12|       |
   13|       |    var window: UIWindow?
   14|       |
   15|       |    func scene(_ scene: UIScene, willConnectTo session: UISceneSession,
   16|      1|               options connectionOptions: UIScene.ConnectionOptions) {
   17|      1|        // Use this method to optionally configure and attach the UIWindow
   18|      1|        //`window` to the provided UIWindowScene `scene`.
   19|      1|        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
   20|      1|        // This delegate does not imply the connecting scene
   21|      1|        //or session are new (see `application:configurationForConnectingSceneSession` instead).
   22|      1|        //let layout = UICollectionViewFlowLayout()
   23|      1|       // window?.rootViewController =
   24|      1|      //  UINavigationController(rootViewController: MainView(collectionViewLayout: layout))
   25|      1|        guard let _ = (scene as? UIWindowScene) else { return }
   26|      1|    }
   27|       |
   28|      0|    func sceneDidDisconnect(_ scene: UIScene) {
   29|      0|        // Called as the scene is being released by the system.
   30|      0|        // This occurs shortly after the scene enters the background, or when its session is discarded.
   31|      0|        // Release any resources associated with this scene that can be re-created the next time the scene connects.
   32|      0|        // The scene may re-connect later, as its session was not
   33|      0|        //neccessarily discarded (see `application:didDiscardSceneSessions` instead).
   34|      0|    }
   35|       |
   36|      1|    func sceneDidBecomeActive(_ scene: UIScene) {
   37|      1|        // Called when the scene has moved from an inactive state to an active state.
   38|      1|        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
   39|      1|    }
   40|       |
   41|      0|    func sceneWillResignActive(_ scene: UIScene) {
   42|      0|        // Called when the scene will move from an active state to an inactive state.
   43|      0|        // This may occur due to temporary interruptions (ex. an incoming phone call).
   44|      0|    }
   45|       |
   46|      1|    func sceneWillEnterForeground(_ scene: UIScene) {
   47|      1|        // Called as the scene transitions from the background to the foreground.
   48|      1|        // Use this method to undo the changes made on entering the background.
   49|      1|    }
   50|       |
   51|      0|    func sceneDidEnterBackground(_ scene: UIScene) {
   52|      0|        // Called as the scene transitions from the foreground to the background.
   53|      0|        // Use this method to save data, release shared resources, and store enough scene-specific state information
   54|      0|        // to restore the scene back to its current state.
   55|      0|    }
   56|       |}

